{{
  "language": "Solidity",
  "settings": {
    "evmVersion": "london",
    "libraries": {},
    "metadata": {
      "bytecodeHash": "ipfs",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 9999
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "contracts/external/@openzeppelin/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n"
    },
    "contracts/external/@openzeppelin/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/utils/SafeERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../IERC20.sol\";\r\nimport \"../../../utils/Address.sol\";\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        unchecked {\r\n            uint256 oldAllowance = token.allowance(address(this), spender);\r\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\r\n            uint256 newAllowance = oldAllowance - value;\r\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) {\r\n            // Return data is optional\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/external/@openzeppelin/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.0 (utils/Address.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\r\n     * revert reason using the provided one.\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/external/@openzeppelin/utils/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\r\n * checks.\r\n *\r\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\r\n * easily result in undesired exploitation or bugs, since developers usually\r\n * assume that overflows raise errors. `SafeCast` restores this intuition by\r\n * reverting the transaction when such an operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n *\r\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\r\n * all math on `uint256` and `int256` and then downcasting.\r\n */\r\nlibrary SafeCast {\r\n    /**\r\n     * @dev Returns the downcasted uint224 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint224).\r\n     *\r\n     * Counterpart to Solidity's `uint224` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 224 bits\r\n     */\r\n    function toUint224(uint256 value) internal pure returns (uint224) {\r\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\r\n        return uint224(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint192 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint192).\r\n     *\r\n     * Counterpart to Solidity's `uint192` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 192 bits\r\n     */\r\n    function toUint192(uint256 value) internal pure returns (uint192) {\r\n        require(value <= type(uint192).max, \"SafeCast: value doesn't fit in 128 bits\");\r\n        return uint192(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint128 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint128).\r\n     *\r\n     * Counterpart to Solidity's `uint128` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 128 bits\r\n     */\r\n    function toUint128(uint256 value) internal pure returns (uint128) {\r\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\r\n        return uint128(value);\r\n    }\r\n}\r\n"
    },
    "contracts/external/GNSPS-solidity-bytes-utils/BytesLib.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\n/*\r\n * @title Solidity Bytes Arrays Utils\r\n * @author Gonçalo Sá <goncalo.sa@consensys.net>\r\n *\r\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\r\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\r\n */\r\npragma solidity 0.8.11;\r\n\r\nlibrary BytesLib {\r\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\r\n        require(_bytes.length >= _start + 20, 'toAddress_outOfBounds');\r\n        address tempAddress;\r\n\r\n        assembly {\r\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\r\n        }\r\n\r\n        return tempAddress;\r\n    }\r\n\r\n    function toUint24(bytes memory _bytes, uint256 _start) internal pure returns (uint24) {\r\n        require(_bytes.length >= _start + 3, 'toUint24_outOfBounds');\r\n        uint24 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x3), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\r\n        require(_bytes.length >= _start + 1 , \"toUint8_outOfBounds\");\r\n        uint8 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x1), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n}\r\n"
    },
    "contracts/external/interfaces/convex/IBaseRewardPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.11;\r\n\r\nimport \"../../../external/@openzeppelin/token/ERC20/IERC20.sol\";\r\n\r\ninterface IBaseRewardPool {\r\n    function rewardToken() external view returns (IERC20);\r\n\r\n    function rewards(address) external view returns (uint256);\r\n\r\n    function userRewardPerTokenPaid(address) external view returns (uint256);\r\n\r\n    function rewardPerToken() external view returns (uint256);\r\n\r\n    function getReward() external;\r\n\r\n    function extraRewardsLength() external view returns (uint256);\r\n\r\n    function extraReward(uint256 i) external view returns (IERC20);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function withdrawAndUnwrap(uint256 amount, bool claim) external returns(bool);\r\n\r\n    function withdrawAllAndUnwrap(bool claim) external;\r\n}\r\n"
    },
    "contracts/external/interfaces/convex/IBooster.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.11;\r\n\r\ninterface IBooster {\r\n    struct PoolInfo {\r\n        address lptoken;\r\n        address token;\r\n        address gauge;\r\n        address crvRewards;\r\n        address stash;\r\n        bool shutdown;\r\n    }\r\n\r\n    function poolLength() external view returns (uint256);\r\n\r\n    function poolInfo(uint256 i) external view returns (PoolInfo memory);\r\n\r\n    function withdrawAll(uint256 pid) external;\r\n\r\n    function deposit(\r\n        uint256 pid,\r\n        uint256 lp,\r\n        bool stake\r\n    ) external;\r\n\r\n    function withdraw(uint256 pid, uint256 lp) external;\r\n\r\n    function minter() external view returns (address);\r\n}\r\n"
    },
    "contracts/external/interfaces/curve/ICurvePool.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.11;\r\n\r\ninterface ICurvePool {\r\n    function coins(uint256 i) external view returns (address);\r\n\r\n    function remove_liquidity_one_coin(\r\n        uint256 lp,\r\n        int128 i,\r\n        uint256 min_amount\r\n    ) external;\r\n\r\n    function calc_withdraw_one_coin(uint256 lp, int128 i) external view returns (uint256);\r\n\r\n    function balanceOf(address user) external view returns (uint256);\r\n}\r\n"
    },
    "contracts/external/interfaces/curve/IStableSwap3Pool.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.11;\r\n\r\nimport \"./ICurvePool.sol\";\r\n\r\ninterface IStableSwap3Pool is ICurvePool {\r\n    function add_liquidity(uint256[3] calldata amounts, uint256 min_lp) external;\r\n}\r\n"
    },
    "contracts/external/uniswap/interfaces/ISwapRouter02.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.7.5;\r\npragma abicoder v2;\r\n\r\nimport './IV2SwapRouter.sol';\r\nimport './IV3SwapRouter.sol';\r\n\r\n/// @title Router token swapping functionality\r\ninterface ISwapRouter02 is IV2SwapRouter, IV3SwapRouter {\r\n\r\n}\r\n"
    },
    "contracts/external/uniswap/interfaces/IV2SwapRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.7.5;\r\npragma abicoder v2;\r\n\r\n/// @title Router token swapping functionality\r\n/// @notice Functions for swapping tokens via Uniswap V2\r\ninterface IV2SwapRouter {\r\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\r\n    /// @dev Setting `amountIn` to 0 will cause the contract to look up its own balance,\r\n    /// and swap the entire amount, enabling contracts to send tokens before calling this function.\r\n    /// @param amountIn The amount of token to swap\r\n    /// @param amountOutMin The minimum amount of output that must be received\r\n    /// @param path The ordered list of tokens to swap through\r\n    /// @param to The recipient address\r\n    /// @return amountOut The amount of the received token\r\n    function swapExactTokensForTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to\r\n    ) external payable returns (uint256 amountOut);\r\n\r\n    /// @notice Swaps as little as possible of one token for an exact amount of another token\r\n    /// @param amountOut The amount of token to swap for\r\n    /// @param amountInMax The maximum amount of input that the caller will pay\r\n    /// @param path The ordered list of tokens to swap through\r\n    /// @param to The recipient address\r\n    /// @return amountIn The amount of token to pay\r\n    function swapTokensForExactTokens(\r\n        uint256 amountOut,\r\n        uint256 amountInMax,\r\n        address[] calldata path,\r\n        address to\r\n    ) external payable returns (uint256 amountIn);\r\n}\r\n"
    },
    "contracts/external/uniswap/interfaces/IV3SwapRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.7.5;\r\npragma abicoder v2;\r\n\r\n/// @title Router token swapping functionality\r\n/// @notice Functions for swapping tokens via Uniswap V3\r\ninterface IV3SwapRouter{\r\n    struct ExactInputSingleParams {\r\n        address tokenIn;\r\n        address tokenOut;\r\n        uint24 fee;\r\n        address recipient;\r\n        uint256 amountIn;\r\n        uint256 amountOutMinimum;\r\n        uint160 sqrtPriceLimitX96;\r\n    }\r\n\r\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\r\n    /// @dev Setting `amountIn` to 0 will cause the contract to look up its own balance,\r\n    /// and swap the entire amount, enabling contracts to send tokens before calling this function.\r\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\r\n    /// @return amountOut The amount of the received token\r\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\r\n\r\n    struct ExactInputParams {\r\n        bytes path;\r\n        address recipient;\r\n        uint256 amountIn;\r\n        uint256 amountOutMinimum;\r\n    }\r\n\r\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\r\n    /// @dev Setting `amountIn` to 0 will cause the contract to look up its own balance,\r\n    /// and swap the entire amount, enabling contracts to send tokens before calling this function.\r\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\r\n    /// @return amountOut The amount of the received token\r\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\r\n\r\n    struct ExactOutputSingleParams {\r\n        address tokenIn;\r\n        address tokenOut;\r\n        uint24 fee;\r\n        address recipient;\r\n        uint256 amountOut;\r\n        uint256 amountInMaximum;\r\n        uint160 sqrtPriceLimitX96;\r\n    }\r\n\r\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\r\n    /// that may remain in the router after the swap.\r\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\r\n    /// @return amountIn The amount of the input token\r\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\r\n\r\n    struct ExactOutputParams {\r\n        bytes path;\r\n        address recipient;\r\n        uint256 amountOut;\r\n        uint256 amountInMaximum;\r\n    }\r\n\r\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\r\n    /// that may remain in the router after the swap.\r\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\r\n    /// @return amountIn The amount of the input token\r\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\r\n}\r\n"
    },
    "contracts/interfaces/IBaseStrategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n\r\npragma solidity 0.8.11;\r\n\r\nimport \"../external/@openzeppelin/token/ERC20/IERC20.sol\";\r\nimport \"./ISwapData.sol\";\r\n\r\ninterface IBaseStrategy {\r\n    function underlying() external view returns (IERC20);\r\n\r\n    function getStrategyBalance() external view returns (uint128);\r\n\r\n    function getStrategyUnderlyingWithRewards() external view returns(uint128);\r\n\r\n    function process(uint256[] calldata, bool, SwapData[] calldata) external;\r\n\r\n    function processReallocation(uint256[] calldata, ProcessReallocationData calldata) external returns(uint128);\r\n\r\n    function processDeposit(uint256[] calldata) external;\r\n\r\n    function fastWithdraw(uint128, uint256[] calldata, SwapData[] calldata) external returns(uint128);\r\n\r\n    function claimRewards(SwapData[] calldata) external;\r\n\r\n    function emergencyWithdraw(address recipient, uint256[] calldata data) external;\r\n\r\n    function initialize() external;\r\n\r\n    function disable() external;\r\n\r\n    /* ========== EVENTS ========== */\r\n\r\n    event Slippage(address strategy, IERC20 underlying, bool isDeposit, uint256 amountIn, uint256 amountOut);\r\n}\r\n\r\nstruct ProcessReallocationData {\r\n    uint128 sharesToWithdraw;\r\n    uint128 optimizedShares;\r\n    uint128 optimizedWithdrawnAmount;\r\n}\r\n"
    },
    "contracts/interfaces/IStrategyContractHelper.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n\r\npragma solidity 0.8.11;\r\n\r\ninterface IStrategyContractHelper {\r\n    function claimRewards(address[] memory, bool executeClaim) external returns(uint256[] memory, bool);\r\n\r\n    function deposit(uint256) external;\r\n\r\n    function withdraw(uint256) external;\r\n\r\n    function withdrawAll() external;\r\n}"
    },
    "contracts/interfaces/ISwapData.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n\r\npragma solidity 0.8.11;\r\n\r\n/**\r\n * @notice Strict holding information how to swap the asset\r\n * @member slippage minumum output amount\r\n * @member path swap path, first byte represents an action (e.g. Uniswap V2 custom swap), rest is swap specific path\r\n */\r\nstruct SwapData {\r\n    uint256 slippage; // min amount out\r\n    bytes path; // 1st byte is action, then path \r\n}"
    },
    "contracts/libraries/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.11;\r\n\r\nimport \"../external/@openzeppelin/utils/SafeCast.sol\";\r\n\r\n\r\n/**\r\n * @notice A collection of custom math ustils used throughout the system\r\n */\r\nlibrary Math {\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a > b ? b : a;\r\n    }\r\n\r\n    function getProportion128(uint256 mul1, uint256 mul2, uint256 div) internal pure returns (uint128) {\r\n        return SafeCast.toUint128(((mul1 * mul2) / div));\r\n    }\r\n\r\n    function getProportion128Unchecked(uint256 mul1, uint256 mul2, uint256 div) internal pure returns (uint128) {\r\n        unchecked {\r\n            return uint128((mul1 * mul2) / div);\r\n        }\r\n    }\r\n}\r\n\r\n"
    },
    "contracts/libraries/Max/128Bit.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.11;\r\n\r\n/** @notice Handle setting zero value in a storage word as uint128 max value.\r\n  *\r\n  *  @dev\r\n  *  The purpose of this is to avoid resetting a storage word to the zero value; \r\n  *  the gas cost of re-initializing the value is the same as setting the word originally.\r\n  *  so instead, if word is to be set to zero, we set it to uint128 max.\r\n  *\r\n  *   - anytime a word is loaded from storage: call \"get\"\r\n  *   - anytime a word is written to storage: call \"set\"\r\n  *   - common operations on uints are also bundled here.\r\n  *\r\n  * NOTE: This library should ONLY be used when reading or writing *directly* from storage.\r\n */\r\nlibrary Max128Bit {\r\n    uint128 internal constant ZERO = type(uint128).max;\r\n\r\n    function get(uint128 a) internal pure returns(uint128) {\r\n        return (a == ZERO) ? 0 : a;\r\n    }\r\n\r\n    function set(uint128 a) internal pure returns(uint128){\r\n        return (a == 0) ? ZERO : a;\r\n    }\r\n\r\n    function add(uint128 a, uint128 b) internal pure returns(uint128 c){\r\n        a = get(a);\r\n        c = set(a + b);\r\n    }\r\n}\r\n"
    },
    "contracts/shared/BaseStorage.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n\r\nimport \"../interfaces/ISwapData.sol\";\r\n\r\npragma solidity 0.8.11;\r\n\r\n/// @notice Strategy struct for all strategies\r\nstruct Strategy {\r\n    uint128 totalShares;\r\n\r\n    /// @notice Denotes strategy completed index\r\n    uint24 index;\r\n\r\n    /// @notice Denotes whether strategy is removed\r\n    /// @dev after removing this value can never change, hence strategy cannot be added back again\r\n    bool isRemoved;\r\n\r\n    /// @notice Pending geposit amount and pending shares withdrawn by all users for next index \r\n    Pending pendingUser;\r\n\r\n    /// @notice Used if strategies \"dohardwork\" hasn't been executed yet in the current index\r\n    Pending pendingUserNext;\r\n\r\n    /// @dev Usually a temp variable when compounding\r\n    mapping(address => uint256) pendingRewards;\r\n\r\n    /// @notice Amount of lp tokens the strategy holds, NOTE: not all strategies use it\r\n    uint256 lpTokens;\r\n\r\n    /// @dev Usually a temp variable when compounding\r\n    uint128 pendingDepositReward;\r\n\r\n    // ----- REALLOCATION VARIABLES -----\r\n\r\n    bool isInDepositPhase;\r\n\r\n    /// @notice Used to store amount of optimized shares, so they can be substracted at the end\r\n    /// @dev Only for temporary use, should be reset to 0 in same transaction\r\n    uint128 optimizedSharesWithdrawn;\r\n\r\n    /// @dev Underlying amount pending to be deposited from other strategies at reallocation \r\n    /// @dev Actual amount needed to be deposited and was withdrawn from others for reallocation\r\n    /// @dev resets after the strategy reallocation DHW is finished\r\n    uint128 pendingReallocateDeposit;\r\n\r\n    /// @notice Stores amount of optimized underlying amount when reallocating\r\n    /// @dev resets after the strategy reallocation DHW is finished\r\n    /// @dev This is \"virtual\" amount that was matched between this strategy and others when reallocating\r\n    uint128 pendingReallocateOptimizedDeposit;\r\n\r\n    /// @notice Average oprimized and non-optimized deposit\r\n    /// @dev Deposit from all strategies by taking the average of optimizedna dn non-optimized deposit\r\n    /// @dev Used as reallocation deposit recieved\r\n    uint128 pendingReallocateAverageDeposit;\r\n\r\n    // ------------------------------------\r\n\r\n    /// @notice Total underlying amoung at index\r\n    mapping(uint256 => TotalUnderlying) totalUnderlying;\r\n\r\n    /// @notice Batches stored after each DHW with index as a key\r\n    /// @dev Holds information for vauls to redeem newly gained shares and withdrawn amounts belonging to users\r\n    mapping(uint256 => Batch) batches;\r\n\r\n    /// @notice Batches stored after each DHW reallocating (if strategy was set to reallocate)\r\n    /// @dev Holds information for vauls to redeem newly gained shares and withdrawn shares to complete reallocation\r\n    mapping(uint256 => BatchReallocation) reallocationBatches;\r\n\r\n    /// @notice Vaults holding this strategy shares\r\n    mapping(address => Vault) vaults;\r\n\r\n    /// @notice Future proof storage\r\n    mapping(bytes32 => AdditionalStorage) additionalStorage;\r\n\r\n    /// @dev Make sure to reset it to 0 after emergency withdrawal\r\n    uint256 emergencyPending;\r\n}\r\n\r\n/// @notice Unprocessed deposit underlying amount and strategy share amount from users\r\nstruct Pending {\r\n    uint128 deposit;\r\n    uint128 sharesToWithdraw;\r\n}\r\n\r\n/// @notice Struct storing total underlying balance of a strategy for an index, along with total shares at same index\r\nstruct TotalUnderlying {\r\n    uint128 amount;\r\n    uint128 totalShares;\r\n}\r\n\r\n/// @notice Stored after executing DHW for each index.\r\n/// @dev This is used for vaults to redeem their deposit.\r\nstruct Batch {\r\n    /// @notice total underlying deposited in index\r\n    uint128 deposited;\r\n    uint128 depositedReceived;\r\n    uint128 depositedSharesReceived;\r\n    uint128 withdrawnShares;\r\n    uint128 withdrawnReceived;\r\n}\r\n\r\n/// @notice Stored after executing reallocation DHW each index.\r\nstruct BatchReallocation {\r\n    /// @notice Deposited amount received from reallocation\r\n    uint128 depositedReallocation;\r\n\r\n    /// @notice Received shares from reallocation\r\n    uint128 depositedReallocationSharesReceived;\r\n\r\n    /// @notice Used to know how much tokens was received for reallocating\r\n    uint128 withdrawnReallocationReceived;\r\n\r\n    /// @notice Amount of shares to withdraw for reallocation\r\n    uint128 withdrawnReallocationShares;\r\n}\r\n\r\n/// @notice VaultBatches could be refactored so we only have 2 structs current and next (see how Pending is working)\r\nstruct Vault {\r\n    uint128 shares;\r\n\r\n    /// @notice Withdrawn amount as part of the reallocation\r\n    uint128 withdrawnReallocationShares;\r\n\r\n    /// @notice Index to action\r\n    mapping(uint256 => VaultBatch) vaultBatches;\r\n}\r\n\r\n/// @notice Stores deposited and withdrawn shares by the vault\r\nstruct VaultBatch {\r\n    /// @notice Vault index to deposited amount mapping\r\n    uint128 deposited;\r\n\r\n    /// @notice Vault index to withdrawn user shares mapping\r\n    uint128 withdrawnShares;\r\n}\r\n\r\n/// @notice Used for reallocation calldata\r\nstruct VaultData {\r\n    address vault;\r\n    uint8 strategiesCount;\r\n    uint256 strategiesBitwise;\r\n    uint256 newProportions;\r\n}\r\n\r\n/// @notice Calldata when executing reallocatin DHW\r\n/// @notice Used in the withdraw part of the reallocation DHW\r\nstruct ReallocationWithdrawData {\r\n    uint256[][] reallocationTable;\r\n    StratUnderlyingSlippage[] priceSlippages;\r\n    RewardSlippages[] rewardSlippages;\r\n    uint256[] stratIndexes;\r\n    uint256[][] slippages;\r\n}\r\n\r\n/// @notice Calldata when executing reallocatin DHW\r\n/// @notice Used in the deposit part of the reallocation DHW\r\nstruct ReallocationData {\r\n    uint256[] stratIndexes;\r\n    uint256[][] slippages;\r\n}\r\n\r\n/// @notice In case some adapters need extra storage\r\nstruct AdditionalStorage {\r\n    uint256 value;\r\n    address addressValue;\r\n    uint96 value96;\r\n}\r\n\r\n/// @notice Strategy total underlying slippage, to verify validity of the strategy state\r\nstruct StratUnderlyingSlippage {\r\n    uint256 min;\r\n    uint256 max;\r\n}\r\n\r\n/// @notice Containig information if and how to swap strategy rewards at the DHW\r\n/// @dev Passed in by the do-hard-worker\r\nstruct RewardSlippages {\r\n    bool doClaim;\r\n    SwapData[] swapData;\r\n}\r\n\r\n/// @notice Helper struct to compare strategy share between eachother\r\n/// @dev Used for reallocation optimization of shares (strategy matching deposits and withdrawals between eachother when reallocating)\r\nstruct PriceData {\r\n    uint256 totalValue;\r\n    uint256 totalShares;\r\n}\r\n\r\n/// @notice Strategy reallocation values after reallocation optimization of shares was calculated \r\nstruct ReallocationShares {\r\n    uint128[] optimizedWithdraws;\r\n    uint128[] optimizedShares;\r\n    uint128[] totalSharesWithdrawn;\r\n    uint256[][] optimizedReallocationTable;\r\n}\r\n\r\n/// @notice Shared storage for multiple strategies\r\n/// @dev This is used when strategies are part of the same proticil (e.g. Curve 3pool)\r\nstruct StrategiesShared {\r\n    uint184 value;\r\n    uint32 lastClaimBlock;\r\n    uint32 lastUpdateBlock;\r\n    uint8 stratsCount;\r\n    mapping(uint256 => address) stratAddresses;\r\n    mapping(bytes32 => uint256) bytesValues;\r\n}\r\n\r\n/// @notice Base storage shared betweek Spool contract and Strategies\r\n/// @dev this way we can use same values when performing delegate call\r\n/// to strategy implementations from the Spool contract\r\nabstract contract BaseStorage {\r\n    // ----- DHW VARIABLES -----\r\n\r\n    /// @notice Force while DHW (all strategies) to be executed in only one transaction\r\n    /// @dev This is enforced to increase the gas efficiency of the system\r\n    /// Can be removed by the DAO if gas gost of the strategies goes over the block limit\r\n    bool internal forceOneTxDoHardWork;\r\n\r\n    /// @notice Global index of the system\r\n    /// @dev Insures the correct strategy DHW execution.\r\n    /// Every strategy in the system must be equal or one less than global index value\r\n    /// Global index increments by 1 on every do-hard-work\r\n    uint24 public globalIndex;\r\n\r\n    /// @notice number of strategies unprocessed (by the do-hard-work) in the current index to be completed\r\n    uint8 internal doHardWorksLeft;\r\n\r\n    // ----- REALLOCATION VARIABLES -----\r\n\r\n    /// @notice Used for offchain execution to get the new reallocation table.\r\n    bool internal logReallocationTable;\r\n\r\n    /// @notice number of withdrawal strategies unprocessed (by the do-hard-work) in the current index\r\n    /// @dev only used when reallocating\r\n    /// after it reaches 0, deposit phase of the reallocation can begin\r\n    uint8 public withdrawalDoHardWorksLeft;\r\n\r\n    /// @notice Index at which next reallocation is set\r\n    uint24 public reallocationIndex;\r\n\r\n    /// @notice 2D table hash containing information of how strategies should be reallocated between eachother\r\n    /// @dev Created when allocation provider sets reallocation for the vaults\r\n    /// This table is stored as a hash in the system and verified on reallocation DHW\r\n    /// Resets to 0 after reallocation DHW is completed\r\n    bytes32 internal reallocationTableHash;\r\n\r\n    /// @notice Hash of all the strategies array in the system at the time when reallocation was set for index\r\n    /// @dev this array is used for the whole reallocation period even if a strategy gets exploited when reallocating.\r\n    /// This way we can remove the strategy from the system and not breaking the flow of the reallocaton\r\n    /// Resets when DHW is completed\r\n    bytes32 internal reallocationStrategiesHash;\r\n\r\n    // -----------------------------------\r\n\r\n    /// @notice Denoting if an address is the do-hard-worker\r\n    mapping(address => bool) public isDoHardWorker;\r\n\r\n    /// @notice Denoting if an address is the allocation provider\r\n    mapping(address => bool) public isAllocationProvider;\r\n\r\n    /// @notice Strategies shared storage\r\n    /// @dev used as a helper storage to save common inoramation\r\n    mapping(bytes32 => StrategiesShared) internal strategiesShared;\r\n\r\n    /// @notice Mapping of strategy implementation address to strategy system values\r\n    mapping(address => Strategy) public strategies;\r\n\r\n    /// @notice Flag showing if disable was skipped when a strategy has been removed\r\n    /// @dev If true disable can still be run \r\n    mapping(address => bool) internal _skippedDisable;\r\n\r\n    /// @notice Flag showing if after removing a strategy emergency withdraw can still be executed\r\n    /// @dev If true emergency withdraw can still be executed\r\n    mapping(address => bool) internal _awaitingEmergencyWithdraw;\r\n}"
    },
    "contracts/shared/Constants.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n\r\npragma solidity 0.8.11;\r\n\r\nimport \"../external/@openzeppelin/token/ERC20/IERC20.sol\";\r\n\r\n/// @title Common Spool contracts constants\r\nabstract contract BaseConstants {\r\n    /// @dev 2 digits precision\r\n    uint256 internal constant FULL_PERCENT = 100_00;\r\n\r\n    /// @dev Accuracy when doing shares arithmetics\r\n    uint256 internal constant ACCURACY = 10**30;\r\n}\r\n\r\n/// @title Contains USDC token related values\r\nabstract contract USDC {\r\n    /// @notice USDC token contract address\r\n    IERC20 internal constant USDC_ADDRESS = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\r\n}"
    },
    "contracts/shared/SwapHelper.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n\r\npragma solidity 0.8.11;\r\n\r\nimport \"../external/GNSPS-solidity-bytes-utils/BytesLib.sol\";\r\nimport \"../external/@openzeppelin/token/ERC20/utils/SafeERC20.sol\";\r\n\r\nimport \"../external/uniswap/interfaces/ISwapRouter02.sol\";\r\nimport \"../interfaces/ISwapData.sol\";\r\n\r\n/// @notice Denotes swap action mode\r\nenum SwapAction {\r\n    NONE,\r\n    UNI_V2_DIRECT,\r\n    UNI_V2_WETH,\r\n    UNI_V2,\r\n    UNI_V3_DIRECT,\r\n    UNI_V3_WETH,\r\n    UNI_V3\r\n}\r\n\r\n/// @title Contains logic facilitating swapping using Uniswap\r\nabstract contract SwapHelper {\r\n    using BytesLib for bytes;\r\n    using SafeERC20 for IERC20;\r\n\r\n    /// @dev The length of the bytes encoded swap action\r\n    uint256 private constant ACTION_SIZE = 1;\r\n\r\n    /// @dev The length of the bytes encoded address\r\n    uint256 private constant ADDR_SIZE = 20;\r\n\r\n    /// @dev The length of the bytes encoded fee\r\n    uint256 private constant FEE_SIZE = 3;\r\n\r\n    /// @dev The offset of a single token address and pool fee\r\n    uint256 private constant NEXT_OFFSET = ADDR_SIZE + FEE_SIZE;\r\n\r\n    /// @dev Maximum V2 path length (4 swaps)\r\n    uint256 private constant MAX_V2_PATH = ADDR_SIZE * 3;\r\n\r\n    /// @dev V3 WETH path length\r\n    uint256 private constant WETH_V3_PATH_SIZE = FEE_SIZE + FEE_SIZE;\r\n\r\n    /// @dev Minimum V3 custom path length (2 swaps)\r\n    uint256 private constant MIN_V3_PATH = FEE_SIZE + NEXT_OFFSET;\r\n\r\n    /// @dev Maximum V3 path length (4 swaps)\r\n    uint256 private constant MAX_V3_PATH = FEE_SIZE + NEXT_OFFSET * 3;\r\n\r\n    /// @notice Uniswap router supporting Uniswap V2 and V3\r\n    ISwapRouter02 internal immutable uniswapRouter;\r\n\r\n    /// @notice Address of WETH token\r\n    address private immutable WETH;\r\n\r\n    /**\r\n     * @notice Sets initial values\r\n     * @param _uniswapRouter Uniswap router address\r\n     * @param _WETH WETH token address\r\n     */\r\n    constructor(ISwapRouter02 _uniswapRouter, address _WETH) {\r\n        uniswapRouter = _uniswapRouter;\r\n        WETH = _WETH;\r\n    }\r\n\r\n    /**\r\n     * @notice Approve reward token and swap the `amount` to a strategy underlying asset\r\n     * @param from Token to swap from\r\n     * @param to Token to swap to\r\n     * @param amount Amount of tokens to swap\r\n     * @param swapData Swap details showing the path of the swap\r\n     * @return result Amount of underlying (`to`) tokens recieved\r\n     */\r\n    function _approveAndSwap(\r\n        IERC20 from,\r\n        IERC20 to,\r\n        uint256 amount,\r\n        SwapData calldata swapData\r\n    ) internal virtual returns (uint256) {\r\n\r\n        // if there is nothing to swap, return\r\n        if(amount == 0)\r\n            return 0;\r\n\r\n        // if amount is not uint256 max approve unswap router to spend tokens\r\n        // otherwise rewards were already sent to the router\r\n        if(amount < type(uint256).max) {\r\n            from.safeApprove(address(uniswapRouter), amount);\r\n        } else {\r\n            amount = 0;\r\n        }\r\n\r\n        // get swap action from first byte\r\n        SwapAction action = SwapAction(swapData.path.toUint8(0));\r\n        uint256 result;\r\n\r\n        if (action == SwapAction.UNI_V2_DIRECT) { // V2 Direct\r\n            address[] memory path = new address[](2);\r\n            result = _swapV2(from, to, amount, swapData.slippage, path);\r\n        } else if (action == SwapAction.UNI_V2_WETH) { // V2 WETH\r\n            address[] memory path = new address[](3);\r\n            path[1] = WETH;\r\n            result = _swapV2(from, to, amount, swapData.slippage, path);\r\n        } else if (action == SwapAction.UNI_V2) { // V2 Custom\r\n            address[] memory path = _getV2Path(swapData.path);\r\n            result = _swapV2(from, to, amount, swapData.slippage, path);\r\n        } else if (action == SwapAction.UNI_V3_DIRECT) { // V3 Direct\r\n            result = _swapDirectV3(from, to, amount, swapData.slippage, swapData.path);\r\n        } else if (action == SwapAction.UNI_V3_WETH) { // V3 WETH\r\n            bytes memory wethPath = _getV3WethPath(swapData.path);\r\n            result = _swapV3(from, to, amount, swapData.slippage, wethPath);\r\n        } else if (action == SwapAction.UNI_V3) { // V3 Custom\r\n            require(swapData.path.length > MIN_V3_PATH, \"SwapHelper::_approveAndSwap: Path too short\");\r\n            uint256 actualpathSize = swapData.path.length - ACTION_SIZE;\r\n            require((actualpathSize - FEE_SIZE) % NEXT_OFFSET == 0 &&\r\n                actualpathSize <= MAX_V3_PATH,\r\n                \"SwapHelper::_approveAndSwap: Bad V3 path\");\r\n\r\n            result = _swapV3(from, to, amount, swapData.slippage, swapData.path[ACTION_SIZE:]);\r\n        } else {\r\n            revert(\"SwapHelper::_approveAndSwap: No action\");\r\n        }\r\n\r\n        if (from.allowance(address(this), address(uniswapRouter)) > 0) {\r\n            from.safeApprove(address(uniswapRouter), 0);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @notice Swaps tokens using Uniswap V2\r\n     * @param from Token to swap from\r\n     * @param to Token to swap to\r\n     * @param amount Amount of tokens to swap\r\n     * @param slippage Allowed slippage\r\n     * @param path Steps to complete the swap\r\n     * @return result Amount of underlying (`to`) tokens recieved\r\n     */\r\n    function _swapV2(\r\n        IERC20 from,\r\n        IERC20 to,\r\n        uint256 amount,\r\n        uint256 slippage,\r\n        address[] memory path\r\n    ) internal virtual returns (uint256) {\r\n        path[0] = address(from);\r\n        path[path.length - 1] = address(to);\r\n\r\n        return uniswapRouter.swapExactTokensForTokens(\r\n            amount,\r\n            slippage,\r\n            path,\r\n            address(this)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Swaps tokens using Uniswap V3\r\n     * @param from Token to swap from\r\n     * @param to Token to swap to\r\n     * @param amount Amount of tokens to swap\r\n     * @param slippage Allowed slippage\r\n     * @param path Steps to complete the swap\r\n     * @return result Amount of underlying (`to`) tokens recieved\r\n     */\r\n    function _swapV3(\r\n        IERC20 from,\r\n        IERC20 to,\r\n        uint256 amount,\r\n        uint256 slippage,\r\n        bytes memory path\r\n    ) internal virtual returns (uint256) {\r\n        IV3SwapRouter.ExactInputParams memory params =\r\n            IV3SwapRouter.ExactInputParams({\r\n                path: abi.encodePacked(address(from), path, address(to)),\r\n                recipient: address(this),\r\n                amountIn: amount,\r\n                amountOutMinimum: slippage\r\n            });\r\n\r\n        // Executes the swap.\r\n        uint received = uniswapRouter.exactInput(params);\r\n\r\n        return received;\r\n    }\r\n\r\n    /**\r\n     * @notice Does a direct swap from `from` address to the `to` address using Uniswap V3\r\n     * @param from Token to swap from\r\n     * @param to Token to swap to\r\n     * @param amount Amount of tokens to swap\r\n     * @param slippage Allowed slippage\r\n     * @param fee V3 direct fee configuration\r\n     * @return result Amount of underlying (`to`) tokens recieved\r\n     */\r\n    function _swapDirectV3(\r\n        IERC20 from,\r\n        IERC20 to,\r\n        uint256 amount,\r\n        uint256 slippage,\r\n        bytes memory fee\r\n    ) internal virtual returns (uint256) {\r\n        require(fee.length == FEE_SIZE + ACTION_SIZE, \"SwapHelper::_swapDirectV3: Bad V3 direct fee\");\r\n\r\n        IV3SwapRouter.ExactInputSingleParams memory params = IV3SwapRouter.ExactInputSingleParams(\r\n            address(from),\r\n            address(to),\r\n            // ignore first byte\r\n            fee.toUint24(ACTION_SIZE),\r\n            address(this),\r\n            amount,\r\n            slippage,\r\n            0\r\n        );\r\n\r\n        return uniswapRouter.exactInputSingle(params);\r\n    }\r\n\r\n    /**\r\n     * @notice Converts passed bytes to V2 path\r\n     * @param pathBytes Swap path in bytes, converted to addresses\r\n     * @return path list of addresses in the swap path (skipping first and last element)\r\n     */\r\n    function _getV2Path(bytes calldata pathBytes) internal pure returns(address[] memory) {\r\n        require(pathBytes.length > ACTION_SIZE, \"SwapHelper::_getV2Path: No path provided\");\r\n        uint256 actualpathSize = pathBytes.length - ACTION_SIZE;\r\n        require(actualpathSize % ADDR_SIZE == 0 && actualpathSize <= MAX_V2_PATH, \"SwapHelper::_getV2Path: Bad V2 path\");\r\n\r\n        uint256 pathLength = actualpathSize / ADDR_SIZE;\r\n        address[] memory path = new address[](pathLength + 2);\r\n\r\n        // ignore first byte\r\n        path[1] = pathBytes.toAddress(ACTION_SIZE);\r\n        for (uint256 i = 1; i < pathLength; i++) {\r\n            path[i + 1] = pathBytes.toAddress(i * ADDR_SIZE + ACTION_SIZE);\r\n        }\r\n\r\n        return path;\r\n    }\r\n\r\n    /**\r\n     * @notice Get Unswap V3 path to swap tokens via WETH LP pool\r\n     * @param pathBytes Swap path in bytes\r\n     * @return wethPath Unswap V3 path routing via WETH pool\r\n     */\r\n    function _getV3WethPath(bytes calldata pathBytes) internal view returns(bytes memory) {\r\n        require(pathBytes.length == WETH_V3_PATH_SIZE + ACTION_SIZE, \"SwapHelper::_getV3WethPath: Bad V3 WETH path\");\r\n        // ignore first byte as it's used for swap action\r\n        return abi.encodePacked(pathBytes[ACTION_SIZE:4], WETH, pathBytes[4:]);\r\n    }\r\n}\r\n"
    },
    "contracts/shared/SwapHelperMainnet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n\r\npragma solidity 0.8.11;\r\n\r\nimport \"./SwapHelper.sol\";\r\n\r\n/// @title Swap helper implementation with SwapRouter02 on Mainnet\r\ncontract SwapHelperMainnet is SwapHelper {\r\n    constructor()\r\n        SwapHelper(ISwapRouter02(0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45), 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2)\r\n    {}\r\n}\r\n"
    },
    "contracts/strategies/BaseStrategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n\r\npragma solidity 0.8.11;\r\n\r\nimport \"../interfaces/IBaseStrategy.sol\";\r\nimport \"../shared/BaseStorage.sol\";\r\nimport \"../shared/Constants.sol\";\r\n\r\nimport \"../external/@openzeppelin/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"../libraries/Math.sol\";\r\nimport \"../libraries/Max/128Bit.sol\";\r\n\r\n/**\r\n * @notice Implementation of the {IBaseStrategy} interface.\r\n *\r\n * @dev\r\n * This implementation of the {IBaseStrategy} is meant to operate\r\n * on single-collateral strategies and uses a delta system to calculate\r\n * whether a withdrawal or deposit needs to be performed for a particular\r\n * strategy.\r\n */\r\nabstract contract BaseStrategy is IBaseStrategy, BaseStorage, BaseConstants {\r\n    using SafeERC20 for IERC20;\r\n    using Max128Bit for uint128;\r\n\r\n    /* ========== CONSTANTS ========== */\r\n\r\n    /// @notice Value to multiply new deposit recieved to get the share amount\r\n    uint128 private constant SHARES_MULTIPLIER = 10**6;\r\n    \r\n    /// @notice number of locked shares when initial shares are added\r\n    /// @dev This is done to prevent rounding errors and share manipulation\r\n    uint128 private constant INITIAL_SHARES_LOCKED = 10**11;\r\n\r\n    /// @notice minimum shares size to avoid loss of share due to computation precision\r\n    /// @dev If total shares go unders this value, new deposit is multiplied by the `SHARES_MULTIPLIER` again\r\n    uint256 private constant MIN_SHARES_FOR_ACCURACY = INITIAL_SHARES_LOCKED * 10;\r\n\r\n    /* ========== STATE VARIABLES ========== */\r\n\r\n    /// @notice The total slippage slots the strategy supports, used for validation of provided slippage\r\n    uint256 internal immutable rewardSlippageSlots;\r\n\r\n    /// @notice Slots for processing\r\n    uint256 internal immutable processSlippageSlots;\r\n\r\n    /// @notice Slots for reallocation\r\n    uint256 internal immutable reallocationSlippageSlots;\r\n\r\n    /// @notice Slots for deposit\r\n    uint256 internal immutable depositSlippageSlots;\r\n\r\n    /** \r\n     * @notice do force claim of rewards.\r\n     *\r\n     * @dev\r\n     * Some strategies auto claim on deposit/withdraw,\r\n     * so execute the claim actions to store the reward amounts.\r\n     */\r\n    bool internal immutable forceClaim;\r\n\r\n    /// @notice flag to force balance validation before running process strategy\r\n    /// @dev this is done so noone can manipulate the strategies before we interact with them and cause harm to the system\r\n    bool internal immutable doValidateBalance;\r\n\r\n    /// @notice The self address, set at initialization to allow proper share accounting\r\n    address internal immutable self;\r\n\r\n    /// @notice The underlying asset of the strategy\r\n    IERC20 public immutable override underlying;\r\n\r\n    /* ========== CONSTRUCTOR ========== */\r\n\r\n    /**\r\n     * @notice Initializes the base strategy values.\r\n     *\r\n     * @dev\r\n     * It performs certain pre-conditional validations to ensure the contract\r\n     * has been initialized properly, such as that the address argument of the\r\n     * underlying asset is valid.\r\n     *\r\n     * Slippage slots for certain strategies may be zero if there is no compounding\r\n     * work to be done.\r\n     * \r\n     * @param _underlying token used for deposits\r\n     * @param _rewardSlippageSlots slots for rewards\r\n     * @param _processSlippageSlots slots for processing\r\n     * @param _reallocationSlippageSlots slots for reallocation\r\n     * @param _depositSlippageSlots slots for deposits\r\n     * @param _forceClaim force claim of rewards\r\n     * @param _doValidateBalance force balance validation\r\n     */\r\n    constructor(\r\n        IERC20  _underlying,\r\n        uint256 _rewardSlippageSlots,\r\n        uint256 _processSlippageSlots,\r\n        uint256 _reallocationSlippageSlots,\r\n        uint256 _depositSlippageSlots,\r\n        bool _forceClaim,\r\n        bool _doValidateBalance,\r\n        address _self\r\n    ) {\r\n        require(\r\n            _underlying != IERC20(address(0)),\r\n            \"BaseStrategy::constructor: Underlying address cannot be 0\"\r\n        );\r\n\r\n        self = _self == address(0) ? address(this) : _self;\r\n\r\n        underlying = _underlying;\r\n        rewardSlippageSlots = _rewardSlippageSlots;\r\n        processSlippageSlots = _processSlippageSlots;\r\n        reallocationSlippageSlots = _reallocationSlippageSlots;\r\n        depositSlippageSlots = _depositSlippageSlots;\r\n        forceClaim = _forceClaim;\r\n        doValidateBalance = _doValidateBalance;\r\n    }\r\n\r\n    /* ========== MUTATIVE FUNCTIONS ========== */\r\n\r\n    /**\r\n     * @notice Process the latest pending action of the strategy\r\n     *\r\n     * @dev\r\n     * it yields amount of funds processed as well as the reward buffer of the strategy.\r\n     * The function will auto-compound rewards if requested and supported.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the slippages provided must be valid in length\r\n     * - if the redeposit flag is set to true, the strategy must support\r\n     *   compounding of rewards\r\n     *\r\n     * @param slippages slippages to process\r\n     * @param redeposit if redepositing is to occur\r\n     * @param swapData swap data for processing\r\n     */\r\n    function process(uint256[] calldata slippages, bool redeposit, SwapData[] calldata swapData) external override\r\n    {\r\n        slippages = _validateStrategyBalance(slippages);\r\n\r\n        if (forceClaim || redeposit) {\r\n            _validateRewardsSlippage(swapData);\r\n            _processRewards(swapData);\r\n        }\r\n\r\n        if (processSlippageSlots != 0)\r\n            _validateProcessSlippage(slippages);\r\n        \r\n        _process(slippages, 0);\r\n    }\r\n\r\n    /**\r\n     * @notice Process first part of the reallocation DHW\r\n     * @dev Withdraws for reallocation, depositn and withdraww for a user\r\n     *\r\n     * @param slippages Parameters to apply when performing a deposit or a withdraw\r\n     * @param processReallocationData Data containing amuont of optimized and not optimized shares to withdraw\r\n     * @return withdrawnReallocationReceived actual amount recieveed from peforming withdraw\r\n     */\r\n    function processReallocation(uint256[] calldata slippages, ProcessReallocationData calldata processReallocationData) external override returns(uint128) {\r\n        slippages = _validateStrategyBalance(slippages);\r\n\r\n        if (reallocationSlippageSlots != 0)\r\n            _validateReallocationSlippage(slippages);\r\n\r\n        _process(slippages, processReallocationData.sharesToWithdraw);\r\n\r\n        uint128 withdrawnReallocationReceived = _updateReallocationWithdraw(processReallocationData);\r\n\r\n        return withdrawnReallocationReceived;\r\n    }\r\n\r\n    /**\r\n     * @dev Update reallocation batch storage for index after withdrawing reallocated shares\r\n     * @param processReallocationData Data containing amount of optimized and not optimized shares to withdraw\r\n     * @return Withdrawn reallocation received\r\n     */\r\n    function _updateReallocationWithdraw(ProcessReallocationData calldata processReallocationData) internal virtual returns(uint128) {\r\n        Strategy storage strategy = strategies[self];\r\n        uint24 stratIndex = _getProcessingIndex();\r\n        BatchReallocation storage batch = strategy.reallocationBatches[stratIndex];\r\n\r\n        // save actual withdrawn amount, without optimized one \r\n        uint128 withdrawnReallocationReceived = batch.withdrawnReallocationReceived;\r\n\r\n        strategy.optimizedSharesWithdrawn += processReallocationData.optimizedShares;\r\n        batch.withdrawnReallocationReceived += processReallocationData.optimizedWithdrawnAmount;\r\n        batch.withdrawnReallocationShares = processReallocationData.optimizedShares + processReallocationData.sharesToWithdraw;\r\n\r\n        return withdrawnReallocationReceived;\r\n    }\r\n\r\n    /**\r\n     * @notice Process deposit\r\n     * @param slippages Array of slippage parameters to apply when depositing\r\n     */\r\n    function processDeposit(uint256[] calldata slippages)\r\n        external\r\n        override\r\n    {\r\n        slippages = _validateStrategyBalance(slippages);\r\n\r\n        if (depositSlippageSlots != 0)\r\n            _validateDepositSlippage(slippages);\r\n        _processDeposit(slippages);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns total starategy balance includign pending rewards\r\n     * @return strategyBalance total starategy balance includign pending rewards\r\n     */\r\n    function getStrategyUnderlyingWithRewards() public view override returns(uint128)\r\n    {\r\n        return _getStrategyUnderlyingWithRewards();\r\n    }\r\n\r\n    /**\r\n     * @notice Fast withdraw\r\n     * @param shares Shares to fast withdraw\r\n     * @param slippages Array of slippage parameters to apply when withdrawing\r\n     * @param swapData Swap slippage and path array\r\n     * @return Withdrawn amount withdawn\r\n     */\r\n    function fastWithdraw(uint128 shares, uint256[] calldata slippages, SwapData[] calldata swapData) external override returns(uint128)\r\n    {\r\n        slippages = _validateStrategyBalance(slippages);\r\n\r\n        _validateRewardsSlippage(swapData);\r\n\r\n        if (processSlippageSlots != 0)\r\n            _validateProcessSlippage(slippages);\r\n\r\n        uint128 withdrawnAmount = _processFastWithdraw(shares, slippages, swapData);\r\n        strategies[self].totalShares -= shares;\r\n        return withdrawnAmount;\r\n    }\r\n\r\n    /**\r\n     * @notice Claims and possibly compounds strategy rewards.\r\n     *\r\n     * @param swapData swap data for processing\r\n     */\r\n    function claimRewards(SwapData[] calldata swapData) external override\r\n    {\r\n        _validateRewardsSlippage(swapData);\r\n        _processRewards(swapData);\r\n    }\r\n\r\n    /**\r\n     * @notice Withdraws all actively deployed funds in the strategy, liquifying them in the process.\r\n     *\r\n     * @param recipient recipient of the withdrawn funds\r\n     * @param data data necessary execute the emergency withdraw\r\n     */\r\n    function emergencyWithdraw(address recipient, uint256[] calldata data) external virtual override {\r\n        uint256 balanceBefore = underlying.balanceOf(address(this));\r\n        _emergencyWithdraw(recipient, data);\r\n        uint256 balanceAfter = underlying.balanceOf(address(this));\r\n\r\n        uint256 withdrawnAmount = 0;\r\n        if (balanceAfter > balanceBefore) {\r\n            withdrawnAmount = balanceAfter - balanceBefore;\r\n        }\r\n        \r\n        Strategy storage strategy = strategies[self];\r\n        if (strategy.emergencyPending > 0) {\r\n            withdrawnAmount += strategy.emergencyPending;\r\n            strategy.emergencyPending = 0;\r\n        }\r\n\r\n        // also withdraw all unprocessed deposit for a strategy\r\n        if (strategy.pendingUser.deposit.get() > 0) {\r\n            withdrawnAmount += strategy.pendingUser.deposit.get();\r\n            strategy.pendingUser.deposit = 0;\r\n        }\r\n\r\n        if (strategy.pendingUserNext.deposit.get() > 0) {\r\n            withdrawnAmount += strategy.pendingUserNext.deposit.get();\r\n            strategy.pendingUserNext.deposit = 0;\r\n        }\r\n\r\n        // if strategy was already processed in the current index that hasn't finished yet,\r\n        // transfer the withdrawn amount\r\n        // reset total underlying to 0\r\n        if (strategy.index == globalIndex && doHardWorksLeft > 0) {\r\n            uint256 withdrawnReceived = strategy.batches[strategy.index].withdrawnReceived;\r\n            withdrawnAmount += withdrawnReceived;\r\n            strategy.batches[strategy.index].withdrawnReceived = 0;\r\n\r\n            strategy.totalUnderlying[strategy.index].amount = 0;\r\n        }\r\n\r\n        if (withdrawnAmount > 0) {\r\n            // check if the balance is high enough to withdraw the total withdrawnAmount\r\n            if (balanceAfter < withdrawnAmount) {\r\n                // if not withdraw the current balance\r\n                withdrawnAmount = balanceAfter;\r\n            }\r\n\r\n            underlying.safeTransfer(recipient, withdrawnAmount);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Initialize a strategy.\r\n     * @dev Execute strategy specific one-time actions if needed.\r\n     */\r\n    function initialize() external virtual override {}\r\n\r\n    /**\r\n     * @notice Disables a strategy.\r\n     * @dev Cleans strategy specific values if needed.\r\n     */\r\n    function disable() external virtual override {}\r\n\r\n    /* ========== INTERNAL FUNCTIONS ========== */\r\n\r\n    /**\r\n     * @dev Validate strategy balance\r\n     * @param slippages Check if the strategy balance is within defined min and max values\r\n     * @return slippages Same array without first 2 slippages\r\n     */\r\n    function _validateStrategyBalance(uint256[] calldata slippages) internal virtual returns(uint256[] calldata) {\r\n        if (doValidateBalance) {\r\n            require(slippages.length >= 2, \"BaseStrategy:: _validateStrategyBalance: Invalid number of slippages\");\r\n            uint128 strategyBalance =  getStrategyBalance();\r\n\r\n            require(\r\n                slippages[0] <= strategyBalance &&\r\n                slippages[1] >= strategyBalance,\r\n                \"BaseStrategy::_validateStrategyBalance: Bad strategy balance\"\r\n            );\r\n\r\n            return slippages[2:];\r\n        }\r\n\r\n        return slippages;\r\n    }\r\n\r\n    /**\r\n     * @dev Validate reards slippage\r\n     * @param swapData Swap slippage and path array\r\n     */\r\n    function _validateRewardsSlippage(SwapData[] calldata swapData) internal view virtual {\r\n        if (swapData.length > 0) {\r\n            require(\r\n                swapData.length == _getRewardSlippageSlots(),\r\n                \"BaseStrategy::_validateSlippage: Invalid Number of reward slippages Defined\"\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Retrieve reward slippage slots\r\n     * @return Reward slippage slots\r\n     */\r\n    function _getRewardSlippageSlots() internal view virtual returns(uint256) {\r\n        return rewardSlippageSlots;\r\n    }\r\n\r\n    /**\r\n     * @dev Validate process slippage\r\n     * @param slippages parameters to verify validity of the strategy state\r\n     */\r\n    function _validateProcessSlippage(uint256[] calldata slippages) internal view virtual {\r\n        _validateSlippage(slippages.length, processSlippageSlots);\r\n    }\r\n\r\n    /**\r\n     * @dev Validate reallocation slippage\r\n     * @param slippages parameters to verify validity of the strategy state\r\n     */\r\n    function _validateReallocationSlippage(uint256[] calldata slippages) internal view virtual {\r\n        _validateSlippage(slippages.length, reallocationSlippageSlots);\r\n    }\r\n\r\n    /**\r\n     * @dev Validate deposit slippage\r\n     * @param slippages parameters to verify validity of the strategy state\r\n     */\r\n    function _validateDepositSlippage(uint256[] calldata slippages) internal view virtual {\r\n        _validateSlippage(slippages.length, depositSlippageSlots);\r\n    }\r\n\r\n    /**\r\n     * @dev Validates the provided slippage in length.\r\n     * @param currentLength actual slippage array length\r\n     * @param shouldBeLength expected slippages array length\r\n     */\r\n    function _validateSlippage(uint256 currentLength, uint256 shouldBeLength)\r\n        internal\r\n        view\r\n        virtual\r\n    {\r\n        require(\r\n            currentLength == shouldBeLength,\r\n            \"BaseStrategy::_validateSlippage: Invalid Number of Slippages Defined\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Retrieve processing index\r\n     * @return Processing index\r\n     */\r\n    function _getProcessingIndex() internal view returns(uint24) {\r\n        return strategies[self].index + 1;\r\n    }\r\n\r\n    /**\r\n     * @dev Calculates shares before they are added to the total shares\r\n     * @param strategyTotalShares Total shares for strategy\r\n     * @param stratTotalUnderlying Total underlying for strategy\r\n     * @param depositAmount Deposit amount recieved\r\n     * @return newShares New shares calculated\r\n     */\r\n    function _getNewSharesAfterWithdraw(uint128 strategyTotalShares, uint128 stratTotalUnderlying, uint128 depositAmount) internal pure returns(uint128, uint128){\r\n        uint128 oldUnderlying;\r\n        if (stratTotalUnderlying > depositAmount) {\r\n            unchecked {\r\n                oldUnderlying = stratTotalUnderlying - depositAmount;\r\n            }\r\n        }\r\n\r\n        return _getNewShares(strategyTotalShares, oldUnderlying, depositAmount);\r\n    }\r\n\r\n    /**\r\n     * @dev Calculates shares when they are already part of the total shares\r\n     *\r\n     * @param strategyTotalShares Total shares\r\n     * @param stratTotalUnderlying Total underlying\r\n     * @param depositAmount Deposit amount recieved\r\n     * @return newShares New shares calculated\r\n     */\r\n    function _getNewShares(uint128 strategyTotalShares, uint128 stratTotalUnderlying, uint128 depositAmount) internal pure returns(uint128 newShares, uint128){\r\n        if (strategyTotalShares <= MIN_SHARES_FOR_ACCURACY || stratTotalUnderlying == 0) {\r\n            (newShares, strategyTotalShares) = _setNewShares(strategyTotalShares, depositAmount);\r\n        } else {\r\n            newShares = Math.getProportion128(depositAmount, strategyTotalShares, stratTotalUnderlying);\r\n        }\r\n\r\n        strategyTotalShares += newShares;\r\n\r\n        return (newShares, strategyTotalShares);\r\n    }\r\n\r\n    /**\r\n     * @notice Sets new shares if strategy does not have enough locked shares and calculated new shares based on deposit recieved\r\n     * @dev\r\n     * This is used when a strategy is new and does not have enough shares locked.\r\n     * Shares are locked to prevent rounding errors and to keep share to underlying amount\r\n     * ratio correct, to ensure the normal working of the share system._awaitingEmergencyWithdraw\r\n     * We always want to have more shares than the underlying value of the strategy.\r\n     *\r\n     * @param strategyTotalShares Total shares\r\n     * @param depositAmount Deposit amount recieved\r\n     * @return newShares New shares calculated\r\n     */\r\n    function _setNewShares(uint128 strategyTotalShares, uint128 depositAmount) private pure returns(uint128, uint128) {\r\n        // Enforce minimum shares size to avoid loss of share due to computation precision\r\n        uint128 newShares = depositAmount * SHARES_MULTIPLIER;\r\n\r\n        if (strategyTotalShares < INITIAL_SHARES_LOCKED) {\r\n            if (newShares + strategyTotalShares >= INITIAL_SHARES_LOCKED) {\r\n                unchecked {\r\n                    uint128 newLockedShares = INITIAL_SHARES_LOCKED - strategyTotalShares;\r\n                    strategyTotalShares += newLockedShares;\r\n                    newShares -= newLockedShares;\r\n                }\r\n            } else {\r\n                newShares = 0;\r\n            }\r\n        }\r\n\r\n        return (newShares, strategyTotalShares);\r\n    }\r\n\r\n    /**\r\n     * @dev Reset allowance to zero if previously set to a higher value.\r\n     * @param token Asset\r\n     * @param spender Spender address\r\n     */\r\n    function _resetAllowance(IERC20 token, address spender) internal {\r\n        if (token.allowance(address(this), spender) > 0) {\r\n            token.safeApprove(spender, 0);\r\n        }\r\n    }\r\n\r\n    /* ========== VIRTUAL FUNCTIONS ========== */\r\n\r\n    function getStrategyBalance()\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint128);\r\n\r\n    function _processRewards(SwapData[] calldata) internal virtual;\r\n    function _emergencyWithdraw(address recipient, uint256[] calldata data) internal virtual;\r\n    function _process(uint256[] memory, uint128 reallocateSharesToWithdraw) internal virtual;\r\n    function _processDeposit(uint256[] memory) internal virtual;\r\n    function _getStrategyUnderlyingWithRewards() internal view virtual returns(uint128);\r\n    function _processFastWithdraw(uint128, uint256[] memory, SwapData[] calldata) internal virtual returns(uint128);\r\n}\r\n"
    },
    "contracts/strategies/MultipleRewardStrategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n\r\npragma solidity 0.8.11;\r\n\r\nimport \"./RewardStrategy.sol\";\r\nimport \"../shared/SwapHelperMainnet.sol\";\r\n\r\n/**\r\n * @notice Multiple reward strategy logic\r\n */\r\nabstract contract MultipleRewardStrategy is RewardStrategy, SwapHelperMainnet {\r\n    /* ========== OVERRIDDEN FUNCTIONS ========== */\r\n\r\n    /**\r\n     * @notice Claim rewards\r\n     * @param swapData Slippage and path array\r\n     * @return Rewards\r\n     */\r\n    function _claimRewards(SwapData[] calldata swapData) internal virtual override returns(Reward[] memory) {\r\n        return _claimMultipleRewards(type(uint128).max, swapData);\r\n    }\r\n\r\n    /**\r\n     * @dev Claim fast withdraw rewards\r\n     * @param shares Amount of shares\r\n     * @param swapData Swap slippage and path\r\n     * @return Rewards\r\n     */\r\n    function _claimFastWithdrawRewards(uint128 shares, SwapData[] calldata swapData) internal virtual override returns(Reward[] memory) {\r\n        return _claimMultipleRewards(shares, swapData);\r\n    }\r\n\r\n    /* ========== VIRTUAL FUNCTIONS ========== */\r\n\r\n    function _claimMultipleRewards(uint128 shares, SwapData[] calldata swapData) internal virtual returns(Reward[] memory rewards);\r\n}\r\n"
    },
    "contracts/strategies/ProcessStrategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n\r\npragma solidity 0.8.11;\r\n\r\nimport \"./BaseStrategy.sol\";\r\n\r\nimport \"../libraries/Max/128Bit.sol\";\r\nimport \"../libraries/Math.sol\";\r\n\r\nstruct ProcessInfo {\r\n    uint128 totalWithdrawReceived;\r\n    uint128 userDepositReceived;\r\n}\r\n\r\n/**\r\n * @notice Process strategy logic\r\n */\r\nabstract contract ProcessStrategy is BaseStrategy {\r\n    using Max128Bit for uint128;\r\n\r\n    /* ========== OVERRIDDEN FUNCTIONS ========== */\r\n\r\n    /**\r\n     * @notice Process the strategy pending deposits, withdrawals, and collected strategy rewards\r\n     * @dev\r\n     * Deposit amount amd withdrawal shares are matched between eachother, effecively only one of\r\n     * those 2 is called. Shares are converted to the dollar value, based on the current strategy\r\n     * total balance. This ensures the minimum amount of assets are moved around to lower the price\r\n     * drift and total fees paid to the protocols the strategy is interacting with (if there are any)\r\n     *\r\n     * @param slippages Strategy slippage values verifying the validity of the strategy state\r\n     * @param reallocateSharesToWithdraw Reallocation shares to withdraw (non-zero only if reallocation DHW is in progress, otherwise 0)\r\n     */\r\n    function _process(uint256[] memory slippages, uint128 reallocateSharesToWithdraw) internal override virtual {\r\n        // PREPARE\r\n        Strategy storage strategy = strategies[self];\r\n        uint24 processingIndex = _getProcessingIndex();\r\n        Batch storage batch = strategy.batches[processingIndex];\r\n        uint128 strategyTotalShares = strategy.totalShares;\r\n        uint128 pendingSharesToWithdraw = strategy.pendingUser.sharesToWithdraw.get();\r\n        uint128 userDeposit = strategy.pendingUser.deposit.get();\r\n\r\n        // CALCULATE THE ACTION\r\n\r\n        // if withdrawing for reallocating, add shares to total withdraw shares\r\n        if (reallocateSharesToWithdraw > 0) {\r\n            pendingSharesToWithdraw += reallocateSharesToWithdraw;\r\n        }\r\n\r\n        // total deposit received from users + compound reward (if there are any)\r\n        uint128 totalPendingDeposit = userDeposit;\r\n        \r\n        // add compound reward (pendingDepositReward) to deposit\r\n        uint128 withdrawalReward = 0;\r\n        if (strategy.pendingDepositReward > 0) {\r\n            uint128 pendingDepositReward = strategy.pendingDepositReward;\r\n\r\n            totalPendingDeposit += pendingDepositReward;\r\n\r\n            // calculate compound reward (withdrawalReward) for users withdrawing in this batch\r\n            if (pendingSharesToWithdraw > 0 && strategyTotalShares > 0) {\r\n                withdrawalReward = Math.getProportion128(pendingSharesToWithdraw, pendingDepositReward, strategyTotalShares);\r\n\r\n                // substract withdrawal reward from total deposit\r\n                totalPendingDeposit -= withdrawalReward;\r\n            }\r\n\r\n            // Reset pendingDepositReward\r\n            strategy.pendingDepositReward = 0;\r\n        }\r\n\r\n        // if there is no pending deposit or withdrawals, return\r\n        if (totalPendingDeposit == 0 && pendingSharesToWithdraw == 0) {\r\n            return;\r\n        }\r\n\r\n        uint128 pendingWithdrawalAmount = 0;\r\n        if (pendingSharesToWithdraw > 0) {\r\n            pendingWithdrawalAmount = \r\n                Math.getProportion128(getStrategyBalance(), pendingSharesToWithdraw, strategyTotalShares);\r\n        }\r\n\r\n        // ACTION: DEPOSIT OR WITHDRAW\r\n        ProcessInfo memory processInfo;\r\n        if (totalPendingDeposit > pendingWithdrawalAmount) { // DEPOSIT\r\n            // uint128 amount = totalPendingDeposit - pendingWithdrawalAmount;\r\n            uint128 depositReceived = _deposit(totalPendingDeposit - pendingWithdrawalAmount, slippages);\r\n\r\n            processInfo.totalWithdrawReceived = pendingWithdrawalAmount + withdrawalReward;\r\n\r\n            // pendingWithdrawalAmount is optimized deposit: totalPendingDeposit - amount;\r\n            uint128 totalDepositReceived = depositReceived + pendingWithdrawalAmount;\r\n            \r\n            // calculate user deposit received, excluding compound rewards\r\n            processInfo.userDepositReceived =  Math.getProportion128(totalDepositReceived, userDeposit, totalPendingDeposit);\r\n        } else if (totalPendingDeposit < pendingWithdrawalAmount) { // WITHDRAW\r\n            // uint128 amount = pendingWithdrawalAmount - totalPendingDeposit;\r\n\r\n            uint128 withdrawReceived = _withdraw(\r\n                // calculate back the shares from actual withdraw amount\r\n                // NOTE: we can do unchecked calculation and casting as\r\n                //       the multiplier is always smaller than the divisor\r\n                Math.getProportion128Unchecked(\r\n                    (pendingWithdrawalAmount - totalPendingDeposit),\r\n                    pendingSharesToWithdraw,\r\n                    pendingWithdrawalAmount\r\n                ),\r\n                slippages\r\n            );\r\n\r\n            // optimized withdraw is total pending deposit: pendingWithdrawalAmount - amount = totalPendingDeposit;\r\n            processInfo.totalWithdrawReceived = withdrawReceived + totalPendingDeposit + withdrawalReward;\r\n            processInfo.userDepositReceived = userDeposit;\r\n        } else {\r\n            processInfo.totalWithdrawReceived = pendingWithdrawalAmount + withdrawalReward;\r\n            processInfo.userDepositReceived = userDeposit;\r\n        }\r\n        \r\n        // UPDATE STORAGE AFTER\r\n        {\r\n            uint128 stratTotalUnderlying = getStrategyBalance();\r\n\r\n            // Update withdraw batch\r\n            if (pendingSharesToWithdraw > 0) {\r\n                batch.withdrawnReceived = processInfo.totalWithdrawReceived;\r\n                batch.withdrawnShares = pendingSharesToWithdraw;\r\n                \r\n                strategyTotalShares -= pendingSharesToWithdraw;\r\n\r\n                // update reallocation batch\r\n                if (reallocateSharesToWithdraw > 0) {\r\n                    BatchReallocation storage reallocationBatch = strategy.reallocationBatches[processingIndex];\r\n\r\n                    uint128 withdrawnReallocationReceived =\r\n                        Math.getProportion128(processInfo.totalWithdrawReceived, reallocateSharesToWithdraw, pendingSharesToWithdraw);\r\n                    reallocationBatch.withdrawnReallocationReceived = withdrawnReallocationReceived;\r\n\r\n                    // substract reallocation values from user values\r\n                    batch.withdrawnReceived -= withdrawnReallocationReceived;\r\n                    batch.withdrawnShares -= reallocateSharesToWithdraw;\r\n                }\r\n            }\r\n\r\n            // Update deposit batch\r\n            if (userDeposit > 0) {\r\n                uint128 newShares;\r\n                (newShares, strategyTotalShares) = _getNewSharesAfterWithdraw(strategyTotalShares, stratTotalUnderlying, processInfo.userDepositReceived);\r\n\r\n                batch.deposited = userDeposit;\r\n                batch.depositedReceived = processInfo.userDepositReceived;\r\n                batch.depositedSharesReceived = newShares;\r\n            }\r\n\r\n            // Update shares\r\n            if (strategyTotalShares != strategy.totalShares) {\r\n                strategy.totalShares = strategyTotalShares;\r\n            }\r\n\r\n            // Set underlying at index\r\n            strategy.totalUnderlying[processingIndex].amount = stratTotalUnderlying;\r\n            strategy.totalUnderlying[processingIndex].totalShares = strategyTotalShares;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Process deposit\r\n     * @param slippages Slippages array\r\n     */\r\n    function _processDeposit(uint256[] memory slippages) internal override virtual {\r\n        Strategy storage strategy = strategies[self];\r\n        \r\n        uint128 depositOptimizedAmount = strategy.pendingReallocateOptimizedDeposit;\r\n        uint128 depositAverageAmount = strategy.pendingReallocateAverageDeposit;\r\n        uint128 optimizedSharesWithdrawn = strategy.optimizedSharesWithdrawn;\r\n        uint128 depositAmount = strategy.pendingReallocateDeposit;\r\n\r\n        // if a strategy is not part of reallocation return\r\n        if (\r\n            depositOptimizedAmount == 0 &&\r\n            optimizedSharesWithdrawn == 0 &&\r\n            depositAverageAmount == 0 &&\r\n            depositAmount == 0\r\n        ) {\r\n            return;\r\n        }\r\n\r\n        uint24 processingIndex = _getProcessingIndex();\r\n        BatchReallocation storage reallocationBatch = strategy.reallocationBatches[processingIndex];\r\n        \r\n        uint128 strategyTotalShares = strategy.totalShares;\r\n        \r\n        // add shares from optimized deposit\r\n        if (depositOptimizedAmount > 0) {\r\n            uint128 stratTotalUnderlying = getStrategyBalance();\r\n            uint128 newShares;\r\n            (newShares, strategyTotalShares) = _getNewShares(strategyTotalShares, stratTotalUnderlying, depositOptimizedAmount);\r\n\r\n            // update reallocation batch deposit shares\r\n            reallocationBatch.depositedReallocationSharesReceived = newShares;\r\n\r\n            strategy.totalUnderlying[processingIndex].amount = stratTotalUnderlying;\r\n\r\n            // reset\r\n            strategy.pendingReallocateOptimizedDeposit = 0;\r\n        }\r\n\r\n        if (depositAverageAmount > 0) {\r\n            reallocationBatch.depositedReallocation += depositAverageAmount;\r\n            strategy.pendingReallocateAverageDeposit = 0;\r\n        }\r\n\r\n        // remove optimized withdraw shares\r\n        if (optimizedSharesWithdrawn > 0) {\r\n            strategyTotalShares -= optimizedSharesWithdrawn;\r\n\r\n            // reset\r\n            strategy.optimizedSharesWithdrawn = 0;\r\n        }\r\n\r\n        // add shares from actual deposit\r\n        if (depositAmount > 0) {\r\n            // deposit\r\n            uint128 depositReceived = _deposit(depositAmount, slippages);\r\n\r\n            // NOTE: might return it from _deposit (only certain strategies need it)\r\n            uint128 stratTotalUnderlying = getStrategyBalance();\r\n\r\n            if (depositReceived > 0) {\r\n                uint128 newShares;\r\n                (newShares, strategyTotalShares) = _getNewSharesAfterWithdraw(strategyTotalShares, stratTotalUnderlying, depositReceived);\r\n\r\n                // update reallocation batch deposit shares\r\n                reallocationBatch.depositedReallocationSharesReceived += newShares;\r\n            }\r\n\r\n            strategy.totalUnderlying[processingIndex].amount = stratTotalUnderlying;\r\n\r\n            // reset\r\n            strategy.pendingReallocateDeposit = 0;\r\n        }\r\n\r\n        // update share storage\r\n        strategy.totalUnderlying[processingIndex].totalShares = strategyTotalShares;\r\n        strategy.totalShares = strategyTotalShares;\r\n    }\r\n\r\n    /* ========== INTERNAL FUNCTIONS ========== */\r\n\r\n    /**\r\n     * @notice get the value of the strategy shares in the underlying tokens\r\n     * @param shares Number of shares\r\n     * @return amount Underling amount representing the `share` value of the strategy\r\n     */\r\n    function _getSharesToAmount(uint256 shares) internal virtual returns(uint128 amount) {\r\n        amount = Math.getProportion128( getStrategyBalance(), shares, strategies[self].totalShares );\r\n    }\r\n\r\n    /**\r\n     * @notice get slippage amount, and action type (withdraw/deposit).\r\n     * @dev\r\n     * Most significant bit represents an action, 0 for a withdrawal and 1 for deposit.\r\n     *\r\n     * This ensures the slippage will be used for the action intended by the do-hard-worker,\r\n     * otherwise the transavtion will revert.\r\n     *\r\n     * @param slippageAction number containing the slippage action and the actual slippage amount\r\n     * @return isDeposit Flag showing if the slippage is for the deposit action\r\n     * @return slippage the slippage value cleaned of the most significant bit\r\n     */\r\n    function _getSlippageAction(uint256 slippageAction) internal pure returns (bool isDeposit, uint256 slippage) {\r\n        // remove most significant bit\r\n        slippage = (slippageAction << 1) >> 1;\r\n\r\n        // if values are not the same (the removed bit was 1) set action to deposit\r\n        if (slippageAction != slippage) {\r\n            isDeposit = true;\r\n        }\r\n    }\r\n\r\n    /* ========== VIRTUAL FUNCTIONS ========== */\r\n\r\n    function _deposit(uint128 amount, uint256[] memory slippages) internal virtual returns(uint128 depositReceived);\r\n    function _withdraw(uint128 shares, uint256[] memory slippages) internal virtual returns(uint128 withdrawReceived);\r\n}\r\n"
    },
    "contracts/strategies/RewardStrategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n\r\npragma solidity 0.8.11;\r\n\r\nimport \"./ProcessStrategy.sol\";\r\nimport \"../shared/SwapHelper.sol\";\r\n\r\nstruct Reward {\r\n    uint256 amount;\r\n    IERC20 token;\r\n}\r\n\r\n/**\r\n * @notice Reward strategy logic\r\n */\r\nabstract contract RewardStrategy is ProcessStrategy, SwapHelper {\r\n\r\n    /* ========== OVERRIDDEN FUNCTIONS ========== */\r\n\r\n    /**\r\n     * @notice Gey strategy underlying asset with rewards\r\n     * @return Total underlying\r\n     */\r\n    function _getStrategyUnderlyingWithRewards() internal view override virtual returns(uint128) {\r\n        Strategy storage strategy = strategies[self];\r\n\r\n        uint128 totalUnderlying = getStrategyBalance();\r\n        totalUnderlying += strategy.pendingDepositReward;\r\n\r\n        return totalUnderlying;\r\n    }\r\n\r\n    /**\r\n     * @notice Process an instant withdrawal from the protocol per users request.\r\n     *\r\n     * @param shares Amount of shares\r\n     * @param slippages Array of slippages\r\n     * @param swapData Data used in processing\r\n     * @return Withdrawn amount\r\n     */\r\n    function _processFastWithdraw(uint128 shares, uint256[] memory slippages, SwapData[] calldata swapData) internal override virtual returns(uint128) {\r\n        uint128 withdrawRewards = _processFastWithdrawalRewards(shares, swapData);\r\n\r\n        uint128 withdrawReceived = _withdraw(shares, slippages);\r\n\r\n        return withdrawReceived + withdrawRewards;\r\n    }\r\n\r\n    /**\r\n     * @notice Process rewards\r\n     * @param swapData Data used in processing\r\n     */\r\n    function _processRewards(SwapData[] calldata swapData) internal override virtual {\r\n        Strategy storage strategy = strategies[self];\r\n\r\n        Reward[] memory rewards = _claimRewards(swapData);\r\n\r\n        uint128 collectedAmount = _sellRewards(rewards, swapData);\r\n\r\n        if (collectedAmount > 0) {\r\n            strategy.pendingDepositReward += collectedAmount;\r\n        }\r\n    }\r\n\r\n    /* ========== INTERNAL FUNCTIONS ========== */\r\n\r\n    /**\r\n     * @notice Process fast withdrawal rewards\r\n     * @param shares Amount of shares\r\n     * @param swapData Values used for swapping the rewards\r\n     * @return withdrawalRewards Withdrawal rewards\r\n     */\r\n    function _processFastWithdrawalRewards(uint128 shares, SwapData[] calldata swapData) internal virtual returns(uint128 withdrawalRewards) {\r\n        Strategy storage strategy = strategies[self];\r\n\r\n        Reward[] memory rewards = _claimFastWithdrawRewards(shares, swapData);\r\n        \r\n        withdrawalRewards += _sellRewards(rewards, swapData);\r\n        \r\n        if (strategy.pendingDepositReward > 0) {\r\n            uint128 fastWithdrawCompound = Math.getProportion128(strategy.pendingDepositReward, shares, strategy.totalShares);\r\n            if (fastWithdrawCompound > 0) {\r\n                strategy.pendingDepositReward -= fastWithdrawCompound;\r\n                withdrawalRewards += fastWithdrawCompound;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Sell rewards to the underlying token\r\n     * @param rewards Rewards to sell\r\n     * @param swapData Values used for swapping the rewards\r\n     * @return collectedAmount Collected underlying amount\r\n     */\r\n    function _sellRewards(Reward[] memory rewards, SwapData[] calldata swapData) internal virtual returns(uint128 collectedAmount) {\r\n        for (uint256 i = 0; i < rewards.length; i++) {\r\n            // add compound amount from current batch to the fast withdraw\r\n            if (rewards[i].amount > 0) { \r\n                uint128 compoundAmount = SafeCast.toUint128(\r\n                    _approveAndSwap(\r\n                        rewards[i].token,\r\n                        underlying,\r\n                        rewards[i].amount,\r\n                        swapData[i]\r\n                    )\r\n                );\r\n\r\n                // add to pending reward\r\n                collectedAmount += compoundAmount;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Get reward claim amount for `shares`\r\n     * @param shares Amount of shares\r\n     * @param rewardAmount Total reward amount\r\n     * @return rewardAmount Amount of reward for the shares\r\n     */\r\n    function _getRewardClaimAmount(uint128 shares, uint256 rewardAmount) internal virtual view returns(uint128) {\r\n        // for do hard work claim everything\r\n        if (shares == type(uint128).max) {\r\n            return SafeCast.toUint128(rewardAmount);\r\n        } else { // for fast withdrawal claim calculate user withdraw amount\r\n            return SafeCast.toUint128((rewardAmount * shares) / strategies[self].totalShares);\r\n        }\r\n    }\r\n\r\n    /* ========== VIRTUAL FUNCTIONS ========== */\r\n    \r\n    function _claimFastWithdrawRewards(uint128 shares, SwapData[] calldata swapData) internal virtual returns(Reward[] memory rewards);\r\n    function _claimRewards(SwapData[] calldata swapData) internal virtual returns(Reward[] memory rewards);\r\n}\r\n"
    },
    "contracts/strategies/convex/ConvexSharedStrategy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n\r\npragma solidity 0.8.11;\r\n\r\nimport \"../curve/base/CurveStrategy3CoinsBase.sol\";\r\nimport \"../MultipleRewardStrategy.sol\";\r\n\r\nimport \"../../external/interfaces/convex/IBooster.sol\";\r\nimport \"../../external/interfaces/convex/IBaseRewardPool.sol\";\r\nimport \"../../interfaces/IStrategyContractHelper.sol\";\r\n\r\n/**\r\n * @notice Convex strategy implementation\r\n */\r\ncontract ConvexSharedStrategy is CurveStrategy3CoinsBase, MultipleRewardStrategy {\r\n    using SafeERC20 for IERC20;\r\n\r\n    /* ========== CONSTANT VARIABLES ========== */\r\n    \r\n    /// @notice There are 2 base reward tokens: CRV and CVX\r\n    uint256 internal constant BASE_REWARDS_COUNT = 2;\r\n\r\n    /* ========== STATE VARIABLES ========== */\r\n\r\n    /// @notice Convex booster contract\r\n    IBooster public immutable booster;\r\n    /// @notice booster pool id\r\n    uint256 public immutable pid;\r\n    /// @notice Reward pool contract\r\n    IBaseRewardPool public immutable crvRewards;\r\n    /// @notice Reward token contract\r\n    IERC20 public immutable rewardToken;\r\n    /// @notice CVX token, reward token\r\n    IERC20 public immutable cvxToken;\r\n    /// @notice Booster helper contract\r\n    IStrategyContractHelper public immutable boosterHelper;\r\n    /// @notice Shared key\r\n    bytes32 private immutable _sharedKey;\r\n\r\n    /* ========== CONSTRUCTOR ========== */\r\n\r\n\r\n    /**\r\n     * @notice Set initial values\r\n     * @param _booster Booster contract\r\n     * @param _boosterPoolId Booster pool id\r\n     * @param _pool Stable swap pool contract\r\n     * @param _lpToken LP token contract\r\n     * @param _underlying Underlying asset\r\n     * @param _boosterDeposit Strategy contract helper\r\n     */\r\n    constructor(\r\n        IBooster _booster,\r\n        uint256 _boosterPoolId,\r\n        IStableSwap3Pool _pool,\r\n        IERC20 _lpToken,\r\n        IERC20 _underlying,\r\n        IStrategyContractHelper _boosterDeposit,\r\n        address _self\r\n    )\r\n        BaseStrategy(_underlying, 0, 1, 1, 1, false, true, _self)\r\n        CurveStrategyBase(_pool, _lpToken)\r\n    {\r\n        require(address(_booster) != address(0), \"ConvexSharedStrategy::constructor: Booster address cannot be 0\");\r\n        booster = _booster;\r\n        pid = _boosterPoolId;\r\n\r\n        IBooster.PoolInfo memory cvxPool = _booster.poolInfo(_boosterPoolId);\r\n\r\n        require(cvxPool.lptoken == address(_lpToken), \"ConvexSharedStrategy::constructor: Booster and curve lp tokens not the same\");\r\n        \r\n        crvRewards = IBaseRewardPool(cvxPool.crvRewards);\r\n        rewardToken = crvRewards.rewardToken();\r\n        cvxToken = IERC20(_booster.minter());\r\n\r\n        boosterHelper = _boosterDeposit;\r\n        \r\n        _sharedKey = _calculateSharedKey();\r\n    }\r\n\r\n    /* ========== OVERRIDDEN FUNCTIONS ========== */\r\n\r\n    /**\r\n     * @notice Initialize strategy\r\n     */\r\n    function initialize() external override {\r\n        _initialize();\r\n    }\r\n\r\n    /**\r\n     * @notice Disable strategy\r\n     */\r\n    function disable() external override {\r\n        _disable();\r\n    }\r\n\r\n    /**\r\n     * @dev Dynamically return slippage length\r\n     * @return Reward slippage slots\r\n     */\r\n    function _getRewardSlippageSlots() internal view override returns(uint256) {\r\n        return crvRewards.extraRewardsLength() + BASE_REWARDS_COUNT;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers lp tokens to helper contract, to deposit them into booster\r\n     */\r\n    function _handleDeposit(uint256 lp) internal override {\r\n        lpToken.safeTransfer(address(boosterHelper), lp);\r\n\r\n        boosterHelper.deposit(lp);\r\n    }\r\n\r\n    /**\r\n     * @dev Withdraw lp tokens from helper contract\r\n     */\r\n    function _handleWithdrawal(uint256 lp) internal override {\r\n\r\n        boosterHelper.withdraw(lp);\r\n    }\r\n\r\n    /**\r\n     * @dev Handle emergency withdrawal\r\n     * @param data Values to perform emergency withdraw\r\n     */\r\n    function _handleEmergencyWithdrawal(address, uint256[] calldata data) internal override {\r\n        // NOTE: withdrawAll removes all lp tokens from the liquidity gauge,\r\n        //       including the tokens from the other strategies in the same pool\r\n        uint256 value = data.length > 0 ? data[0] : 0;\r\n\r\n        if (value == 0) {\r\n            boosterHelper.withdraw(_lpBalance());\r\n            strategies[self].lpTokens = 0;\r\n        } else {\r\n            (bool withdrawAll, uint256 lpTokens) = _getSlippageAction(value);\r\n            \r\n            if (withdrawAll) {\r\n                boosterHelper.withdrawAll();\r\n                strategies[self].lpTokens = 0;\r\n            } else {\r\n                boosterHelper.withdraw(lpTokens);\r\n\r\n                if (lpTokens >= strategies[self].lpTokens) {\r\n                    strategies[self].lpTokens = 0;\r\n                } else {\r\n                    strategies[self].lpTokens -= lpTokens;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Claim multiple rewards\r\n     * @param shares Shares to claim\r\n     * @param swapData Swap slippage and path array\r\n     * @return rewards array of claimed rewards\r\n     */\r\n    function _claimMultipleRewards(uint128 shares, SwapData[] calldata swapData) internal override returns(Reward[] memory rewards) {\r\n        if (swapData.length > 0) {\r\n            uint256 extraRewardCount = crvRewards.extraRewardsLength();\r\n            \r\n            rewards = new Reward[](extraRewardCount + BASE_REWARDS_COUNT);\r\n\r\n            address[] memory rewardTokens = _getRewardAddresses(extraRewardCount);\r\n            _claimStrategyRewards(rewardTokens);\r\n\r\n            Strategy storage strategy = strategies[self];\r\n            for (uint256 i = 0; i < rewardTokens.length; i++) {\r\n\r\n                if (swapData[i].slippage > 0) {\r\n                    uint256 rewardTokenAmount = strategy.pendingRewards[rewardTokens[i]];\r\n\r\n                    if (rewardTokenAmount > 0) {\r\n                        uint256 claimedAmount = _getRewardClaimAmount(shares, rewardTokenAmount);\r\n\r\n                        if (rewardTokenAmount > claimedAmount) {\r\n                            // if we don't swap all the tokens (fast withdraw), store the amount left \r\n                            uint256 rewardAmountLeft = rewardTokenAmount - claimedAmount;\r\n                            strategy.pendingRewards[rewardTokens[i]] = rewardAmountLeft;\r\n                        } else {\r\n                            strategy.pendingRewards[rewardTokens[i]] = 0;\r\n                        }\r\n\r\n                        rewards[i] = Reward(claimedAmount, IERC20(rewardTokens[i]));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /* ========== PRIVATE FUNCTIONS ========== */\r\n\r\n    /**\r\n     * @dev Claim strategy rewards\r\n     * @param rewardTokens Reward tokens\r\n     */\r\n    function _claimStrategyRewards(address[] memory rewardTokens) private {\r\n        (\r\n            uint256[] memory rewardTokenAmounts,\r\n            bool didClaimNewRewards\r\n        ) = boosterHelper.claimRewards(rewardTokens, true);\r\n\r\n        if (didClaimNewRewards) {\r\n            Strategy storage strategy = strategies[self];\r\n\r\n            for(uint256 i = 0; i < rewardTokens.length; i++) {\r\n                if (rewardTokenAmounts[i] > 0) {\r\n                    strategy.pendingRewards[rewardTokens[i]] += rewardTokenAmounts[i];\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Get reward addresses\r\n     * @param extraRewardCount Extra reward count\r\n     * @return Reward addresses\r\n     */\r\n    function _getRewardAddresses(uint256 extraRewardCount) private view returns(address[] memory) {\r\n        address[] memory rewardAddresses = new address[](extraRewardCount + BASE_REWARDS_COUNT);\r\n        rewardAddresses[0] = address(rewardToken);\r\n        rewardAddresses[1] = address(cvxToken);\r\n\r\n        for (uint256 i = 0; i < extraRewardCount; i++) {\r\n            rewardAddresses[i + BASE_REWARDS_COUNT] = address(crvRewards.extraReward(i));\r\n        }\r\n\r\n        return rewardAddresses;\r\n    }\r\n\r\n    /**\r\n     * @dev Calculate shared key\r\n     * @return Shared key\r\n     */\r\n    function _calculateSharedKey() private view returns(bytes32) {\r\n        return keccak256(abi.encodePacked(address(booster), pid));\r\n    }\r\n\r\n    /**\r\n     * @dev Get shared key\r\n     * @return Shared key\r\n     */\r\n    function _getSharedKey() internal view override returns(bytes32) {\r\n        return _sharedKey;\r\n    }\r\n}"
    },
    "contracts/strategies/curve/base/CurveStrategy3CoinsBase.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n\r\npragma solidity 0.8.11;\r\n\r\nimport \"./CurveStrategyBase.sol\";\r\nimport \"../../../external/interfaces/curve/IStableSwap3Pool.sol\";\r\n\r\n/**\r\n * @notice Curve 3Coins base strategy\r\n */\r\nabstract contract CurveStrategy3CoinsBase is CurveStrategyBase {\r\n    using SafeERC20 for IERC20;\r\n\r\n    /* ========== CONSTANT VARIABLES ========== */\r\n\r\n    /// @notice Total number of coins\r\n    uint256 internal constant TOTAL_COINS = 3;\r\n\r\n    /* ========== STATE VARIABLES ========== */\r\n\r\n    /// @notice Stable swap pool\r\n    IStableSwap3Pool public immutable pool3Coins;\r\n\r\n    /* ========== CONSTRUCTOR ========== */\r\n\r\n    constructor() {\r\n        pool3Coins = IStableSwap3Pool(address(pool));\r\n    }\r\n\r\n    /* ========== OVERRIDDEN FUNCTIONS ========== */\r\n\r\n    /**\r\n     * @dev register a strategy as shared strategy, using shared key\r\n     */\r\n    function _initialize() internal virtual {\r\n        StrategiesShared storage stratsShared = strategiesShared[_getSharedKey()];\r\n        \r\n        stratsShared.stratAddresses[stratsShared.stratsCount] = self;\r\n        stratsShared.stratsCount++;\r\n    }\r\n\r\n    /**\r\n     * @notice Run after strategy was removed as a breakdown function\r\n     */\r\n    function _disable() internal virtual {\r\n        StrategiesShared storage stratsShared = strategiesShared[_getSharedKey()];\r\n\r\n        uint256 sharedStratsCount = stratsShared.stratsCount;\r\n\r\n        for(uint256 i = 0; i < sharedStratsCount; i++) {\r\n            if (stratsShared.stratAddresses[i] == self) {\r\n                stratsShared.stratAddresses[i] = stratsShared.stratAddresses[sharedStratsCount - 1];\r\n                delete stratsShared.stratAddresses[sharedStratsCount - 1];\r\n                stratsShared.stratsCount--;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Deposit\r\n     * @param amount Amount\r\n     * @param slippage Slippage\r\n     */\r\n    function _curveDeposit(uint256 amount, uint256 slippage) internal override {\r\n        uint256[TOTAL_COINS] memory amounts;\r\n        amounts[uint128(nCoin)] = amount;\r\n\r\n        pool3Coins.add_liquidity(amounts, slippage);\r\n    }\r\n\r\n    /* ========== VIRTUAL FUNCTIONS ========== */\r\n\r\n    /**\r\n     * @notice Get shared key\r\n     * @return Shared key\r\n     */\r\n    function _getSharedKey() internal virtual view returns(bytes32);\r\n}"
    },
    "contracts/strategies/curve/base/CurveStrategyBase.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\n\r\npragma solidity 0.8.11;\r\n\r\nimport \"../../../external/@openzeppelin/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"../../ProcessStrategy.sol\";\r\nimport \"../../../external/interfaces/curve/ICurvePool.sol\";\r\n\r\nabstract contract CurveStrategyBase is ProcessStrategy {\r\n    using SafeERC20 for IERC20;\r\n\r\n    /* ========== CONSTANT VARIABLES ========== */\r\n\r\n    uint256 internal constant ONE_LP_UNIT = 1e18;\r\n\r\n    /* ========== STATE VARIABLES ========== */\r\n\r\n    ICurvePool public immutable pool;\r\n    IERC20 public immutable lpToken;\r\n    int128 public immutable nCoin;\r\n\r\n    /* ========== CONSTRUCTOR ========== */\r\n\r\n    constructor(\r\n        ICurvePool _pool,\r\n        IERC20 _lpToken\r\n    ) {\r\n        require(address(_pool) != address(0), \"CurveStrategy::constructor: Curve Pool address cannot be 0\");\r\n        require(address(_lpToken) != address(0), \"CurveStrategy::constructor: Token address cannot be 0\");\r\n\r\n        pool = _pool;\r\n        lpToken = _lpToken;\r\n        \r\n        uint128 _nCoin = 0;\r\n        while (_pool.coins(_nCoin) != address(underlying)) _nCoin++;\r\n        nCoin = int128(_nCoin);\r\n    }\r\n\r\n    /* ========== VIEWS ========== */\r\n\r\n    function getStrategyBalance() public view override returns(uint128) {\r\n        return _lpToCoin(_lpBalance());\r\n    }\r\n\r\n    /* ========== OVERRIDDEN FUNCTIONS ========== */\r\n\r\n    function _deposit(uint128 amount, uint256[] memory slippages) internal override returns(uint128) {\r\n        (bool isDeposit, uint256 slippage) = _getSlippageAction(slippages[0]);\r\n        require(isDeposit, \"CurveStrategyBase::_deposit: Withdraw slippage provided\");\r\n        \r\n        // deposit underlying\r\n        underlying.safeApprove(address(pool), amount);\r\n        \r\n        uint256 lpBefore = lpToken.balanceOf(address(this));\r\n        _curveDeposit(amount, slippage);\r\n        uint256 newLp = lpToken.balanceOf(address(this)) - lpBefore;\r\n        _resetAllowance(underlying, address(pool));\r\n\r\n        emit Slippage(self, underlying, true, amount, newLp);\r\n\r\n        strategies[self].lpTokens += newLp;\r\n\r\n        _handleDeposit(newLp);\r\n        return _lpToCoin(newLp);\r\n    }\r\n\r\n    function _withdraw(uint128 shares, uint256[] memory slippages) internal override returns(uint128) {\r\n        (bool isDeposit, uint256 slippage) = _getSlippageAction(slippages[0]);\r\n        require(!isDeposit, \"CurveStrategyBase::_withdraw: Deposit slippage provided\");\r\n\r\n        uint256 totalLp = _lpBalance();\r\n\r\n        uint256 withdrawLp = (totalLp * shares) / strategies[self].totalShares;\r\n        strategies[self].lpTokens -= withdrawLp;\r\n\r\n        // withdraw staked lp tokens\r\n        _handleWithdrawal(withdrawLp);\r\n\r\n        // withdraw fTokens from vault\r\n        uint256 undelyingBefore = underlying.balanceOf(address(this));\r\n        \r\n        pool.remove_liquidity_one_coin(withdrawLp, nCoin, slippage);\r\n        uint256 underlyingWithdrawn = underlying.balanceOf(address(this)) - undelyingBefore;\r\n\r\n        emit Slippage(self, underlying, false, shares, underlyingWithdrawn);\r\n\r\n        return SafeCast.toUint128(underlyingWithdrawn);\r\n    }\r\n\r\n    /**\r\n     * @notice Emergency withdraw from curve pool\r\n     */\r\n    function _emergencyWithdraw(address recipient, uint256[] calldata data) internal override {\r\n        uint256 slippage = data.length > 0 ? data[0] : 0;\r\n\r\n        uint256[] calldata poolData = data.length > 0 ? data[1:] : data;\r\n\r\n        uint256 lpBefore = lpToken.balanceOf(address(this));\r\n        _handleEmergencyWithdrawal(recipient, poolData);\r\n        uint256 newLp = lpToken.balanceOf(address(this)) - lpBefore;\r\n\r\n        pool.remove_liquidity_one_coin(newLp, nCoin, slippage);\r\n    }\r\n\r\n    /* ========== INTERNAL FUNCTIONS ========== */\r\n\r\n    function _lpBalance() internal view returns (uint256) {\r\n        return strategies[self].lpTokens;\r\n    }\r\n\r\n    function _lpToCoin(uint256 lp) internal view returns (uint128) {\r\n        if (lp == 0)\r\n            return 0;\r\n        \r\n        uint256 lpToCoin = pool.calc_withdraw_one_coin(ONE_LP_UNIT, nCoin);\r\n\r\n        uint256 result = (lp * lpToCoin) / ONE_LP_UNIT;\r\n\r\n        return SafeCast.toUint128(result);\r\n    }\r\n\r\n    /* ========== VIRTUAL FUNCTIONS ========== */\r\n    \r\n    function _curveDeposit(uint256 amount, uint256 slippage) internal virtual;\r\n\r\n    function _handleDeposit(uint256 lp) internal virtual;\r\n\r\n    function _handleWithdrawal(uint256 lp) internal virtual;\r\n\r\n    function _handleEmergencyWithdrawal(address recipient, uint256[] calldata data) internal virtual;\r\n}"
    }
  }
}}