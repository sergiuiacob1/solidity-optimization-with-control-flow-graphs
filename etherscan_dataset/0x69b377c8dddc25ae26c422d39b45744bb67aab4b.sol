{"base64.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.2;\n\n/// [MIT License]\n/// @title Base64\n/// @notice Provides a function for encoding some bytes in base64\n/// @author Brecht Devos \u003cbrecht@loopring.org\u003e\nlibrary Base64 {\n  bytes internal constant TABLE = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n  /// @notice Encodes some bytes to the base64 representation\n  function encode(bytes memory data) internal pure returns (string memory) {\n    uint256 len = data.length;\n    if (len == 0) return \"\";\n\n    // multiply by 4/3 rounded up\n    uint256 encodedLen = 4 * ((len + 2) / 3);\n\n    // Add some extra buffer at the end\n    bytes memory result = new bytes(encodedLen + 32);\n\n    bytes memory table = TABLE;\n\n    assembly {\n      let tablePtr := add(table, 1)\n      let resultPtr := add(result, 32)\n\n      for {\n        let i := 0\n      } lt(i, len) {\n\n      } {\n        i := add(i, 3)\n        let input := and(mload(add(data, i)), 0xffffff)\n\n        let out := mload(add(tablePtr, and(shr(18, input), 0x3F)))\n        out := shl(8, out)\n        out := add(out, and(mload(add(tablePtr, and(shr(12, input), 0x3F))), 0xFF))\n        out := shl(8, out)\n        out := add(out, and(mload(add(tablePtr, and(shr(6, input), 0x3F))), 0xFF))\n        out := shl(8, out)\n        out := add(out, and(mload(add(tablePtr, and(input, 0x3F))), 0xFF))\n        out := shl(224, out)\n\n        mstore(resultPtr, out)\n\n        resultPtr := add(resultPtr, 4)\n      }\n\n      switch mod(len, 3)\n      case 1 {\n        mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\n      }\n      case 2 {\n        mstore(sub(resultPtr, 1), shl(248, 0x3d))\n      }\n\n      mstore(result, encodedLen)\n    }\n\n    return string(result);\n  }\n}"},"Renderer.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity ^0.8.11;\n\nimport \u0027./SVG.sol\u0027;\nimport \u0027./Utils.sol\u0027;\n\n/// @title Spherical GeNFTs Renderer\n/// @author espina (modified from w1nt3r.eth\u0027s hot-chain-svg)\n/// @notice contract to render onchain generative SVGs\n\ninterface SphereInterface {\n    function balanceOf(address owner) external view returns (uint256 balance);\n}\ninterface KarmicInterface {\n    function allBalancesOf(address holder) external view returns (uint256[] memory balances);\n}\n\ncontract Renderer {\n    address sphereNFTAddress = address(0x2346358D22b8b59f25A1Cf05BbE86FE762db6134);\n    address karmicAddress = address(0xe323C27212F34fCEABBBd98A5f43505dDeC266Dc); \n    SphereInterface sphereInterface = SphereInterface(sphereNFTAddress);\n    KarmicInterface karmicInterface = KarmicInterface(karmicAddress);\n\n    struct SphereProps {\n        uint stop1;\n        string color1;\n        string color2;\n        uint16 radius;\n        uint posY;\n        uint ind;\n    }\n\n    function _render(uint256 _tokenId, address _owner, uint256 _birthdate) internal view returns (string memory) {\n        uint elapsed = (block.timestamp - _birthdate) /  1 weeks;\n        uint age = _sqrtu(2 * elapsed) + 3;\n        string[2][2] memory colors = _setColors(_tokenId, _owner);\n        string memory bgColPick = _bgColor(_owner);\n        string memory bordCol;\n        if ((keccak256(abi.encodePacked(bgColPick))) == (keccak256(abi.encodePacked(\u0027#FFFFFF\u0027)))) { \n            bordCol = \u0027black\u0027; \n            } else {\n                bordCol = \u0027white\u0027; \n        } \n\n        return\n            string.concat(\n                string.concat(\u0027\u003csvg xmlns=\"http://www.w3.org/2000/svg\" width=\"1600\" height=\"2400\" style=\"background:\u0027, _bgColor(_owner),\u0027\"\u003e\u0027),\n                _sphereGen(_tokenId, _owner, age, colors),\n                _drawBorder(bordCol),                \n                \u0027\u003c/svg\u003e\u0027\n            );\n    }\n\n    function _setColors(uint256 _tokenId, address _owner) internal pure returns(string[2][2] memory) {\n        string[2][2] memory randClr;\n        randClr[0][0] = string.concat(\u0027hsl(\u0027, utils.uint2str(_random(_tokenId, 1, _owner,  \u0027clrs\u0027) % 360), \u0027, 36%, 65%, 0%)\u0027);\n        randClr[0][1] = string.concat(\u0027hsl(\u0027, utils.uint2str(_random(_tokenId, 1, _owner,  \u0027clrs\u0027) % 360), \u0027, 36%, 65%, 78%)\u0027);\n        randClr[1][0] = string.concat(\u0027hsl(\u0027, utils.uint2str(_random(_tokenId, 2, _owner,  \u0027clrs\u0027) % 360), \u0027, 36%, 65%, 0%)\u0027);\n        randClr[1][1] = string.concat(\u0027hsl(\u0027, utils.uint2str(_random(_tokenId, 2, _owner,  \u0027clrs\u0027) % 360), \u0027, 36%, 65%, 78%)\u0027);\n        return randClr;\n    }\n\n    function _sphereGen(uint _tokenId, address _owner, uint _age, string[2][2] memory _colors) internal pure returns (string memory) {\n        string memory spheresSVG;\n        for (uint i = 0; i \u003c _age; i++) {\n            SphereProps memory sphereProp;\n            uint colorPick = _random(_tokenId, i, _owner, \u0027r\u0027) % 2;\n            sphereProp.ind = i;\n            sphereProp.stop1 = _random(_tokenId, i, _owner, \u0027stop1\u0027) % 90;\n            sphereProp.color1 = _colors[colorPick][0];\n            sphereProp.color2 = _colors[colorPick][1];\n            sphereProp.radius = uint16(_random(_tokenId, i, _owner, \u0027r\u0027) % ((800) -(186+45)) +45);\n            uint16[3] memory yPositions = [\n                uint16(sphereProp.radius + 186), \n                uint16(1200), \n                uint16(2400 - 186 -sphereProp.radius)]; //possible sphere positions for top,center, bottom\n            sphereProp.posY = yPositions[_random(_tokenId, i, _owner, \u0027pY\u0027) % 3];\n            spheresSVG = string.concat(spheresSVG, _spheres(sphereProp));\n\n        }\n        return spheresSVG;\n    }\n\n    function _spheres(SphereProps memory _sphereProp) internal pure returns(string memory) {\n        return string.concat(\n            \n            svg.radialGradient(\n                string.concat(\n                    svg.prop(\u0027id\u0027, string.concat(\u0027sphereGradient\u0027, utils.uint2str(_sphereProp.ind)))\n                ),\n                string.concat(\n                    svg.gradientStop(80, _sphereProp.color1, utils.NULL), //first stop amount should be random\n                    svg.gradientStop(100,_sphereProp.color2,utils.NULL)\n\n                )\n            ),\n\n            svg.circle(\n                string.concat(\n                    svg.prop(\u0027cx\u0027, utils.uint2str(800)),\n                    svg.prop(\u0027cy\u0027, utils.uint2str(_sphereProp.posY)),\n                    svg.prop(\u0027r\u0027, utils.uint2str(_sphereProp.radius)),\n                    svg.prop(\u0027fill\u0027, string.concat(\"url(\u0027#sphereGradient\", utils.uint2str(_sphereProp.ind), \"\u0027)\"))\n                ),\n                utils.NULL\n            )\n        );\n    }\n\n    function _random(uint _tokenId, uint _ind, address _owner, string memory _prop) internal pure returns (uint) {\n        return uint(keccak256(abi.encodePacked(_ind, _owner, _tokenId, _prop)));\n    }\n\n    function _bgColor(address _owner) internal view returns (string memory) {\n        bool sphereHolder = (sphereInterface.balanceOf(_owner) \u003e 0);\n        uint256[] memory karmics = karmicInterface.allBalancesOf(_owner);\n        bool karmicHolder = false;\n        \n        for(uint i = 0; i \u003c karmics.length; i++) {\n            if (karmics[i] \u003e 0) { karmicHolder = true; }\n        }\n        \n        if (karmicHolder \u0026\u0026 sphereHolder) {\n            return \u0027#FFFFFF\u0027;\n        } else if (karmicHolder) {\n            return \u0027#733700\u0027;\n        } else if (sphereHolder) {\n            return \u0027#000957\u0027;\n        } else {\n            return \u0027#000000\u0027;\n        }\n    }\n\n    function _drawBorder(string memory _bordCol) internal pure returns(string memory) {\n        return \n        string.concat(\n            _rects(80,80,1440,2240,_bordCol),\n            _rects(106,106,1388,2188,_bordCol),\n            _rects(80,80,68,52,_bordCol),\n            _rects(1452,80,68,52,_bordCol),\n            _rects(80,2268,68,52,_bordCol),\n            _rects(1452,2268,68,52,_bordCol)\n        );\n\n    }\n\n    function _rects(uint _x, uint _y,uint  _width,uint _height, string memory _bordCol) internal pure returns(string memory) {\n        return svg.rect(\n            string.concat(\n                svg.prop(\u0027x\u0027, utils.uint2str(_x)),\n                svg.prop(\u0027y\u0027, utils.uint2str(_y)),\n                svg.prop(\u0027width\u0027, utils.uint2str(_width)),\n                svg.prop(\u0027height\u0027, utils.uint2str(_height)),\n                svg.prop(\u0027stroke\u0027, _bordCol),\n                svg.prop(\u0027fill-opacity\u0027, utils.uint2str(0)),\n                svg.prop(\u0027stroke-width\u0027, utils.uint2str(3))\n            ),\n            utils.NULL\n        );\n    }\n\n    //Square root function from ABDK Math\n    function _sqrtu (uint256 x) internal pure returns (uint128) {\n        unchecked {\n        if (x == 0) return 0;\n        else {\n            uint256 xx = x;\n            uint256 r = 1;\n            if (xx \u003e= 0x100000000000000000000000000000000) { xx \u003e\u003e= 128; r \u003c\u003c= 64; }\n            if (xx \u003e= 0x10000000000000000) { xx \u003e\u003e= 64; r \u003c\u003c= 32; }\n            if (xx \u003e= 0x100000000) { xx \u003e\u003e= 32; r \u003c\u003c= 16; }\n            if (xx \u003e= 0x10000) { xx \u003e\u003e= 16; r \u003c\u003c= 8; }\n            if (xx \u003e= 0x100) { xx \u003e\u003e= 8; r \u003c\u003c= 4; }\n            if (xx \u003e= 0x10) { xx \u003e\u003e= 4; r \u003c\u003c= 2; }\n            if (xx \u003e= 0x8) { r \u003c\u003c= 1; }\n            r = (r + x / r) \u003e\u003e 1;\n            r = (r + x / r) \u003e\u003e 1;\n            r = (r + x / r) \u003e\u003e 1;\n            r = (r + x / r) \u003e\u003e 1;\n            r = (r + x / r) \u003e\u003e 1;\n            r = (r + x / r) \u003e\u003e 1;\n            r = (r + x / r) \u003e\u003e 1; // Seven iterations should be enough\n            uint256 r1 = x / r;\n            return uint128 (r \u003c r1 ? r : r1);\n        }\n        }\n    }\n\n}\n"},"Spherical.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \u0027./Renderer.sol\u0027;\nimport \u0027./base64.sol\u0027;\n\n/// @title Spherical GeNFTs\n/// @author espina (based on Miguel Piedrafita\u0027s SoulMinter)\n/// @notice contract to mint Soulbound NFTs with onchain generative SVGs\n\ncontract Spherical is Renderer {\n    /// @notice Thrown when trying to transfer a Soulbound token\n    error Soulbound();\n\n    /// @notice Emitted when minting a Soulbound NFT\n    /// @param from Who the token comes from. Will always be address(0)\n    /// @param to The token recipient\n    /// @param id The ID of the minted token\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 indexed id\n    );\n\n    /// @notice The symbol for the token\n    string public constant symbol = \"OOOO\";\n\n    /// @notice The name for the token\n    string public constant name = \"Spherical\";\n\n    /// @notice The owner of this contract (set to the deployer)\n    address public immutable owner = msg.sender;\n    address[2] public admins = [address(0xA6aF4168482CE3c40dedAb6A45F194a2B4a3FF33), address(0x2ac85F79d0FBE628594F7BC1d2311cDF700EF57A) ];\n\n    address payable public constant sphereAdr = payable(0x2ac85F79d0FBE628594F7BC1d2311cDF700EF57A);\n    address payable public constant espinaAdr = payable(0x5706542bb1e2eA5A10f820eA9E23AEfCe4858629);\n\n    /// @notice Get the owner of a certain tokenID\n    mapping(uint256 =\u003e address) public ownerOf;\n\n    /// @notice Get how many SoulMinter NFTs a certain user owns\n    mapping(address =\u003e uint256) public balanceOf;\n\n    /// @notice Get birthdate of tokenID\n    mapping(uint256 =\u003e uint256) public birthOf;\n\n    /// @dev Counter for the next tokenID, defaults to 1 for better gas on first mint\n    uint256 internal nextTokenId = 1;\n\n    constructor() payable {}\n\n    /// @notice This function was disabled to make the token Soulbound. Calling it will revert\n    function approve(address, uint256) public virtual {\n        revert Soulbound();\n    }\n\n    /// @notice This function was disabled to make the token Soulbound. Calling it will revert\n    function isApprovedForAll(address, address) public pure {\n        revert Soulbound();\n    }\n\n    /// @notice This function was disabled to make the token Soulbound. Calling it will revert\n    function getApproved(uint256) public pure {\n        revert Soulbound();\n    }\n\n    /// @notice This function was disabled to make the token Soulbound. Calling it will revert\n    function setApprovalForAll(address, bool) public virtual {\n        revert Soulbound();\n    }\n\n    /// @notice This function was disabled to make the token Soulbound. Calling it will revert\n    function transferFrom(\n        address,\n        address,\n        uint256\n    ) public virtual {\n        revert Soulbound();\n    }\n\n    /// @notice This function was disabled to make the token Soulbound. Calling it will revert\n    function safeTransferFrom(\n        address,\n        address,\n        uint256\n    ) public virtual {\n        revert Soulbound();\n    }\n\n    /// @notice This function was disabled to make the token Soulbound. Calling it will revert\n    function safeTransferFrom(\n        address,\n        address,\n        uint256,\n        bytes calldata\n    ) public virtual {\n        revert Soulbound();\n    }\n\n    function supportsInterface(bytes4 interfaceId) public pure returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\n    }\n\n    /// @notice Withdraw function to transfer funds from mints\n    function withdraw() public {\n        uint256 espinaShare = address(this).balance / 10;\n        uint256 sphereShare = address(this).balance - espinaShare;\n        payable(espinaAdr).transfer(espinaShare);\n        payable(sphereAdr).transfer(sphereShare);\n    }\n\n    /// @notice Mint a new Soulbound NFT to `to`\n    /// @param to The recipient of the NFT\n    function mint(address to) external payable {\n        // Check to make sure 0.25 ether was sent to the function call:\n        require(msg.value == 0.25 ether, \u0027Wrong amount of ETH sent\u0027);\n        require(balanceOf[to] == 0, \u0027You can only mint one\u0027);\n\n        // If so, some logic to transfer the digital item to the caller of the function:\n        unchecked {\n            balanceOf[to]++;\n        }\n\n        ownerOf[nextTokenId] = to;\n        birthOf[nextTokenId] = block.timestamp;\n\n        emit Transfer(address(0), to, nextTokenId++);\n    }\n\n    /// @dev Returns an URI for a given token ID\n    function tokenURI(uint256 _tokenId) public view returns (string memory) {\n        require(ownerOf[_tokenId] != address(0), \u0027Token does not exist\u0027);\n        address tokenOwner = ownerOf[_tokenId];\n        uint256 birthdate = birthOf[_tokenId];\n        string memory svgString = _render(_tokenId, tokenOwner, birthdate);\n        return _metadata(_tokenId, svgString);\n    }\n\n    /// @dev Returns metadata as a json\n    function _metadata(uint256 _tokenId, string memory _svgString) internal pure returns (string memory) {\n        string memory tokenName = string(abi.encodePacked(\u0027Spherical #\u0027, utils.uint2str(_tokenId)));\n        string memory tokenDescription = \"The Sphere is a research-creation project developing new ecologies of funding for the performing arts. We envisage a world in which audiences co-own the artworks they love together with the artists, collectors and other stakeholders of a given project.\\\\nWebsite: [thesphere.as](https://thesphere.as)  Twitter: [@thesphere_as](https://twitter.com/thesphere_as)\\\\n\\\\nThe Spherical GeNFTs are dynamic on-chain generative artworks that evolve over time as an expression of membership in The Sphere. The particularities of the holder\u0027s wallet become the seed for an ongoing creation.\";\n        string memory json = string(\n            abi.encodePacked(\u0027{\"name\":\"\u0027, \n            tokenName, \u0027\",\"description\":\"\u0027, \n            tokenDescription, \u0027\",\"image\": \"data:image/svg+xml;base64,\u0027, \n            Base64.encode(bytes(_svgString)), \u0027\"}\u0027)\n        );\n        return string(abi.encodePacked(\"data:application/json;base64,\", Base64.encode(bytes(json))));\n    }\n\n    /// @notice Airdrop NFTs to an array of addresses\n    /// @param _recipients The recipients of the NFTs\n    function airdrop(address[] calldata _recipients) public {\n        require((msg.sender == admins[0] || msg.sender == admins[1]), \u0027Not allowed to airdop\u0027);\n\n        for (uint i = 0; i\u003c _recipients.length; i++){\n            \n            unchecked {\n                balanceOf[_recipients[i]]++;\n            }\n\n            ownerOf[nextTokenId] = _recipients[i];\n            birthOf[nextTokenId] = block.timestamp;\n\n            emit Transfer(address(0), _recipients[i], nextTokenId++);\n        }\n    }\n\n    /// @notice Change the admin of the contract\n    /// @param _newAdmin The admin that permission will be transferred to\n    function changeAdmin(address _newAdmin, uint adminId) public {\n        require(adminId \u003c= 1, \u0027Only two admins\u0027);\n        require((msg.sender == admins[0] || msg.sender == admins[1]), \u0027Only admin can change\u0027);\n        admins[adminId] = _newAdmin;\n    }\n\n    /// @notice Burn a token\n    /// @param _tokenId to be burned\n    function burn(uint256 _tokenId) public {\n        require(msg.sender == ownerOf[_tokenId], \u0027Only owner can burn\u0027);\n        balanceOf[msg.sender] = 0;\n        ownerOf[_tokenId] = address(0);\n        birthOf[_tokenId] = block.timestamp;\n\n        emit Transfer(msg.sender, address(0), _tokenId);\n    }\n}\n\n"},"SVG.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity ^0.8.12;\nimport \u0027./Utils.sol\u0027;\n\n/// @author w1nt3r.eth\n// Core SVG utilitiy library which helps us construct\n// onchain SVG\u0027s with a simple, web-like API.\nlibrary svg {\n    /* MAIN ELEMENTS */\n\n    function circle(string memory _props, string memory _children)\n        internal\n        pure\n        returns (string memory)\n    {\n        return el(\u0027circle\u0027, _props, _children);\n    }\n\n    function circle(string memory _props)\n        internal\n        pure\n        returns (string memory)\n    {\n        return el(\u0027circle\u0027, _props);\n    }\n\n    function rect(string memory _props, string memory _children)\n        internal\n        pure\n        returns (string memory)\n    {\n        return el(\u0027rect\u0027, _props, _children);\n    }\n\n    function rect(string memory _props)\n        internal\n        pure\n        returns (string memory)\n    {\n        return el(\u0027rect\u0027, _props);\n    }\n\n\n    /* GRADIENTS */\n    function radialGradient(string memory _props, string memory _children)\n        internal\n        pure\n        returns (string memory)\n    {\n        return el(\u0027radialGradient\u0027, _props, _children);\n    }\n\n    function gradientStop(\n        uint256 offset,\n        string memory stopColor,\n        string memory _props\n    ) internal pure returns (string memory) {\n        return\n            el(\n                \u0027stop\u0027,\n                string.concat(\n                    prop(\u0027stop-color\u0027, stopColor),\n                    \u0027 \u0027,\n                    prop(\u0027offset\u0027, string.concat(utils.uint2str(offset), \u0027%\u0027)),\n                    \u0027 \u0027,\n                    _props\n                )\n            );\n    }\n\n\n\n    /* COMMON */\n    // A generic element, can be used to construct any SVG (or HTML) element\n    function el(\n        string memory _tag,\n        string memory _props,\n        string memory _children\n    ) internal pure returns (string memory) {\n        return\n            string.concat(\n                \u0027\u003c\u0027,\n                _tag,\n                \u0027 \u0027,\n                _props,\n                \u0027\u003e\u0027,\n                _children,\n                \u0027\u003c/\u0027,\n                _tag,\n                \u0027\u003e\u0027\n            );\n    }\n\n    // A generic element, can be used to construct any SVG (or HTML) element without children\n    function el(\n        string memory _tag,\n        string memory _props\n    ) internal pure returns (string memory) {\n        return\n            string.concat(\n                \u0027\u003c\u0027,\n                _tag,\n                \u0027 \u0027,\n                _props,\n                \u0027/\u003e\u0027\n            );\n    }\n\n    // an SVG attribute\n    function prop(string memory _key, string memory _val)\n        internal\n        pure\n        returns (string memory)\n    {\n        return string.concat(_key, \u0027=\u0027, \u0027\"\u0027, _val, \u0027\" \u0027);\n    }\n}\n"},"Utils.sol":{"content":"//SPDX-License-Identifier: MIT\npragma solidity ^0.8.12;\n\n// @author w1nt3r.eth\n// Core utils used extensively to format CSS and numbers.\nlibrary utils {\n    // used to simulate empty strings\n    string internal constant NULL = \u0027\u0027;\n\n    // converts an unsigned integer to a string\n    function uint2str(uint256 _i)\n        internal\n        pure\n        returns (string memory _uintAsString)\n    {\n        if (_i == 0) {\n            return \u00270\u0027;\n        }\n        uint256 j = _i;\n        uint256 len;\n        while (j != 0) {\n            len++;\n            j /= 10;\n        }\n        bytes memory bstr = new bytes(len);\n        uint256 k = len;\n        while (_i != 0) {\n            k = k - 1;\n            uint8 temp = (48 + uint8(_i - (_i / 10) * 10));\n            bytes1 b1 = bytes1(temp);\n            bstr[k] = b1;\n            _i /= 10;\n        }\n        return string(bstr);\n    }\n}\n"}}