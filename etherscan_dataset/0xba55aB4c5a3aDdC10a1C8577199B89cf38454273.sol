{{
  "language": "Solidity",
  "settings": {
    "evmVersion": "istanbul",
    "libraries": {},
    "metadata": {
      "bytecodeHash": "ipfs",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "contracts/rentAdapters/LandworksAdapter.sol": {
      "content": "// Sources flattened with hardhat v2.8.0 https://hardhat.org\r\n\r\n// File @openzeppelin/contracts/utils/introspection/IERC165.sol@v4.1.0\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC721/IERC721.sol@v4.1.0\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ninterface IERC721 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\r\n     */\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\r\n     */\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of tokens in ``owner``'s account.\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n     * The approval is cleared when the token is transferred.\r\n     *\r\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The caller must own the token or be an approved operator.\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Returns the account approved for `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n    /**\r\n     * @dev Approve or remove `operator` as an operator for the caller.\r\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The `operator` cannot be the caller.\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     */\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    /**\r\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n     *\r\n     * See {setApprovalForAll}\r\n     */\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\r\n    /**\r\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n      *\r\n      * Requirements:\r\n      *\r\n      * - `from` cannot be the zero address.\r\n      * - `to` cannot be the zero address.\r\n      * - `tokenId` token must exist and be owned by `from`.\r\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n      *\r\n      * Emits a {Transfer} event.\r\n      */\r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/Address.sol@v4.1.0\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File contracts/rentAdapters/libraries/LibLandworks.sol\r\n\r\npragma solidity 0.8.0;\r\n\r\nlibrary LibLandworks {\r\n    enum AssetStatus {\r\n        Listed,\r\n        Delisted\r\n    }\r\n\r\n    struct Asset {\r\n        uint256 metaverseId;\r\n        address metaverseRegistry;\r\n        uint256 metaverseAssetId;\r\n        address paymentToken;\r\n        uint256 minPeriod;\r\n        uint256 maxPeriod;\r\n        uint256 maxFutureTime;\r\n        uint256 pricePerSecond;\r\n        uint256 totalRents;\r\n        AssetStatus status;\r\n    }\r\n\r\n    struct Rent {\r\n        address renter;\r\n        uint256 start;\r\n        uint256 end;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/rentAdapters/interfaces/ILandworks.sol\r\n\r\npragma solidity 0.8.0;\r\ninterface ILandworks {\r\n    // MarketplaceFacet\r\n    function list(\r\n        uint256 _metaverseId,\r\n        address _metaverseRegistry,\r\n        uint256 _metaverseAssetId,\r\n        uint256 _minPeriod,\r\n        uint256 _maxPeriod,\r\n        uint256 _maxFutureTime,\r\n        address _paymentToken,\r\n        uint256 _pricePerSecond\r\n    ) external returns (uint256);\r\n\r\n    function changeConsumer(address _consumer, uint256 _tokenId) external;\r\n\r\n    function delist(uint256 _assetId) external;\r\n\r\n    function withdraw(uint256 _assetId) external;\r\n\r\n    function rentAt(uint256 _assetId, uint256 _rentId) external view returns (LibLandworks.Rent memory);\r\n\r\n    function assetAt(uint256 _assetId) external view returns (LibLandworks.Asset memory);\r\n\r\n    // ERC721 functions\r\n    function ownerOf(uint256 tokenId) external view returns (address);\r\n\r\n    function balanceOf(address owner) external view returns (uint256);\r\n\r\n    // FeeFacet functions\r\n    function assetRentFeesFor(uint256 _assetId, address _token) external view returns (uint256);\r\n\r\n    function claimRentFee(uint256 _assetId) external;\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC721/IERC721Receiver.sol@v4.1.0\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n * from ERC721 asset contracts.\r\n */\r\ninterface IERC721Receiver {\r\n    /**\r\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\r\n     * by `operator` from `from`, this function is called.\r\n     *\r\n     * It must return its Solidity selector to confirm the token transfer.\r\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\r\n     *\r\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\r\n     */\r\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol@v4.1.0\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n  /**\r\n   * @dev Implementation of the {IERC721Receiver} interface.\r\n   *\r\n   * Accepts all token transfers.\r\n   * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\r\n   */\r\ncontract ERC721Holder is IERC721Receiver {\r\n\r\n    /**\r\n     * @dev See {IERC721Receiver-onERC721Received}.\r\n     *\r\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\r\n     */\r\n    function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) {\r\n        return this.onERC721Received.selector;\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/security/ReentrancyGuard.sol@v4.1.0\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor () {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/rentAdapters/interfaces/IBaseRentAdapter.sol\r\n\r\npragma solidity 0.8.0;\r\ninterface IBaseRentAdapter {\r\n    function withdrawNFTFromRent(uint256 loanId) external;\r\n}\r\n\r\n\r\n// File contracts/rentAdapters/BaseRentAdapter.sol\r\n\r\npragma solidity 0.8.0;\r\ncontract BaseRentAdapter is ERC721Holder, ReentrancyGuard {\r\n    using Address for address;\r\n\r\n    address public immutable TRIBE_ONE_ADDRESS;\r\n\r\n    address public devWallet;\r\n\r\n    constructor(address _TRIBE_ONE_ADDRESS, address _devWallet) {\r\n        require(_TRIBE_ONE_ADDRESS.isContract(), \"BRA: Only contract address is available\");\r\n        TRIBE_ONE_ADDRESS = _TRIBE_ONE_ADDRESS;\r\n        devWallet = _devWallet;\r\n    }\r\n\r\n    modifier onlyTribeOne() {\r\n        require(msg.sender == TRIBE_ONE_ADDRESS, \"BRA: Only TribeOne is allowed\");\r\n        _;\r\n    }\r\n\r\n    function setDevWallet(address _devWallet) external {\r\n        require(msg.sender == _devWallet, \"Only dev can change dev wallet\");\r\n        devWallet = _devWallet;\r\n    }\r\n\r\n    // function listNFTForRent(uint256 loandId) external virtual {}\r\n\r\n    // function withdrawNFTFromRent(uint256 loanId) external virtual override {}\r\n\r\n    // function claimRentFee(uint256 loanId) external virtual {}\r\n\r\n    // function adjustRentFee(uint256 loanId) external virtual {}\r\n}\r\n\r\n\r\n// File contracts/libraries/DataTypes.sol\r\n\r\npragma solidity 0.8.0;\r\n\r\nlibrary DataTypes {\r\n    enum Status {\r\n        AVOID_ZERO, // just for avoid zero\r\n        LISTED, // after the loan has been created --> the next status will be APPROVED\r\n        APPROVED, // in this status the loan has a lender -- will be set after approveLoan(). loan fund => borrower\r\n        LOANACTIVED, // NFT was brought from opensea by agent and staked in TribeOne - relayNFT()\r\n        LOANPAID, // loan was paid fully but still in TribeOne\r\n        WITHDRAWN, // the final status, the collateral returned to the borrower or to the lender withdrawNFT()\r\n        FAILED, // NFT buying order was failed in partner's platform such as opensea...\r\n        CANCELLED, // only if loan is LISTED - cancelLoan()\r\n        DEFAULTED, // Grace period = 15 days were passed from the last payment schedule\r\n        LIQUIDATION, // NFT was put in marketplace\r\n        POSTLIQUIDATION, /// NFT was sold\r\n        RESTWITHDRAWN, // user get back the rest of money from the money which NFT set is sold in marketplace\r\n        RESTLOCKED, // Rest amount was forcely locked because he did not request to get back with in 2 weeks (GRACE PERIODS)\r\n        REJECTED // Loan should be rejected when requested loan amount is less than fund amount because of some issues such as big fluctuation in marketplace\r\n    }\r\n\r\n    struct Asset {\r\n        uint256 amount;\r\n        address currency; // address(0) is ETH native coin\r\n    }\r\n\r\n    struct LoanRules {\r\n        uint16 tenor;\r\n        uint16 LTV; // 10000 - 100%\r\n        uint16 interest; // 10000 - 100%\r\n    }\r\n\r\n    struct NFTItem {\r\n        address nftAddress;\r\n        bool isERC721;\r\n        uint256 nftId;\r\n    }\r\n\r\n    struct Loan {\r\n        uint256 fundAmount; // the amount which user put in TribeOne to buy NFT\r\n        uint256 paidAmount; // the amount that has been paid back to the lender to date\r\n        uint256 loanStart; // the point when the loan is approved\r\n        uint256 postTime; // the time when NFT set was sold in marketplace and that money was put in TribeOne\r\n        uint256 restAmount; // rest amount after sending loan debt(+interest) and 5% penalty\r\n        address borrower; // the address who receives the loan\r\n        uint8 nrOfPenalty;\r\n        uint8 passedTenors; // the number of tenors which we can consider user passed - paid tenor\r\n        Asset loanAsset;\r\n        Asset collateralAsset;\r\n        Status status; // the loan status\r\n        LoanRules loanRules;\r\n        NFTItem nftItem;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/interfaces/ITribeOne.sol\r\n\r\npragma solidity 0.8.0;\r\ninterface ITribeOne {\r\n    event LoanCreated(uint256 indexed loanId, address indexed owner, address nftAddress, uint256 nftTokenId, bool isERC721);\r\n    event LoanApproved(uint256 indexed _loanId, address indexed _to, address _fundCurreny, uint256 _fundAmount);\r\n    event LoanCanceled(uint256 indexed _loanId, address _sender);\r\n    event NFTRelayed(uint256 indexed _loanId, address indexed _sender, bool _accepted);\r\n    event InstallmentPaid(uint256 indexed _loanId, address _sender, address _currency, uint256 _amount);\r\n    event NFTWithdrew(uint256 indexed _loanId, address _to);\r\n    event LoanDefaulted(uint256 indexed _loandId);\r\n    event LoanLiquidation(uint256 indexed _loanId, address _salesManager);\r\n    event LoanPostLiquidation(uint256 indexed _loanId, uint256 _soldAmount, uint256 _finalDebt);\r\n    event RestWithdrew(uint256 indexed _loanId, uint256 _amount);\r\n    event SettingsUpdate(address _feeTo, uint256 _lateFee, uint256 _penaltyFee, address _salesManager, address _assetManager);\r\n    event LoanRejected(uint256 indexed _loanId, address _agent);\r\n    event LoanRented(uint256 indexed _loanId, address indexed _adapter);\r\n    event LoanWithdrawFromRent(uint256 indexed _loanId, address _adapter);\r\n\r\n    function approveLoan(\r\n        uint256 _loanId,\r\n        uint256 _amount,\r\n        address _agent\r\n    ) external;\r\n\r\n    function relayNFT(\r\n        uint256 _loanId,\r\n        address _agent,\r\n        bool _accepted\r\n    ) external payable;\r\n\r\n    function payInstallment(uint256 _loanId, uint256 _amount) external payable;\r\n\r\n    function getLoans(uint256 _loanId) external view returns (DataTypes.Loan memory);\r\n\r\n    function getLoanNFTItem(uint256 _loanId) external view returns (DataTypes.NFTItem memory);\r\n\r\n    function getLoanAsset(uint256 _loanId) external view returns (uint256, address);\r\n\r\n    function getCollateralAsset(uint256 _loanId) external view returns (uint256, address);\r\n\r\n    function getLoanRent(uint256 _loanId) external view returns (address);\r\n\r\n    function totalDebt(uint256 _loanId) external view returns (uint256);\r\n\r\n    function currentDebt(uint256 _loanId) external view returns (uint256);\r\n\r\n    function listNFTForRent(uint256 loanId, address borrower) external;\r\n\r\n    function withdrawNFTFromRent(uint256 loanId) external;\r\n\r\n    function isAvailableRentalAction(uint256 loanId, address user) external view returns (bool);\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC1155/IERC1155.sol@v4.1.0\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\r\n *\r\n * _Available since v3.1._\r\n */\r\ninterface IERC1155 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\r\n     */\r\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\r\n\r\n    /**\r\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\r\n     * transfers.\r\n     */\r\n    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);\r\n\r\n    /**\r\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\r\n     * `approved`.\r\n     */\r\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\r\n     *\r\n     * If an {URI} event was emitted for `id`, the standard\r\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\r\n     * returned by {IERC1155MetadataURI-uri}.\r\n     */\r\n    event URI(string value, uint256 indexed id);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     */\r\n    function balanceOf(address account, uint256 id) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `accounts` and `ids` must have the same length.\r\n     */\r\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);\r\n\r\n    /**\r\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `operator` cannot be the caller.\r\n     */\r\n    function setApprovalForAll(address operator, bool approved) external;\r\n\r\n    /**\r\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\r\n     *\r\n     * See {setApprovalForAll}.\r\n     */\r\n    function isApprovedForAll(address account, address operator) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\r\n     *\r\n     * Emits a {TransferSingle} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\r\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\r\n     *\r\n     * Emits a {TransferBatch} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `ids` and `amounts` must have the same length.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;\r\n}\r\n\r\n\r\n// File contracts/libraries/TribeOneHelper.sol\r\n\r\n\r\npragma solidity 0.8.0;\r\nlibrary TribeOneHelper {\r\n    function safeApprove(\r\n        address token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TransferHelper::safeApprove: approve failed\");\r\n    }\r\n\r\n    function safeTransfer(\r\n        address token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TribeOneHelper::safeTransfer: transfer failed\");\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \"TribeOneHelper::transferFrom: transferFrom failed\");\r\n    }\r\n\r\n    function safeTransferETH(address to, uint256 value) internal {\r\n        (bool success, ) = to.call{value: value}(new bytes(0));\r\n        require(success, \"TribeOneHelper::safeTransferETH: ETH transfer failed\");\r\n    }\r\n\r\n    function safeTransferAsset(\r\n        address token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        if (token == address(0)) {\r\n            safeTransferETH(to, value);\r\n        } else {\r\n            safeTransfer(token, to, value);\r\n        }\r\n    }\r\n\r\n    function safeNFTApproveForAll(\r\n        address nft,\r\n        address operator,\r\n        bool approved\r\n    ) internal {\r\n        // bytes4(keccak256(bytes('setApprovalForAll(address,bool)')));\r\n        (bool success, ) = nft.call(abi.encodeWithSelector(0xa22cb465, operator, approved));\r\n        require(success, \"TribeOneHelper::safeNFTApproveForAll: Failed\");\r\n    }\r\n\r\n    function safeTransferNFT(\r\n        address _nft,\r\n        address _from,\r\n        address _to,\r\n        bool isERC721,\r\n        uint256 _tokenId\r\n    ) internal {\r\n        if (isERC721) {\r\n            IERC721(_nft).safeTransferFrom(_from, _to, _tokenId);\r\n        } else {\r\n            IERC1155(_nft).safeTransferFrom(_from, _to, _tokenId, 1, \"0x00\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev this function calculates expected price of NFT based on created LTV and fund amount,\r\n     * LTV: 10000 = 100%; _slippage: 10000 = 100%\r\n     */\r\n    function getExpectedPrice(\r\n        uint256 _fundAmount,\r\n        uint256 _percentage,\r\n        uint256 _slippage\r\n    ) internal pure returns (uint256) {\r\n        require(_percentage != 0, \"TribeOneHelper: percentage should not be 0\");\r\n        return (_fundAmount * (10000 + _slippage)) / _percentage;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/rentAdapters/LandworksAdapter.sol\r\n\r\npragma solidity 0.8.0;\r\ncontract LandworksAdapter is BaseRentAdapter {\r\n    using Address for address;\r\n    enum RentStatus {\r\n        NONE,\r\n        RENTAL,\r\n        DELISTED,\r\n        WITHDRAWN\r\n    }\r\n\r\n    address constant LANDWORKS_ETHEREUM_PAYMENT_TOKEN = address(1);\r\n    address constant TRIBEONE_ETHEREUM_PAYMENT_TOKEN = address(0);\r\n    address public immutable LAND_WORKS_ADDRESS;\r\n    // loanId => assetId\r\n    mapping(uint256 => uint256) public rentAssetIdMap;\r\n    mapping(uint256 => RentStatus) public rentStatusMap;\r\n\r\n    bytes4 public constant ERC721_Interface = bytes4(0x80ac58cd);\r\n\r\n    event LoanRented(uint256 indexed loanId, uint256 indexed assetId);\r\n    event RentDelisted(uint256 indexed loanId, uint256 indexed assetId);\r\n    event RentWithdraw(uint256 indexed loanId, uint256 indexed assetId);\r\n    event ClaimRentFee(uint256 indexed loanId, address token, uint256 amount);\r\n    event AdjustRentFee(uint256 indexed loanId, address token, uint256 totalRentFee, uint256 paidDebt);\r\n    event ForceWithdraw(uint256 indexed loanId, bool isWithdraw);\r\n\r\n    constructor(\r\n        address _LAND_WORKS_ADDRESS,\r\n        address _TRIBE_ONE_ADDRESS,\r\n        address __devWallet\r\n    ) BaseRentAdapter(_TRIBE_ONE_ADDRESS, __devWallet) {\r\n        LAND_WORKS_ADDRESS = _LAND_WORKS_ADDRESS;\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    function listNFTforRenting(\r\n        uint256 _metaverseId,\r\n        uint256 _minPeriod,\r\n        uint256 _maxPeriod,\r\n        uint256 _maxFutureTime,\r\n        address _paymentToken,\r\n        uint256 _pricePerSecond,\r\n        uint256 _loanId\r\n    ) external {\r\n        // Validate Listing\r\n        DataTypes.NFTItem memory nftItem = ITribeOne(TRIBE_ONE_ADDRESS).getLoanNFTItem(_loanId);\r\n\r\n        ITribeOne(TRIBE_ONE_ADDRESS).listNFTForRent(_loanId, msg.sender);\r\n\r\n        _requireERC721(nftItem.nftAddress);\r\n\r\n        IERC721(nftItem.nftAddress).approve(LAND_WORKS_ADDRESS, nftItem.nftId);\r\n\r\n        // call list function in Landworks smart contract\r\n        uint256 assetId = ILandworks(LAND_WORKS_ADDRESS).list(\r\n            _metaverseId,\r\n            nftItem.nftAddress, // _metaverseRegistry\r\n            nftItem.nftId, // _metaverseAssetId\r\n            _minPeriod,\r\n            _maxPeriod,\r\n            _maxFutureTime,\r\n            _paymentToken,\r\n            _pricePerSecond\r\n        );\r\n\r\n        rentAssetIdMap[_loanId] = assetId;\r\n        rentStatusMap[_loanId] = RentStatus.RENTAL;\r\n\r\n        emit LoanRented(_loanId, assetId);\r\n    }\r\n\r\n    function delistNFTFromRenting(uint256 _loanId) external nonReentrant {\r\n        _delistNFTFromRenting(_loanId, false);\r\n    }\r\n\r\n    function _delistNFTFromRenting(uint256 _loanId, bool isForce) private {\r\n        DataTypes.NFTItem memory nftItem = ITribeOne(TRIBE_ONE_ADDRESS).getLoanNFTItem(_loanId);\r\n\r\n        require(\r\n            ITribeOne(TRIBE_ONE_ADDRESS).isAvailableRentalAction(_loanId, msg.sender) || isForce,\r\n            \"Only loan borrower or T1 can delist.\"\r\n        );\r\n\r\n        uint256 assetId = rentAssetIdMap[_loanId];\r\n\r\n        address paymentToken = ILandworks(LAND_WORKS_ADDRESS).assetAt(assetId).paymentToken;\r\n        uint256 feeAmount = _getRentFeeAmount(assetId, paymentToken);\r\n\r\n        ILandworks(LAND_WORKS_ADDRESS).delist(assetId);\r\n        if (IERC721(nftItem.nftAddress).ownerOf(nftItem.nftId) == address(this)) {\r\n            // NFT was withdrawn\r\n            IERC721(nftItem.nftAddress).approve(TRIBE_ONE_ADDRESS, nftItem.nftId);\r\n            ITribeOne(TRIBE_ONE_ADDRESS).withdrawNFTFromRent(_loanId);\r\n            rentStatusMap[_loanId] = RentStatus.WITHDRAWN;\r\n\r\n            if (feeAmount > 0) {\r\n                isForce\r\n                    ? _safeTransferAsset(paymentToken, devWallet, feeAmount)\r\n                    : _safeTransferAsset(paymentToken, msg.sender, feeAmount);\r\n            }\r\n            emit RentWithdraw(_loanId, assetId);\r\n            if (!isForce) {\r\n                emit ClaimRentFee(_loanId, paymentToken, feeAmount);\r\n            }\r\n        } else {\r\n            // remain NFT in Landworks because someone is leasing it now\r\n            rentStatusMap[_loanId] = RentStatus.DELISTED;\r\n\r\n            emit RentDelisted(_loanId, assetId);\r\n        }\r\n    }\r\n\r\n    function withdrawNFTFromRenting(uint256 _loanId) external nonReentrant {\r\n        _withdraw(_loanId, false);\r\n    }\r\n\r\n    function _withdraw(uint256 _loanId, bool isForce) private {\r\n        require(rentStatusMap[_loanId] == RentStatus.DELISTED, \"LandworksAdapter: NFT shoud be delisted first\");\r\n        // DataTypes.Loan memory _loan = ITribeOne(TRIBE_ONE_ADDRESS).getLoans(_loanId);\r\n        DataTypes.NFTItem memory nftItem = ITribeOne(TRIBE_ONE_ADDRESS).getLoanNFTItem(_loanId);\r\n\r\n        require(\r\n            ITribeOne(TRIBE_ONE_ADDRESS).isAvailableRentalAction(_loanId, msg.sender) || isForce,\r\n            \"Only loan borrower or T1 can withdraw\"\r\n        );\r\n\r\n        uint256 assetId = rentAssetIdMap[_loanId];\r\n\r\n        address paymentToken = ILandworks(LAND_WORKS_ADDRESS).assetAt(assetId).paymentToken;\r\n        uint256 feeAmount = _getRentFeeAmount(assetId, paymentToken);\r\n\r\n        ILandworks(LAND_WORKS_ADDRESS).withdraw(assetId);\r\n\r\n        require(IERC721(nftItem.nftAddress).ownerOf(nftItem.nftId) == address(this), \"LandworksAdapter: Withdraw was failed\");\r\n\r\n        if (feeAmount > 0) {\r\n            isForce\r\n                ? _safeTransferAsset(paymentToken, devWallet, feeAmount)\r\n                : _safeTransferAsset(paymentToken, msg.sender, feeAmount);\r\n        }\r\n        IERC721(nftItem.nftAddress).approve(TRIBE_ONE_ADDRESS, nftItem.nftId);\r\n\r\n        ITribeOne(TRIBE_ONE_ADDRESS).withdrawNFTFromRent(_loanId);\r\n\r\n        rentStatusMap[_loanId] = RentStatus.WITHDRAWN;\r\n\r\n        emit RentWithdraw(_loanId, assetId);\r\n        if (!isForce) {\r\n            emit ClaimRentFee(_loanId, paymentToken, feeAmount);\r\n        }\r\n    }\r\n\r\n    function forceWithdrawNFTFromRent(uint256 loanId) external onlyTribeOne {\r\n        if (rentStatusMap[loanId] == RentStatus.RENTAL) {\r\n            _delistNFTFromRenting(loanId, true);\r\n            emit ForceWithdraw(loanId, false);\r\n        } else if (rentStatusMap[loanId] == RentStatus.DELISTED) {\r\n            _withdraw(loanId, true);\r\n            emit ForceWithdraw(loanId, true);\r\n        }\r\n    }\r\n\r\n    function claimRentFee(uint256 loanId) external nonReentrant {\r\n        require(\r\n            ITribeOne(TRIBE_ONE_ADDRESS).isAvailableRentalAction(loanId, msg.sender),\r\n            \"Only loan borrower or T1 can withdraw\"\r\n        );\r\n\r\n        uint256 assetId = rentAssetIdMap[loanId];\r\n\r\n        address paymentToken = ILandworks(LAND_WORKS_ADDRESS).assetAt(assetId).paymentToken;\r\n\r\n        uint256 feeAmount = _getRentFeeAmount(assetId, paymentToken);\r\n\r\n        if (feeAmount > 0) {\r\n            _claimFeeFromRental(assetId);\r\n\r\n            _safeTransferAsset(paymentToken, msg.sender, feeAmount);\r\n\r\n            emit ClaimRentFee(loanId, paymentToken, feeAmount);\r\n        }\r\n    }\r\n\r\n    function adjustRentFee(uint256 loanId) external nonReentrant {\r\n        // DataTypes.Loan memory _loan = ITribeOne(TRIBE_ONE_ADDRESS).getLoans(loanId);\r\n        require(ITribeOne(TRIBE_ONE_ADDRESS).isAvailableRentalAction(loanId, msg.sender), \"Only loan borrower can withdraw\");\r\n\r\n        uint256 assetId = rentAssetIdMap[loanId];\r\n        address paymentToken = ILandworks(LAND_WORKS_ADDRESS).assetAt(assetId).paymentToken;\r\n\r\n        (, address loanCurrency) = ITribeOne(TRIBE_ONE_ADDRESS).getLoanAsset(loanId);\r\n\r\n        require(\r\n            (paymentToken == LANDWORKS_ETHEREUM_PAYMENT_TOKEN && loanCurrency == TRIBEONE_ETHEREUM_PAYMENT_TOKEN) ||\r\n                paymentToken == loanCurrency,\r\n            \"Rent payment token is not same as loan asset\"\r\n        );\r\n\r\n        uint256 feeAmount = _getRentFeeAmount(assetId, paymentToken);\r\n\r\n        if (feeAmount > 0) {\r\n            _claimFeeFromRental(assetId);\r\n\r\n            uint256 debtAmount = ITribeOne(TRIBE_ONE_ADDRESS).currentDebt(loanId);\r\n\r\n            if (feeAmount > debtAmount) {\r\n                TribeOneHelper.safeTransferAsset(loanCurrency, msg.sender, feeAmount - debtAmount);\r\n            } else {\r\n                debtAmount = feeAmount;\r\n            }\r\n\r\n            if (paymentToken == LANDWORKS_ETHEREUM_PAYMENT_TOKEN) {\r\n                ITribeOne(TRIBE_ONE_ADDRESS).payInstallment{value: debtAmount}(loanId, debtAmount);\r\n            } else {\r\n                TribeOneHelper.safeApprove(paymentToken, TRIBE_ONE_ADDRESS, debtAmount);\r\n                ITribeOne(TRIBE_ONE_ADDRESS).payInstallment(loanId, debtAmount);\r\n            }\r\n\r\n            emit AdjustRentFee(loanId, paymentToken, feeAmount, debtAmount);\r\n        }\r\n    }\r\n\r\n    function _claimFeeFromRental(uint256 assetId) private {\r\n        ILandworks(LAND_WORKS_ADDRESS).claimRentFee(assetId);\r\n    }\r\n\r\n    function getRentFeeAmount(uint256 loanId) external view returns (uint256) {\r\n        uint256 assetId = rentAssetIdMap[loanId];\r\n        address paymentToken = ILandworks(LAND_WORKS_ADDRESS).assetAt(assetId).paymentToken;\r\n\r\n        return _getRentFeeAmount(assetId, paymentToken);\r\n    }\r\n\r\n    function _getRentFeeAmount(uint256 assetId, address paymentToken) private view returns (uint256) {\r\n        return ILandworks(LAND_WORKS_ADDRESS).assetRentFeesFor(assetId, paymentToken);\r\n    }\r\n\r\n    function _safeTransferAsset(\r\n        address token,\r\n        address to,\r\n        uint256 amount\r\n    ) private {\r\n        if (token == LANDWORKS_ETHEREUM_PAYMENT_TOKEN) {\r\n            TribeOneHelper.safeTransferETH(to, amount);\r\n        } else {\r\n            TribeOneHelper.safeTransfer(token, to, amount);\r\n        }\r\n    }\r\n\r\n    function _requireERC721(address nftAddress) internal view {\r\n        require(nftAddress.isContract(), \"The NFT Address should be a contract\");\r\n\r\n        // ERC721Interface nftRegistry = ERC721Interface(nftAddress);\r\n        require(IERC165(nftAddress).supportsInterface(ERC721_Interface), \"The NFT contract has an invalid ERC721 implementation\");\r\n    }\r\n}\r\n"
    }
  }
}}