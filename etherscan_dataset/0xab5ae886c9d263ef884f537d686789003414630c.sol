{"Context.sol":{"content":"// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.13;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\ncontract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n"},"IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.13;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n  \r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller\u0027s account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n    \r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are befor moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event beforeTransfer(string remark, address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when when `value` tokens are afther moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event afterTransfer(string remark, address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n\r\n}\r\n"},"Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.13;\r\n\r\nimport \"./Context.sol\";\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n    address private _firstOwner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n        _firstOwner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(_firstOwner);\r\n        //_transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n"},"SALES.sol":{"content":"//SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.13;\r\n\r\nimport \"./Ownable.sol\";\r\nimport \"./IERC20.sol\";\r\n\r\ncontract SALES is Ownable\r\n{\r\n    IERC20 public token;\r\n    address public OwnerTokenAddress;\r\n    //uint256 public rate;\r\n    uint256 public usdPerEth;\r\n    uint private phaseIndex;\r\n    //string phaseOfsales=\"ICO\";\r\n    address _owner;\r\n    event Bought(string phase, uint256 amount);\r\n    event Sold(string phase, uint256 amount);\r\n    event OwnerWithdraw(string phase,uint256 amount);\r\n    event bytesLog(bool sent,bytes data);\r\n\r\n    /*\r\n            PhaseIndex: \r\n            999 = Free\r\n            1 = Airdrop\r\n            2 = Seed\r\n            3 = Private\r\n            4 = ICO\r\n            5 = CEX\r\n            6 = DEX\r\n            8 = Pool liquidity\r\n            9 = Founder\r\n    */\r\n    \r\n    /*\r\n      send ether and get tokens in exchange; 1 token == 1 ether\r\n\r\n        ETH Per WEI         \t\t= 1000000000000000000 WEI\r\n\r\n        Total Supply\t\t\t    = 100,000,000,000,000.000000000000000000 SANDO\r\n\r\n        Token Airdrop       25%     =  25,000,000,000,000.000000000000000000 SANDO\r\n        Token SEED   \t     5%     =   5,000,000,000,000.000000000000000000 SANDO\r\n        Token Private \t    20%     =  20,000,000,000,000.000000000000000000 SANDO\r\n        Token ICO            5%     =   5,000,000,000,000.000000000000000000 SANDO\r\n        Token Presales (CEX) 5%     =   5,000,000,000,000.000000000000000000 SANDO\r\n        Token Public (DEX)   5%\t    =   5,000,000,000,000.000000000000000000 SANDO\r\n        Token Marketing      5%     =   5,000,000,000,000.000000000000000000 SANDO\r\n        Token Pool liquidity 5%\t    =   5,000,000,000,000.000000000000000000 SANDO\r\n        Token Founder       15%\t    =  15,000,000,000,000.000000000000000000 SANDO\r\n        Token Reserve       10%\t    =  10,000,000,000,000.000000000000000000 SANDO\r\n\r\n        USD Values SEED     \t\t= 0.0009\r\n        USD Values Private  \t\t= 0.0012\r\n        USD Values ICO      \t\t= 0.0020\r\n        USD Values Public   \t\t= 0.0035\r\n\r\n        Example:\r\n        Token Values SEED    \t    = SEED *0.0009\r\n                            \t\t= 4,500,000,000 USD\r\n\r\n        USD Per ETH         \t\t= 3000 USD\r\n                            \t\t=  USD\r\n\r\n        MAX Values of SEED   \t    = 1,500,000 ETH\r\n                            \t\t= 1,500,000,000,000,000,000,000,000 WEI\r\n                            \t\t= 1500000000000000000000000 WEI\r\n        Price Rate  SEED       \t    = (Token SEED 5%)/(MAX Values of SEED)  TOKEN per WEI\r\n\t\t\t\t\t                = 3,333,333 * (10^18) WEI per Token\r\n                                    = 3333333\r\n        1 WEI per Token             = 0.00000000000333333333333333 WEI per Token\r\n\r\n    */\r\n\r\n    /*\r\n     rate = (Price of usdc per ETH) / \r\n     send ether and get tokens in exchange; 1 ether = 1 token * rate\r\n     */\r\n    //constructor\r\n    mapping (uint =\u003e string[]) private strphaseOfsales;\r\n    string[] private _strphaseOfsales =[\"Airdrop\",\"SEED\",\"Private Sales\",\"ICO\",\"CEX\",\"DEX\",\"Marketing\",\"Pool liquidity\",\"Founder\",\"Reserve\"];\r\n    bool private sellFucntion = false;\r\n\r\n    function initialSales (IERC20 _tokenAddress,uint256 _usdPerEthRate,uint256 _initTokenPerWEIRate) onlyOwner public \r\n    {\r\n        phaseIndex = 2;\r\n\r\n        require(_initTokenPerWEIRate \u003e 0,\"Rate not found..\");\r\n        token = _tokenAddress; //new SANDOToken(\"SANDO\",\"SANDO\");\r\n        rate[phaseIndex] = _initTokenPerWEIRate; //1200000000000000; //0.0012;\r\n        usdPerEth = _usdPerEthRate;\r\n        _owner=msg.sender;\r\n        OwnerTokenAddress = address(_tokenAddress);\r\n        \r\n    }\r\n\r\n    function getPhaseSeles() public view returns(string[] memory){\r\n        return _strphaseOfsales;\r\n    }\r\n\r\n    function getOwnerToken() public returns(address){\r\n        bytes memory payload = abi.encodeWithSignature(\"_owner()\",\"\");  \r\n        bool success;\r\n        bytes memory result;\r\n        (success, result)= address(this).call(payload);\r\n\r\n        // Decode data\r\n        address _ownerToken = abi.decode(result, (address));\r\n        return _ownerToken;\r\n    }\r\n\r\n    /*\r\n        Protect Reentrancy Attacks check and clear value of request\r\n        use modifier noReentrant()\r\n        before transfer values to msg.sender keep values to temporary variable \r\n        immediately is done and set values = 0 \r\n\r\n    */\r\n    bool internal locked;\r\n\r\n    modifier noReentrant() {\r\n        require(!locked,\"The list is not complete. please wait a moment.\");\r\n        locked = true; //before use function, set status locked is true.\r\n        _;\r\n        locked = false; //after use function is finish, set status locked is false.\r\n\r\n    }\r\n\r\n    function setState(uint _state) public onlyOwner {\r\n        require(_state\u003e=0,\"State not found.\");\r\n        phaseIndex = _state;\r\n    }\r\n\r\n    function setstrphaseOfsales(uint _state,string memory _stateName,uint256 _initTokenPerWEIRate) public onlyOwner {\r\n        strphaseOfsales[_state].push(_stateName);\r\n        rate[_state] = _initTokenPerWEIRate;\r\n    }\r\n\r\n    function setUsdPerEthRate(uint _usdPerEthRate) external onlyOwner {\r\n        require(_usdPerEthRate\u003e0,\"Rate not found..\");\r\n        usdPerEth = _usdPerEthRate;\r\n    }\r\n\r\n    mapping (uint =\u003e uint256) rate;\r\n\r\n    function setTokenPerWeiRate(uint _state, uint _TokenPerWeiRate) external onlyOwner {\r\n        require(_TokenPerWeiRate\u003e0,\"Rate not found..\");\r\n        require(_state\u003e=0,\"State is not found..\");\r\n        rate[_state] = _TokenPerWeiRate;\r\n    }\r\n\r\n    function getSenderAddress() public view returns (address) // for debugging purposes\r\n    {\r\n        return (msg.sender);\r\n    }\r\n\r\n    function getAddress() public view returns (address)\r\n    {\r\n        return address(this);\r\n    }\r\n\r\n    function getTokenAddress() public view returns (address)\r\n    {\r\n        return address(token);\r\n    }\r\n\r\n \r\n    modifier _checkPhase(){\r\n        if((phaseIndex==2)||(phaseIndex==3)||(phaseIndex==4)||(phaseIndex==9)){sellFucntion=false;}\r\n        if((phaseIndex==5)||(phaseIndex==6)){sellFucntion=true;}\r\n        _;\r\n    } \r\n\r\n\r\n    function buy() payable _checkPhase public \r\n    {\r\n      require(sellFucntion==false,\"This state is not enabled buy function.\");\r\n      uint256 amountTobuy = msg.value*rate[phaseIndex];\r\n      uint256 salesBalance =  token.balanceOf(address(this)); //token.balanceOf(SalesWallet);\r\n      require(amountTobuy \u003e 0, \"You need to send some ether\");\r\n      require(amountTobuy \u003c= salesBalance, \"Not enough tokens in the reserve\");\r\n      token.transfer(msg.sender, amountTobuy);\r\n      emit Bought(_strphaseOfsales[phaseIndex], amountTobuy);\r\n    }\r\n\r\n\r\n    function sell(uint256 amount) payable _checkPhase public // send tokens to get ether back\r\n    {\r\n      require(sellFucntion==true,\"This state is not enabled buy function.\");  \r\n      require(amount \u003e 0, \"You need to sell at least some tokens\");\r\n      uint256 allowance = token.allowance(msg.sender, address(this));\r\n      require(allowance \u003e= amount, \"Check the token allowance\");\r\n      token.transferFrom(msg.sender, address(this), amount);\r\n      payable(msg.sender).transfer(amount*rate[phaseIndex]);\r\n      emit Sold(_strphaseOfsales[phaseIndex], amount*rate[phaseIndex]);\r\n    }\r\n\r\n    function getBalanceWEI() external view returns(uint256){\r\n        return address(this).balance;\r\n    }\r\n\r\n    function getValueOfSales() external view returns(uint256){\r\n        return token.balanceOf(address(this));\r\n    }\r\n\r\n    function OwnerWithdrawAll() public onlyOwner noReentrant{\r\n      payable(msg.sender).transfer(address(this).balance);\r\n      emit OwnerWithdraw(_strphaseOfsales[phaseIndex], address(this).balance);\r\n    }\r\n\r\n    function returnTokentoOrigin(uint256 _amountToOrigin) public onlyOwner noReentrant{\r\n      uint256 salesBalance =  token.balanceOf(address(this)); \r\n      require(_amountToOrigin \u003e 0, \"You need to send some ether\");\r\n      require(_amountToOrigin \u003c= salesBalance, \"Not enough tokens in the reserve\");\r\n      require(OwnerTokenAddress != address(0x0),\"Address is not zero\");\r\n      token.transfer(OwnerTokenAddress, _amountToOrigin);\r\n      emit OwnerWithdraw(_strphaseOfsales[phaseIndex],  _amountToOrigin);\r\n\r\n    }\r\n\r\n    function returnTokentoOriginAll() public onlyOwner noReentrant{\r\n      uint256 salesBalance =  token.balanceOf(address(this)); \r\n      require(salesBalance \u003e 0, \"You need to send some ether\");\r\n      require(OwnerTokenAddress != address(0x0),\"Address is not zero\");\r\n      token.transfer(OwnerTokenAddress, salesBalance);\r\n      emit OwnerWithdraw(_strphaseOfsales[phaseIndex],  salesBalance);\r\n\r\n    }\r\n\r\n    fallback() external payable {\r\n    }\r\n\r\n    receive() external payable {\r\n    }\r\n\r\n}\r\n"}}