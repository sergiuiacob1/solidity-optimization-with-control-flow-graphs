{{
  "language": "Solidity",
  "sources": {
    "contracts/Grill.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\n\n/**\n * Interfaces SuperFarm's Super1155 contract\n * See example contracts: https://etherscan.io/address/0x71B11Ac923C967CD5998F23F6dae0d779A6ac8Af#code,\n * https://etherscan.io/address/0xc7b9D8483FD01C379a4141B2Ee7c39442172b259#code\n *\n * @notice To stake tokens an account must setApprovalForAll() using the address of this contract in the above contracts\n */\ninterface Super1155 {\n  function safeBatchTransferFrom(\n    address _from,\n    address _to,\n    uint256[] memory _ids,\n    uint256[] memory _amounts,\n    bytes memory _data\n  ) external;\n\n  function safeTransferFrom(\n    address _from,\n    address _to,\n    uint256 _id,\n    uint256 _amount,\n    bytes calldata _data\n  ) external;\n\n  function balanceOf(address _owner, uint256 _id)\n    external\n    view\n    returns (uint256);\n\n  function isApprovedForAll(address _owner, address _operator)\n    external\n    view\n    returns (bool);\n}\n\n/**\n * @title A staking contract for Super1155 tokens.\n * @author DegenDeveloper.eth\n *\n * April 25, 2022\n *\n * This contract allows users to stake their tokens to earn emission tokens.\n *\n * This contract is only capable of transferring tokens to their original stakers.\n *\n * Accounts always have the ability to unstake their tokens no matter the contract state.\n *\n * The contract owner has the following permissions:\n *\n * - Open/close staking; enabling/disabling the addition of new stakes\n * - Blacklist an account; disabling the addition of new stakes for a specific address\n * - Pause emissions; stops the counting of emission tokens\n * - Set new emission rates; sets a new rate for earning emission tokens\n *    - if emissions are paused this unpauses them\n *    - historic emission rates (emRates) are stored in the contract to accurately calculate emissions\n *\n * --------( In case of security breach )---------\n *\n * Accounts will always have the ability to unstake their tokens, no matter the state of the contract; however,\n *\n * If there is a security breach or the team wishes to terminate the grill, they have the ability to permanently close staking,\n * sending back all tokens to their original stakers.\n *\n * The contract owner must call toggleBailout() before they force unstake any tokens.\n *\n * ToggleBailout() is only callable once\n *\n * Once toggleBailout() has been called, bailoutAllStakes() becomes callable. This function will unstake all tokens and send them back to their original stakers.\n * If there are gas limits sending back all tokens in a single transaction, the function bailoutSingleStake(_tokenId) also becomes callable,\n * allowing each tokenId to be unstaked manually\n */\ncontract Grill is Ownable, ERC1155Holder {\n  /// used for variables that start at 0 and only increment/decrement by 1 at a time\n  using Counters for Counters.Counter;\n\n  /// the contract instance for the tokens being staked\n  Super1155 private immutable Parent;\n\n  bool private STAKING_ACTIVE;\n  bool private BAILED_OUT;\n\n  /// the max number of tokens to stake/unstake in a single txn\n  uint256 private constant MAX_TXN = 20;\n\n  /// the max number of seconds possible, used for pausing emissions\n  uint256 private constant MAX_INT = 2**256 - 1;\n\n  /// a mapping from each tokenId to its stake details\n  mapping(uint256 => Stake) private stakes;\n\n  /// a mapping from each address to an indexed mapping of the tokenIds they have staked\n  mapping(address => mapping(uint256 => uint256)) private addrStakesIds;\n\n  /// a mapping from each address to a counter for tokens currently staked\n  mapping(address => Counters.Counter) private addrStakesCount;\n\n  /// a mapping from each address to their ability to add new stakes\n  mapping(address => bool) private blacklist;\n\n  /// a counter for the number of times the emission rate changes\n  Counters.Counter private emChanges;\n\n  /// a mapping from each emChange to its associated emission details\n  mapping(uint256 => Emission) private emissions;\n\n  /// a mapping from each address to their emission claims earned from their removed stakes\n  mapping(address => uint256) private unstakedClaims;\n\n  /// a counter for the number of active stakes\n  Counters.Counter private allStakesCount;\n\n  /// an indexed mapping for all tokenIds staked currently\n  mapping(uint256 => uint256) private allStakes;\n\n  /**\n   * This struct stores information about staked tokens. They are stored\n   * in the `stakes` mapping by tokenId\n   * @param status If tokenId is staked or not\n   * @param staker The staker of tokenId\n   * @param timestamp The time tokenId was staked\n   */\n  struct Stake {\n    bool status;\n    address staker;\n    uint256 timestamp;\n  }\n\n  /**\n   * This struct stores information about emissions. They are stored in\n   * the 'emissions' mapping by emChange\n   * @param rate The number of seconds to earn 1 token\n   * @param timestamp The time the emission rate was set\n   */\n  struct Emission {\n    uint256 rate;\n    uint256 timestamp;\n  }\n\n  /// ============ CONSTRUCTOR ============ ///\n\n  /**\n   * Initializes the parent contract instance, the initial emission rate, and timestamps the deploy\n   * @param _parentAddr The contract address to allow staking from\n   */\n  constructor(address _parentAddr) {\n    Parent = Super1155(_parentAddr);\n    STAKING_ACTIVE = true;\n    BAILED_OUT = false;\n    uint256 secondsIn45Days = 3600 * 24 * 45;\n    emissions[emChanges.current()] = Emission(secondsIn45Days, block.timestamp);\n  }\n\n  /// ============ OWNER FUNCTIONS ============ ///\n\n  /**\n   * For allowing/unallowing the addition of new stakes\n   * @notice This function is disabled once toggleBailout() is called\n   */\n  function toggleStaking() external onlyOwner {\n    require(!BAILED_OUT, \"GRILL: contract has been terminated\");\n    STAKING_ACTIVE = !STAKING_ACTIVE;\n  }\n\n  /**\n   * For allowing/unallowing an address to add new stakes\n   * @notice A staker is always able to remove their stakes regardless of contract state\n   * @param _addr The address to set blacklist status for\n   * @param _status The status to set for _addr\n   */\n  function blacklistAddr(address _addr, bool _status) external onlyOwner {\n    blacklist[_addr] = _status;\n  }\n\n  /**\n   * Stops the counting of emission tokens\n   * @notice No tokens can be earned with an emission rate this long\n   * @notice To continue emissions counting, the owner must set a new emission rate\n   */\n  function pauseEmissions() external onlyOwner {\n    _setEmissionRate(MAX_INT);\n  }\n\n  /**\n   * Sets new emission rate\n   * @param _seconds The number of seconds a token must be staked for to earn 1 emission token\n   */\n  function setEmissionRate(uint256 _seconds) external onlyOwner {\n    require(!BAILED_OUT, \"GRILL: cannot change emission rate after bailout\");\n    _setEmissionRate(_seconds);\n  }\n\n  /**\n   * Pauses staking/emissions counting permanently\n   * @notice This function is only callable once and all state changes are final\n   * @notice It must be called before bailoutAllStakes() or bailoutSingleStake()\n   */\n  function toggleBailout() external onlyOwner {\n    require(!BAILED_OUT, \"GRILL: bailout already called\");\n    STAKING_ACTIVE = false;\n    BAILED_OUT = true;\n    _setEmissionRate(MAX_INT);\n  }\n\n  /**\n   * Sends back all tokens to their original stakers\n   * @notice toggleBailout() must be called\n   */\n  function bailoutAllStakes() external onlyOwner {\n    require(BAILED_OUT, \"GRILL: toggleBailout() must be called first\");\n\n    /// @dev copies current number of stakes before bailout ///\n    uint256 _totalCount = allStakesCount.current();\n    for (uint256 i = 1; i <= _totalCount; ++i) {\n      /// @dev gets token and staker for last token staked ///\n      uint256 _lastTokenId = allStakes[allStakesCount.current()];\n      address _staker = stakes[_lastTokenId].staker;\n\n      /// @dev transferrs _lastTokenId from the contract to associated _staker ///\n      Parent.safeTransferFrom(address(this), _staker, _lastTokenId, 1, \"0x0\");\n\n      /// @dev sets state changes ///\n      uint256[] memory _singleArray = _makeOnesArray(1);\n      _singleArray[0] = _lastTokenId; // _removeStakes() requires an array of tokenIds\n      _removeStakes(_staker, _singleArray);\n    }\n  }\n\n  /**\n   * Sends back _tokenId to its original staker\n   * @notice toggleBailout() must be called\n   * @notice This function is here in case bailoutAllStakes() has gas limitations\n   */\n  function bailoutSingleStake(uint256 _tokenId) external onlyOwner {\n    require(BAILED_OUT, \"GRILL: toggleBailout() must be called first\");\n\n    Parent.safeTransferFrom(\n      address(this),\n      stakes[_tokenId].staker,\n      _tokenId,\n      1,\n      \"0x0\"\n    );\n\n    /// @dev sets state changes ///\n    uint256[] memory _singleArray = _makeOnesArray(1);\n    _singleArray[0] = _tokenId;\n    _removeStakes(stakes[_tokenId].staker, _singleArray);\n  }\n\n  /// ============ PUBLIC FUNCTIONS ============ ///\n\n  /**\n   * Transfer tokens from caller to contract and begins emissions counting\n   * @param _tokenIds The tokenIds to stake\n   * @param _amounts The amount of each tokenId to stake\n   * @notice _amounts must have a value of 1 at each index\n   */\n  function addStakes(uint256[] memory _tokenIds, uint256[] memory _amounts)\n    external\n  {\n    require(STAKING_ACTIVE, \"GRILL: staking is not active\");\n    require(!blacklist[msg.sender], \"GRILL: caller is blacklisted\");\n    require(_tokenIds.length > 0, \"GRILL: must stake more than 0 tokens\");\n    require(\n      _tokenIds.length <= MAX_TXN,\n      \"GRILL: must stake less than MAX_TXN tokens per txn\"\n    );\n    require(\n      _isOwnerOfBatch(msg.sender, _tokenIds, _amounts),\n      \"GRILL: caller does not own these tokens\"\n    );\n    require(\n      Parent.isApprovedForAll(msg.sender, address(this)),\n      \"GRILL: contract is not an approved operator for caller's tokens\"\n    );\n\n    /// @dev transfers token batch from caller to contract\n    Parent.safeBatchTransferFrom(\n      msg.sender,\n      address(this),\n      _tokenIds,\n      _amounts,\n      \"0x0\"\n    );\n\n    /// @dev sets contract state\n    _addStakes(msg.sender, _tokenIds);\n  }\n\n  /**\n   * Transfer tokens from contract to caller and records emissions in unStakedClaims\n   * @param _tokenIds The tokenIds to unstake\n   * @param _amounts The amount of each tokenId to unstake\n   * @notice _amounts must have a value of 1 at each index\n   */\n  function removeStakes(uint256[] memory _tokenIds, uint256[] memory _amounts)\n    external\n  {\n    require(_tokenIds.length > 0, \"GRILL: must unstake more than 0 tokens\");\n    require(\n      _tokenIds.length <= MAX_TXN,\n      \"GRILL: cannot stake more than MAX_TXN tokens in a single txn\"\n    );\n    require(_tokenIds.length == _amounts.length, \"GRILL: arrays mismatch\");\n    require(\n      _isStakerOfBatch(msg.sender, _tokenIds, _amounts),\n      \"GRILL: caller was not the staker of these tokens\"\n    );\n    require(\n      _tokenIds.length <= addrStakesCount[msg.sender].current(),\n      \"GRILL: caller is unstaking too many tokens\"\n    );\n\n    /// @dev transfers token batch from contract to caller ///\n    Parent.safeBatchTransferFrom(\n      address(this),\n      msg.sender,\n      _tokenIds,\n      _amounts,\n      \"0x0\"\n    );\n\n    /// @dev sets contract state ///\n    _removeStakes(msg.sender, _tokenIds);\n  }\n\n  /// ============ PRIVATE/HELPER FUNCTIONS ============ ///\n\n  /**\n   * Verifies if an address can stake a batch of tokens\n   * @param _operator The address trying to stake\n   * @param _tokenIds The tokenIds _operator is trying to stake\n   * @param _amounts The amount of each tokenId caller is trying to stake\n   * @notice Each element in _amounts must be 1\n   * @return _b If _operator can unstake _tokenIds\n   */\n  function _isOwnerOfBatch(\n    address _operator,\n    uint256[] memory _tokenIds,\n    uint256[] memory _amounts\n  ) private view returns (bool _b) {\n    _b = true;\n    for (uint256 i = 0; i < _tokenIds.length; ++i) {\n      if (parentBalance(_operator, _tokenIds[i]) == 0 || _amounts[i] != 1) {\n        _b = false;\n        break;\n      }\n    }\n  }\n\n  /**\n   * Verifies if an address can unstake a batch of tokens\n   * @param _operator The address trying to unstake\n   * @param _tokenIds The tokenIds _operator is trying to unstake\n   * @param _amounts The amount of each tokenId caller is trying to unstake\n   * @notice Each element in _amounts must be 1\n   * @return _b If _operator can unstake _tokenIds\n   */\n  function _isStakerOfBatch(\n    address _operator,\n    uint256[] memory _tokenIds,\n    uint256[] memory _amounts\n  ) private view returns (bool _b) {\n    _b = true;\n    for (uint256 i = 0; i < _tokenIds.length; ++i) {\n      if (stakes[_tokenIds[i]].staker != _operator || _amounts[i] != 1) {\n        _b = false;\n        break;\n      }\n    }\n  }\n\n  /**\n   * Helper function for setting contract state when tokens are staked\n   * @param _staker The address staking tokens\n   * @param _tokenIds The tokenIds being staked\n   */\n  function _addStakes(address _staker, uint256[] memory _tokenIds) private {\n    for (uint256 i = 0; i < _tokenIds.length; ++i) {\n      require(!stakes[_tokenIds[i]].status, \"GRILL: token already staked\");\n\n      /// increment counters\n      addrStakesCount[_staker].increment();\n      allStakesCount.increment();\n\n      /// set mappings\n      addrStakesIds[_staker][addrStakesCount[_staker].current()] = _tokenIds[i];\n      allStakes[allStakesCount.current()] = _tokenIds[i];\n      stakes[_tokenIds[i]] = Stake(true, _staker, block.timestamp);\n    }\n  }\n\n  /**\n   * Helper function for setting contract state when tokens are unstaked\n   * @param _staker The address unstaking tokens\n   * @param _tokenIds The tokenIds being unstaked\n   */\n  function _removeStakes(address _staker, uint256[] memory _tokenIds) private {\n    for (uint256 i = 0; i < _tokenIds.length; ++i) {\n      require(\n        stakes[_tokenIds[i]].status,\n        \"GRILL: token is not currently staked\"\n      );\n\n      /// count rewards earned\n      uint256 _tokenId = _tokenIds[i];\n      unstakedClaims[_staker] += _countEmissions(_tokenId);\n\n      /// @dev resets Stake object in `stakes` mapping ///\n      delete stakes[_tokenId];\n\n      /// last index of mappings\n      uint256 _t = addrStakesCount[_staker].current();\n      uint256 _t1 = allStakesCount.current();\n\n      /// @dev finds _tokenId in mappings, swaps it with last index ///\n      for (uint256 j = 1; j < _t; ++j) {\n        if (addrStakesIds[_staker][j] == _tokenId) {\n          addrStakesIds[_staker][j] = addrStakesIds[_staker][_t];\n        }\n      }\n      for (uint256 k = 1; k < _t1; ++k) {\n        if (allStakes[k] == _tokenId) {\n          allStakes[k] = allStakes[_t1];\n        }\n      }\n\n      /// @dev resets last item in mappings\n      delete addrStakesIds[_staker][_t];\n      delete allStakes[_t1];\n\n      /// decrement counters, avoiding decrement overflow\n      if (_t != 0) {\n        addrStakesCount[_staker].decrement();\n      }\n      if (_t1 != 0) {\n        allStakesCount.decrement();\n      }\n    }\n  }\n\n  /**\n   * Helper function for setting contract state when emission changes occur\n   * @param _seconds The number of seconds a token must be staked for to earn 1 emission token\n   * @notice The emission rate cannot be 0 seconds\n   */\n  function _setEmissionRate(uint256 _seconds) private {\n    require(_seconds > 0, \"GRILL: emission rate cannot be 0\");\n    emChanges.increment();\n    emissions[emChanges.current()] = Emission(_seconds, block.timestamp);\n  }\n\n  /**\n   * Helper function to count number of emission tokens _tokenId has earned\n   * @param _tokenId The tokenId to check\n   * @notice A token must be staked to count emissions\n   */\n  function _countEmissions(uint256 _tokenId) private view returns (uint256 _c) {\n    require(stakes[_tokenId].status, \"GRILL: token is not currently staked\");\n\n    /// @dev finds the first emission rate _tokenId was staked for ///\n    uint256 minT;\n    uint256 timeStake = stakes[_tokenId].timestamp;\n    for (uint256 i = 1; i <= emChanges.current(); ++i) {\n      if (emissions[i].timestamp < timeStake) {\n        minT += 1;\n      }\n    }\n    /// @dev counts all emissions earned starting from minT -> now\n    for (uint256 i = minT; i <= emChanges.current(); ++i) {\n      uint256 tSmall = emissions[i].timestamp;\n      uint256 tBig = emissions[i + 1].timestamp;\n      if (i == minT) {\n        tSmall = timeStake;\n      }\n      if (i == emChanges.current()) {\n        tBig = block.timestamp;\n      }\n      _c += (tBig - tSmall) / emissions[i].rate;\n    }\n  }\n\n  /**\n   * Helper function for creating an array of all 1's\n   * @param _n The size of the array\n   * @return _ones An array of size _n with a value of 1 at each index\n   */\n  function _makeOnesArray(uint256 _n)\n    private\n    pure\n    returns (uint256[] memory _ones)\n  {\n    _ones = new uint256[](_n);\n    for (uint256 i = 0; i < _n; i++) {\n      _ones[i] = 1;\n    }\n    return _ones;\n  }\n\n  /// ============ READ-ONLY FUNCTIONS ============ ///\n\n  /**\n   * Get the balance for a specifc tokenId in parent contract\n   * @param _operator The address to lookup\n   * @param _tokenId The token id to check balance of\n   * @return _c The _tokenId balance of _operator\n   */\n  function parentBalance(address _operator, uint256 _tokenId)\n    public\n    view\n    returns (uint256 _c)\n  {\n    _c = Parent.balanceOf(_operator, _tokenId);\n  }\n\n  /**\n   * @return _b If the contract is allowing new stakes to be added\n   */\n  function isStakingActive() external view returns (bool _b) {\n    _b = STAKING_ACTIVE;\n  }\n\n  /**\n   * @return _b If the contract has been bailed out\n   */\n  function isBailedOut() external view returns (bool _b) {\n    _b = BAILED_OUT;\n  }\n\n  /**\n   * @param _addr The address to lookup\n   * @return _b Blacklist status\n   */\n  function isBlacklisted(address _addr) external view returns (bool _b) {\n    _b = blacklist[_addr];\n  }\n\n  /**\n   * @return _changes The current number of emission changes to date\n   */\n  function getEmissionChanges() external view returns (uint256 _changes) {\n    _changes = emChanges.current();\n  }\n\n  /**\n   * Get details for an emission change\n   * @param _change The change number to lookup\n   * @return _emission The emission object for emChange _change\n   * @notice A _change must have occured to view it\n   */\n  function getEmission(uint256 _change)\n    external\n    view\n    returns (Emission memory _emission)\n  {\n    require(_change <= emChanges.current(), \"GRILL: invalid index to lookup\");\n    _emission = emissions[_change];\n  }\n\n  /**\n   * @return _allStakingIds Array of tokenIds currently being staked\n   */\n  function getAllStakedIds()\n    external\n    view\n    returns (uint256[] memory _allStakingIds)\n  {\n    _allStakingIds = new uint256[](allStakesCount.current());\n    for (uint256 i = 0; i < _allStakingIds.length; ++i) {\n      _allStakingIds[i] = allStakes[i + 1];\n    }\n  }\n\n  /**\n   * Get details for a staked token\n   * @param _tokenId The tokenId to lookup\n   * @return _stake The stake of _tokenId\n   * @notice A _tokenId must currently be staked to view it\n   */\n  function getStake(uint256 _tokenId)\n    external\n    view\n    returns (Stake memory _stake)\n  {\n    require(stakes[_tokenId].status, \"GRILL: tokenId is not staked\");\n    _stake = stakes[_tokenId];\n  }\n\n  /**\n   * @param _operator The address to lookup\n   * @return _addrStakes Array of tokenIds currently staked by _operator\n   */\n  function getIdsOfAddr(address _operator)\n    external\n    view\n    returns (uint256[] memory _addrStakes)\n  {\n    _addrStakes = new uint256[](addrStakesCount[_operator].current());\n    for (uint256 i = 0; i < _addrStakes.length; ++i) {\n      _addrStakes[i] = addrStakesIds[_operator][i + 1];\n    }\n  }\n\n  /**\n   * @param _operator The address to lookup\n   * @return _claims The number of claims _operator has earned from their unstaked bulls\n   */\n  function getUnstakedClaims(address _operator) public view returns (uint256) {\n    return unstakedClaims[_operator];\n  }\n\n  /**\n   * @param _operator The address to lookup\n   * @return _total The number of claims an address has earned from their current stakes\n   */\n  function getStakedClaims(address _operator)\n    public\n    view\n    returns (uint256 _total)\n  {\n    for (uint256 i = 1; i <= addrStakesCount[_operator].current(); i++) {\n      _total += _countEmissions(addrStakesIds[_operator][i]);\n    }\n  }\n\n  /**\n   * @param _operator The address to lookup\n   * @return _total The number of emissions _operator has earned from all past and current stakes\n   */\n  function getTotalClaims(address _operator)\n    external\n    view\n    returns (uint256 _total)\n  {\n    _total = unstakedClaims[_operator];\n    _total += getStakedClaims(_operator);\n  }\n}\n"
    },
    "contracts/Burger.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\n\n/**\n * Interfaces Grill contracts\n */\ninterface GrillC {\n  function getTotalClaims(address _operator) external view returns (uint256);\n}\n\n/**\n * @title An erc-1155 nft contract.\n * @author DegenDeveloper.eth\n *\n * March 29th, 2022\n *\n * This contract allows addresses to mint tokens earned from AstroGrill\n * and/or RickstroGrill staking.\n *\n * The contract owner has the following permissions:\n * - toggle minting.\n * - toggle burning.\n * - update the URI for tokens.\n * - mint tokens for marketing/giveaways without restriction\n */\ncontract Burger is ERC1155, Ownable {\n  using Counters for Counters.Counter;\n\n  /// contract instances\n  GrillC public immutable AstroGrill;\n  GrillC public immutable RickstroGrill;\n\n  Counters.Counter private totalMinted;\n  Counters.Counter private totalBurned;\n\n  bool private CAN_MINT = false;\n  bool private CAN_BURN = false;\n\n  /// lookup identifiers\n  bytes32 constant MINTS = keccak256(\"CLAIMS\");\n  bytes32 constant BURNS = keccak256(\"BURNS\");\n\n  /// mapping for the number of mints/burns of each address\n  mapping(bytes32 => mapping(address => Counters.Counter)) private stats;\n\n  /**\n   * @param _aGrillAddr The address of the astro grill\n   * @param _rGrillAddr The address of the rickstro grill\n   */\n  constructor(address _aGrillAddr, address _rGrillAddr)\n    ERC1155(\"burger.io/{}.json\")\n  {\n    AstroGrill = GrillC(_aGrillAddr);\n    RickstroGrill = GrillC(_rGrillAddr);\n  }\n\n  /// ============ OWNER FUNCTIONS ============ ///\n\n  /**\n   * Sets the URI for the collection\n   * @param _URI The new URI\n   */\n  function setURI(string memory _URI) public onlyOwner {\n    _setURI(_URI);\n  }\n\n  function toggleMinting() external onlyOwner {\n    CAN_MINT = !CAN_MINT;\n  }\n\n  function toggleBurning() external onlyOwner {\n    CAN_BURN = !CAN_BURN;\n  }\n\n  /**\n   * Allows contract owner to mint tokens for giveaways/etc.\n   * @param _amount The number of tokens to mint\n   * @param _addr The address to mint the tokens to\n   */\n  function ownerMint(uint256 _amount, address _addr) external onlyOwner {\n    uint256[] memory _ids = new uint256[](_amount);\n    uint256[] memory _amounts = new uint256[](_amount);\n\n    for (uint256 i = 0; i < _amount; i++) {\n      totalMinted.increment();\n      _ids[i] = totalMinted.current();\n      _amounts[i] = 1;\n    }\n\n    _mintBatch(_addr, _ids, _amounts, \"0x0\");\n  }\n\n  /// ============ PUBLIC FUNCTIONS ============ ///\n\n  /**\n   * Mint tokens to caller\n   * @param _amount The number of tokens to mint\n   */\n  function mintPublic(uint256 _amount) external {\n    require(CAN_MINT, \"BURGER: minting is not active\");\n    require(_amount > 0, \"BURGER: must claim more than 0 tokens\");\n    require(\n      stats[MINTS][msg.sender].current() + _amount <=\n        AstroGrill.getTotalClaims(msg.sender) +\n          RickstroGrill.getTotalClaims(msg.sender),\n      \"BURGER: caller cannot claim this many tokens\"\n    );\n\n    uint256[] memory _ids = new uint256[](_amount);\n    uint256[] memory _amounts = new uint256[](_amount);\n\n    for (uint256 i = 0; i < _amount; i++) {\n      stats[MINTS][msg.sender].increment();\n      totalMinted.increment();\n      _ids[i] = totalMinted.current();\n      _amounts[i] = 1;\n    }\n\n    _mintBatch(msg.sender, _ids, _amounts, \"0x0\");\n  }\n\n  /**\n   * Burns callers tokens and records amount burned\n   * @param _ids Array of token ids caller is trying to burn\n   */\n  function burnPublic(uint256[] memory _ids) external {\n    require(CAN_BURN, \"BURGER: burning is not active\");\n    require(_ids.length > 0, \"BURGER: must burn more than 0 tokens\");\n\n    uint256[] memory _amounts = new uint256[](_ids.length);\n\n    for (uint256 i = 0; i < _ids.length; i++) {\n      require(\n        balanceOf(msg.sender, _ids[i]) > 0,\n        \"BURGER: caller is not token owner\"\n      );\n      _amounts[i] = 1;\n      stats[BURNS][msg.sender].increment();\n      totalBurned.increment();\n    }\n    _burnBatch(msg.sender, _ids, _amounts);\n  }\n\n  /// ============ READ-ONLY FUNCTIONS ============ ///\n\n  /**\n   * @return _b If minting tokens is currently allowed\n   */\n  function isMinting() external view returns (bool _b) {\n    return CAN_MINT;\n  }\n\n  /**\n   * @return _b If burning tokens is currently allowed\n   */\n  function isBurning() external view returns (bool _b) {\n    return CAN_BURN;\n  }\n\n  /**\n   * @return _supply The number of tokens in circulation\n   */\n  function totalSupply() external view returns (uint256 _supply) {\n    _supply = totalMinted.current() - totalBurned.current();\n  }\n\n  /**\n   * @return _mints The number of tokens minted\n   */\n  function totalMints() external view returns (uint256 _mints) {\n    _mints = totalMinted.current();\n  }\n\n  /**\n   * @return _burns The number of tokens burned\n   */\n  function totalBurns() external view returns (uint256 _burns) {\n    _burns = totalBurned.current();\n  }\n\n  /**\n   * @param _operator The address to lookup\n   * @return _remaining The number of tokens _operator can mint\n   */\n  function tokenMintsLeft(address _operator)\n    external\n    view\n    returns (uint256 _remaining)\n  {\n    _remaining =\n      AstroGrill.getTotalClaims(_operator) +\n      RickstroGrill.getTotalClaims(_operator) -\n      stats[MINTS][_operator].current();\n  }\n\n  /**\n   * @param _operator The address to lookup\n   * @return _mints The number of tokens _operator has minted\n   */\n  function tokenMints(address _operator)\n    external\n    view\n    returns (uint256 _mints)\n  {\n    _mints = stats[MINTS][_operator].current();\n  }\n\n  /**\n   * @return _burns The number of tokens _operator has burned\n   */\n  function tokenBurns(address _operator)\n    external\n    view\n    returns (uint256 _burns)\n  {\n    _burns = stats[BURNS][_operator].current();\n  }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/ERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/ERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC1155.sol\";\nimport \"./IERC1155Receiver.sol\";\nimport \"./extensions/IERC1155MetadataURI.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of the basic standard multi-token.\n * See https://eips.ethereum.org/EIPS/eip-1155\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\n *\n * _Available since v3.1._\n */\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\n    using Address for address;\n\n    // Mapping from token ID to account balances\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n\n    // Mapping from account to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\n    string private _uri;\n\n    /**\n     * @dev See {_setURI}.\n     */\n    constructor(string memory uri_) {\n        _setURI(uri_);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: balance query for the zero address\");\n        return _balances[id][account];\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @dev See {IERC1155-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    /**\n     * @dev See {IERC1155-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n\n    /**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     */\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    /**\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        _balances[id][to] += amount;\n        emit TransferSingle(operator, address(0), to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens of token type `id` from `from`\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `from` must have at least `amount` tokens of token type `id`.\n     */\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, address(0), _asSingletonArray(id), _asSingletonArray(amount), \"\");\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n\n        emit TransferSingle(operator, from, address(0), id, amount);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     */\n    function _burnBatch(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n        }\n\n        emit TransferBatch(operator, from, address(0), ids, amounts);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits a {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC1155: setting approval status for self\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `id` and `amount` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155.sol\";\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155MetadataURI is IERC1155 {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/utils/ERC1155Holder.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ERC1155Receiver.sol\";\n\n/**\n * Simple implementation of `ERC1155Receiver` that will allow a contract to hold ERC1155 tokens.\n *\n * IMPORTANT: When inheriting this contract, you must include a way to use the received tokens, otherwise they will be\n * stuck.\n *\n * @dev _Available since v3.1._\n */\ncontract ERC1155Holder is ERC1155Receiver {\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] memory,\n        uint256[] memory,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/utils/ERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155Receiver.sol\";\nimport \"../../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\nabstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    }
  }
}}