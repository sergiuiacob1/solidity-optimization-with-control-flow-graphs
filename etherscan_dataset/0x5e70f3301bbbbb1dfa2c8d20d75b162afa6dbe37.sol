{"BlockDirectCall.sol":{"content":"/*\n  Copyright 2019-2022 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\n// SPDX-License-Identifier: Apache-2.0.\npragma solidity ^0.6.12;\n\n/*\n  This contract provides means to block direct call of an external function.\n  A derived contract (e.g. MainDispatcherBase) should decorate sensitive functions with the\n  notCalledDirectly modifier, thereby preventing it from being called directly, and allowing only calling\n  using delegate_call.\n*/\nabstract contract BlockDirectCall {\n    address immutable this_;\n\n    constructor() internal {\n        this_ = address(this);\n    }\n\n    modifier notCalledDirectly() {\n        require(this_ != address(this), \"DIRECT_CALL_DISALLOWED\");\n        _;\n    }\n}\n"},"CairoConstants.sol":{"content":"/*\n  Copyright 2019-2022 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\npragma solidity ^0.6.12;\n\nlibrary CairoConstants {\n    uint256 public constant FIELD_PRIME =\n        0x800000000000011000000000000000000000000000000000000000000000001;\n}\n"},"Common.sol":{"content":"/*\n  Copyright 2019-2022 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\n// SPDX-License-Identifier: Apache-2.0.\npragma solidity ^0.6.12;\n\n/*\n  Common Utility librarries.\n  I. Addresses (extending address).\n*/\nlibrary Addresses {\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size \u003e 0;\n    }\n\n    function performEthTransfer(address recipient, uint256 amount) internal {\n        (bool success, ) = recipient.call{value: amount}(\"\"); // NOLINT: low-level-calls.\n        require(success, \"ETH_TRANSFER_FAILED\");\n    }\n\n    /*\n      Safe wrapper around ERC20/ERC721 calls.\n      This is required because many deployed ERC20 contracts don\u0027t return a value.\n      See https://github.com/ethereum/solidity/issues/4116.\n    */\n    function safeTokenContractCall(address tokenAddress, bytes memory callData) internal {\n        require(isContract(tokenAddress), \"BAD_TOKEN_ADDRESS\");\n        // NOLINTNEXTLINE: low-level-calls.\n        (bool success, bytes memory returndata) = tokenAddress.call(callData);\n        require(success, string(returndata));\n\n        if (returndata.length \u003e 0) {\n            require(abi.decode(returndata, (bool)), \"TOKEN_OPERATION_FAILED\");\n        }\n    }\n\n    /*\n      Validates that the passed contract address is of a real contract,\n      and that its id hash (as infered fromn identify()) matched the expected one.\n    */\n    function validateContractId(address contractAddress, bytes32 expectedIdHash) internal {\n        require(isContract(contractAddress), \"ADDRESS_NOT_CONTRACT\");\n        (bool success, bytes memory returndata) = contractAddress.call( // NOLINT: low-level-calls.\n            abi.encodeWithSignature(\"identify()\")\n        );\n        require(success, \"FAILED_TO_IDENTIFY_CONTRACT\");\n        string memory realContractId = abi.decode(returndata, (string));\n        require(\n            keccak256(abi.encodePacked(realContractId)) == expectedIdHash,\n            \"UNEXPECTED_CONTRACT_IDENTIFIER\"\n        );\n    }\n}\n\n/*\n  II. StarkExTypes - Common data types.\n*/\nlibrary StarkExTypes {\n    // Structure representing a list of verifiers (validity/availability).\n    // A statement is valid only if all the verifiers in the list agree on it.\n    // Adding a verifier to the list is immediate - this is used for fast resolution of\n    // any soundness issues.\n    // Removing from the list is time-locked, to ensure that any user of the system\n    // not content with the announced removal has ample time to leave the system before it is\n    // removed.\n    struct ApprovalChainData {\n        address[] list;\n        // Represents the time after which the verifier with the given address can be removed.\n        // Removal of the verifier with address A is allowed only in the case the value\n        // of unlockedForRemovalTime[A] != 0 and unlockedForRemovalTime[A] \u003c (current time).\n        mapping(address =\u003e uint256) unlockedForRemovalTime;\n    }\n}\n"},"ContractInitializer.sol":{"content":"/*\n  Copyright 2019-2022 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\n// SPDX-License-Identifier: Apache-2.0.\npragma solidity ^0.6.12;\n\n/**\n  Interface for contract initialization.\n  The functions it exposes are the app specific parts of the contract initialization,\n  and are called by the ProxySupport contract that implement the generic part of behind-proxy\n  initialization.\n*/\nabstract contract ContractInitializer {\n    /*\n      The number of sub-contracts that the proxied contract consists of.\n    */\n    function numOfSubContracts() internal pure virtual returns (uint256);\n\n    /*\n      Indicates if the proxied contract has already been initialized.\n      Used to prevent re-init.\n    */\n    function isInitialized() internal view virtual returns (bool);\n\n    /*\n      Validates the init data that is passed into the proxied contract.\n    */\n    function validateInitData(bytes calldata data) internal pure virtual;\n\n    /*\n      For a proxied contract that consists of sub-contracts, this function processes\n      the sub-contract addresses, e.g. validates them, stores them etc.\n    */\n    function processSubContractAddresses(bytes calldata subContractAddresses) internal virtual;\n\n    /*\n      This function applies the logic of initializing the proxied contract state,\n      e.g. setting root values etc.\n    */\n    function initializeContractState(bytes calldata data) internal virtual;\n}\n"},"GenericGovernance.sol":{"content":"/*\n  Copyright 2019-2022 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\n// SPDX-License-Identifier: Apache-2.0.\npragma solidity ^0.6.12;\n\nimport \"Governance.sol\";\n\ncontract GenericGovernance is Governance {\n    bytes32 immutable GOVERNANCE_INFO_TAG_HASH;\n\n    constructor(string memory governanceContext) public {\n        GOVERNANCE_INFO_TAG_HASH = keccak256(abi.encodePacked(governanceContext));\n    }\n\n    /*\n      Returns the GovernanceInfoStruct associated with the governance tag.\n    */\n    function getGovernanceInfo() internal view override returns (GovernanceInfoStruct storage gub) {\n        bytes32 location = GOVERNANCE_INFO_TAG_HASH;\n        assembly {\n            gub_slot := location\n        }\n    }\n\n    function isGovernor(address testGovernor) external view returns (bool) {\n        return _isGovernor(testGovernor);\n    }\n\n    function nominateNewGovernor(address newGovernor) external {\n        _nominateNewGovernor(newGovernor);\n    }\n\n    function removeGovernor(address governorForRemoval) external {\n        _removeGovernor(governorForRemoval);\n    }\n\n    function acceptGovernance() external {\n        _acceptGovernance();\n    }\n\n    function cancelNomination() external {\n        _cancelNomination();\n    }\n}\n"},"Governance.sol":{"content":"/*\n  Copyright 2019-2022 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\n// SPDX-License-Identifier: Apache-2.0.\npragma solidity ^0.6.12;\n\nimport \"MGovernance.sol\";\n\n/*\n  Implements Generic Governance, applicable for both proxy and main contract, and possibly others.\n  Notes:\n   The use of the same function names by both the Proxy and a delegated implementation\n   is not possible since calling the implementation functions is done via the default function\n   of the Proxy. For this reason, for example, the implementation of MainContract (MainGovernance)\n   exposes mainIsGovernor, which calls the internal _isGovernor method.\n*/\nabstract contract Governance is MGovernance {\n    event LogNominatedGovernor(address nominatedGovernor);\n    event LogNewGovernorAccepted(address acceptedGovernor);\n    event LogRemovedGovernor(address removedGovernor);\n    event LogNominationCancelled();\n\n    function getGovernanceInfo() internal view virtual returns (GovernanceInfoStruct storage);\n\n    /*\n      Current code intentionally prevents governance re-initialization.\n      This may be a problem in an upgrade situation, in a case that the upgrade-to implementation\n      performs an initialization (for real) and within that calls initGovernance().\n\n      Possible workarounds:\n      1. Clearing the governance info altogether by changing the MAIN_GOVERNANCE_INFO_TAG.\n         This will remove existing main governance information.\n      2. Modify the require part in this function, so that it will exit quietly\n         when trying to re-initialize (uncomment the lines below).\n    */\n    function initGovernance() internal {\n        GovernanceInfoStruct storage gub = getGovernanceInfo();\n        require(!gub.initialized, \"ALREADY_INITIALIZED\");\n        gub.initialized = true; // to ensure addGovernor() won\u0027t fail.\n        // Add the initial governer.\n        addGovernor(msg.sender);\n    }\n\n    function _isGovernor(address testGovernor) internal view override returns (bool) {\n        GovernanceInfoStruct storage gub = getGovernanceInfo();\n        return gub.effectiveGovernors[testGovernor];\n    }\n\n    /*\n      Cancels the nomination of a governor candidate.\n    */\n    function _cancelNomination() internal onlyGovernance {\n        GovernanceInfoStruct storage gub = getGovernanceInfo();\n        gub.candidateGovernor = address(0x0);\n        emit LogNominationCancelled();\n    }\n\n    function _nominateNewGovernor(address newGovernor) internal onlyGovernance {\n        GovernanceInfoStruct storage gub = getGovernanceInfo();\n        require(!_isGovernor(newGovernor), \"ALREADY_GOVERNOR\");\n        gub.candidateGovernor = newGovernor;\n        emit LogNominatedGovernor(newGovernor);\n    }\n\n    /*\n      The addGovernor is called in two cases:\n      1. by _acceptGovernance when a new governor accepts its role.\n      2. by initGovernance to add the initial governor.\n      The difference is that the init path skips the nominate step\n      that would fail because of the onlyGovernance modifier.\n    */\n    function addGovernor(address newGovernor) private {\n        require(!_isGovernor(newGovernor), \"ALREADY_GOVERNOR\");\n        GovernanceInfoStruct storage gub = getGovernanceInfo();\n        gub.effectiveGovernors[newGovernor] = true;\n    }\n\n    function _acceptGovernance() internal {\n        // The new governor was proposed as a candidate by the current governor.\n        GovernanceInfoStruct storage gub = getGovernanceInfo();\n        require(msg.sender == gub.candidateGovernor, \"ONLY_CANDIDATE_GOVERNOR\");\n\n        // Update state.\n        addGovernor(gub.candidateGovernor);\n        gub.candidateGovernor = address(0x0);\n\n        // Send a notification about the change of governor.\n        emit LogNewGovernorAccepted(msg.sender);\n    }\n\n    /*\n      Remove a governor from office.\n    */\n    function _removeGovernor(address governorForRemoval) internal onlyGovernance {\n        require(msg.sender != governorForRemoval, \"GOVERNOR_SELF_REMOVE\");\n        GovernanceInfoStruct storage gub = getGovernanceInfo();\n        require(_isGovernor(governorForRemoval), \"NOT_GOVERNOR\");\n        gub.effectiveGovernors[governorForRemoval] = false;\n        emit LogRemovedGovernor(governorForRemoval);\n    }\n}\n"},"IStarknetMessaging.sol":{"content":"/*\n  Copyright 2019-2022 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\n// SPDX-License-Identifier: Apache-2.0.\npragma solidity ^0.6.12;\n\nimport \"IStarknetMessagingEvents.sol\";\n\ninterface IStarknetMessaging is IStarknetMessagingEvents {\n    /**\n      Sends a message to an L2 contract.\n\n      Returns the hash of the message.\n    */\n    function sendMessageToL2(\n        uint256 toAddress,\n        uint256 selector,\n        uint256[] calldata payload\n    ) external returns (bytes32);\n\n    /**\n      Consumes a message that was sent from an L2 contract.\n\n      Returns the hash of the message.\n    */\n    function consumeMessageFromL2(uint256 fromAddress, uint256[] calldata payload)\n        external\n        returns (bytes32);\n\n    /**\n      Starts the cancellation of an L1 to L2 message.\n      A message can be canceled messageCancellationDelay() seconds after this function is called.\n\n      Note: This function may only be called for a message that is currently pending and the caller\n      must be the sender of the that message.\n    */\n    function startL1ToL2MessageCancellation(\n        uint256 toAddress,\n        uint256 selector,\n        uint256[] calldata payload,\n        uint256 nonce\n    ) external;\n\n    /**\n      Cancels an L1 to L2 message, this function should be called messageCancellationDelay() seconds\n      after the call to startL1ToL2MessageCancellation().\n    */\n    function cancelL1ToL2Message(\n        uint256 toAddress,\n        uint256 selector,\n        uint256[] calldata payload,\n        uint256 nonce\n    ) external;\n}\n"},"IStarknetMessagingEvents.sol":{"content":"/*\n  Copyright 2019-2022 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\n// SPDX-License-Identifier: Apache-2.0.\npragma solidity ^0.6.12;\n\ninterface IStarknetMessagingEvents {\n    // This event needs to be compatible with the one defined in Output.sol.\n    event LogMessageToL1(uint256 indexed fromAddress, address indexed toAddress, uint256[] payload);\n\n    // An event that is raised when a message is sent from L1 to L2.\n    event LogMessageToL2(\n        address indexed fromAddress,\n        uint256 indexed toAddress,\n        uint256 indexed selector,\n        uint256[] payload,\n        uint256 nonce\n    );\n\n    // An event that is raised when a message from L2 to L1 is consumed.\n    event ConsumedMessageToL1(\n        uint256 indexed fromAddress,\n        address indexed toAddress,\n        uint256[] payload\n    );\n\n    // An event that is raised when a message from L1 to L2 is consumed.\n    event ConsumedMessageToL2(\n        address indexed fromAddress,\n        uint256 indexed toAddress,\n        uint256 indexed selector,\n        uint256[] payload,\n        uint256 nonce\n    );\n\n    // An event that is raised when a message from L1 to L2 Cancellation is started.\n    event MessageToL2CancellationStarted(\n        address indexed fromAddress,\n        uint256 indexed toAddress,\n        uint256 indexed selector,\n        uint256[] payload,\n        uint256 nonce\n    );\n\n    // An event that is raised when a message from L1 to L2 is canceled.\n    event MessageToL2Canceled(\n        address indexed fromAddress,\n        uint256 indexed toAddress,\n        uint256 indexed selector,\n        uint256[] payload,\n        uint256 nonce\n    );\n}\n"},"MGovernance.sol":{"content":"/*\n  Copyright 2019-2022 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\n// SPDX-License-Identifier: Apache-2.0.\npragma solidity ^0.6.12;\n\nstruct GovernanceInfoStruct {\n    mapping(address =\u003e bool) effectiveGovernors;\n    address candidateGovernor;\n    bool initialized;\n}\n\nabstract contract MGovernance {\n    function _isGovernor(address testGovernor) internal view virtual returns (bool);\n\n    /*\n      Allows calling the function only by a Governor.\n    */\n    modifier onlyGovernance() {\n        require(_isGovernor(msg.sender), \"ONLY_GOVERNANCE\");\n        _;\n    }\n}\n"},"NamedStorage.sol":{"content":"/*\n  Copyright 2019-2022 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\n// SPDX-License-Identifier: Apache-2.0.\npragma solidity ^0.6.12;\n\n/*\n  Library to provide basic storage, in storage location out of the low linear address space.\n\n  New types of storage variables should be added here upon need.\n*/\nlibrary NamedStorage {\n    function bytes32ToUint256Mapping(string memory tag_)\n        internal\n        pure\n        returns (mapping(bytes32 =\u003e uint256) storage randomVariable)\n    {\n        bytes32 location = keccak256(abi.encodePacked(tag_));\n        assembly {\n            randomVariable_slot := location\n        }\n    }\n\n    function bytes32ToAddressMapping(string memory tag_)\n        internal\n        pure\n        returns (mapping(bytes32 =\u003e address) storage randomVariable)\n    {\n        bytes32 location = keccak256(abi.encodePacked(tag_));\n        assembly {\n            randomVariable_slot := location\n        }\n    }\n\n    function uintToAddressMapping(string memory tag_)\n        internal\n        pure\n        returns (mapping(uint256 =\u003e address) storage randomVariable)\n    {\n        bytes32 location = keccak256(abi.encodePacked(tag_));\n        assembly {\n            randomVariable_slot := location\n        }\n    }\n\n    function addressToBoolMapping(string memory tag_)\n        internal\n        pure\n        returns (mapping(address =\u003e bool) storage randomVariable)\n    {\n        bytes32 location = keccak256(abi.encodePacked(tag_));\n        assembly {\n            randomVariable_slot := location\n        }\n    }\n\n    function getUintValue(string memory tag_) internal view returns (uint256 retVal) {\n        bytes32 slot = keccak256(abi.encodePacked(tag_));\n        assembly {\n            retVal := sload(slot)\n        }\n    }\n\n    function setUintValue(string memory tag_, uint256 value) internal {\n        bytes32 slot = keccak256(abi.encodePacked(tag_));\n        assembly {\n            sstore(slot, value)\n        }\n    }\n\n    function setUintValueOnce(string memory tag_, uint256 value) internal {\n        require(getUintValue(tag_) == 0, \"ALREADY_SET\");\n        setUintValue(tag_, value);\n    }\n\n    function getAddressValue(string memory tag_) internal view returns (address retVal) {\n        bytes32 slot = keccak256(abi.encodePacked(tag_));\n        assembly {\n            retVal := sload(slot)\n        }\n    }\n\n    function setAddressValue(string memory tag_, address value) internal {\n        bytes32 slot = keccak256(abi.encodePacked(tag_));\n        assembly {\n            sstore(slot, value)\n        }\n    }\n\n    function setAddressValueOnce(string memory tag_, address value) internal {\n        require(getAddressValue(tag_) == address(0x0), \"ALREADY_SET\");\n        setAddressValue(tag_, value);\n    }\n\n    function getBoolValue(string memory tag_) internal view returns (bool retVal) {\n        bytes32 slot = keccak256(abi.encodePacked(tag_));\n        assembly {\n            retVal := sload(slot)\n        }\n    }\n\n    function setBoolValue(string memory tag_, bool value) internal {\n        bytes32 slot = keccak256(abi.encodePacked(tag_));\n        assembly {\n            sstore(slot, value)\n        }\n    }\n}\n"},"ProxySupport.sol":{"content":"/*\n  Copyright 2019-2022 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\n// SPDX-License-Identifier: Apache-2.0.\npragma solidity ^0.6.12;\n\nimport \"Governance.sol\";\nimport \"Common.sol\";\nimport \"BlockDirectCall.sol\";\nimport \"ContractInitializer.sol\";\n\n/**\n  This contract contains the code commonly needed for a contract to be deployed behind\n  an upgradability proxy.\n  It perform the required semantics of the proxy pattern,\n  but in a generic manner.\n  Instantiation of the Governance and of the ContractInitializer, that are the app specific\n  part of initialization, has to be done by the using contract.\n*/\nabstract contract ProxySupport is Governance, BlockDirectCall, ContractInitializer {\n    using Addresses for address;\n\n    // The two function below (isFrozen \u0026 initialize) needed to bind to the Proxy.\n    function isFrozen() external view virtual returns (bool) {\n        return false;\n    }\n\n    /*\n      The initialize() function serves as an alternative constructor for a proxied deployment.\n\n      Flow and notes:\n      1. This function cannot be called directly on the deployed contract, but only via\n         delegate call.\n      2. If an EIC is provided - init is passed onto EIC and the standard init flow is skipped.\n         This true for both first intialization or a later one.\n      3. The data passed to this function is as follows:\n         [sub_contracts addresses, eic address, initData].\n\n         When calling on an initialized contract (no EIC scenario), initData.length must be 0.\n    */\n    function initialize(bytes calldata data) external notCalledDirectly {\n        uint256 eicOffset = 32 * numOfSubContracts();\n        uint256 expectedBaseSize = eicOffset + 32;\n        require(data.length \u003e= expectedBaseSize, \"INIT_DATA_TOO_SMALL\");\n        address eicAddress = abi.decode(data[eicOffset:expectedBaseSize], (address));\n\n        bytes calldata subContractAddresses = data[:eicOffset];\n\n        processSubContractAddresses(subContractAddresses);\n\n        bytes calldata initData = data[expectedBaseSize:];\n\n        // EIC Provided - Pass initData to EIC and the skip standard init flow.\n        if (eicAddress != address(0x0)) {\n            callExternalInitializer(eicAddress, initData);\n            return;\n        }\n\n        if (isInitialized()) {\n            require(initData.length == 0, \"UNEXPECTED_INIT_DATA\");\n        } else {\n            // Contract was not initialized yet.\n            validateInitData(initData);\n            initializeContractState(initData);\n            initGovernance();\n        }\n    }\n\n    function callExternalInitializer(address externalInitializerAddr, bytes calldata eicData)\n        private\n    {\n        require(externalInitializerAddr.isContract(), \"EIC_NOT_A_CONTRACT\");\n\n        // NOLINTNEXTLINE: low-level-calls, controlled-delegatecall.\n        (bool success, bytes memory returndata) = externalInitializerAddr.delegatecall(\n            abi.encodeWithSelector(this.initialize.selector, eicData)\n        );\n        require(success, string(returndata));\n        require(returndata.length == 0, string(returndata));\n    }\n}\n"},"StarknetBridgeConstatns.sol":{"content":"/*\n  Copyright 2019-2022 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\n// SPDX-License-Identifier: Apache-2.0.\npragma solidity ^0.6.12;\n\ncontract StarknetBridgeConstatns {\n    // The selector of the deposit handler in L2.\n    uint256 constant DEPOSIT_SELECTOR =\n        1285101517810983806491589552491143496277809242732141897358598292095611420389;\n    uint256 constant TRANSFER_FROM_STARKNET = 0;\n    uint256 constant UINT256_PART_SIZE_BITS = 128;\n    uint256 constant UINT256_PART_SIZE = 2**UINT256_PART_SIZE_BITS;\n    string constant GOVERNANCE_TAG = \"STARKWARE_DEFAULT_GOVERNANCE_INFO\";\n}\n"},"StarknetEthBridge.sol":{"content":"/*\n  Copyright 2019-2022 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\n// SPDX-License-Identifier: Apache-2.0.\npragma solidity ^0.6.12;\n\nimport \"Common.sol\";\nimport \"StarknetTokenBridge.sol\";\n\ncontract StarknetEthBridge is StarknetTokenBridge {\n    using Addresses for address;\n\n    function deposit(uint256 l2Recipient) external payable {\n        // The msg.value in this transaction was already credited to the contract.\n        require(address(this).balance \u003c= maxTotalBalance(), \"MAX_BALANCE_EXCEEDED\");\n        sendMessage(msg.value, l2Recipient);\n    }\n\n    function withdraw(uint256 amount, address recipient) public override {\n        // Make sure we don\u0027t accidentally burn funds.\n        require(recipient != address(0x0), \"INVALID_RECIPIENT\");\n\n        // The call to consumeMessage will succeed only if a matching L2-\u003eL1 message\n        // exists and is ready for consumption.\n        consumeMessage(amount, recipient);\n        recipient.performEthTransfer(amount);\n    }\n\n    function transferOutFunds(uint256 amount, address recipient) internal override {\n        recipient.performEthTransfer(amount);\n    }\n}\n"},"StarknetTokenBridge.sol":{"content":"/*\n  Copyright 2019-2022 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\n// SPDX-License-Identifier: Apache-2.0.\npragma solidity ^0.6.12;\n\nimport \"GenericGovernance.sol\";\nimport \"ContractInitializer.sol\";\nimport \"ProxySupport.sol\";\nimport \"CairoConstants.sol\";\nimport \"StarknetBridgeConstatns.sol\";\nimport \"StarknetTokenStorage.sol\";\nimport \"IStarknetMessaging.sol\";\n\nabstract contract StarknetTokenBridge is\n    StarknetTokenStorage,\n    StarknetBridgeConstatns,\n    GenericGovernance,\n    ContractInitializer,\n    ProxySupport\n{\n    event LogDeposit(address indexed sender, uint256 amount, uint256 indexed l2Recipient);\n    event LogDepositCancelRequest(\n        address indexed sender,\n        uint256 amount,\n        uint256 indexed l2Recipient,\n        uint256 nonce\n    );\n    event LogDepositReclaimed(\n        address indexed sender,\n        uint256 amount,\n        uint256 indexed l2Recipient,\n        uint256 nonce\n    );\n    event LogWithdrawal(address indexed recipient, uint256 amount);\n    event LogSetL2TokenBridge(uint256 value);\n    event LogSetMaxTotalBalance(uint256 value);\n    event LogSetMaxDeposit(uint256 value);\n\n    function withdraw(uint256 amount, address recipient) public virtual;\n\n    function transferOutFunds(uint256 amount, address recipient) internal virtual;\n\n    /*\n      The constructor is in use here only to set the immutable tag in GenericGovernance.\n    */\n    constructor() internal GenericGovernance(GOVERNANCE_TAG) {}\n\n    function isInitialized() internal view override returns (bool) {\n        return messagingContract() != IStarknetMessaging(0);\n    }\n\n    function numOfSubContracts() internal pure override returns (uint256) {\n        return 0;\n    }\n\n    function validateInitData(bytes calldata data) internal pure override {\n        require(data.length == 64, \"ILLEGAL_DATA_SIZE\");\n    }\n\n    /*\n      No processing needed, as there are no sub-contracts to this contract.\n    */\n    function processSubContractAddresses(bytes calldata subContractAddresses) internal override {}\n\n    /*\n      Gets the addresses of bridgedToken \u0026 messagingContract from the ProxySupport initialize(),\n      and sets the storage slot accordingly.\n    */\n    function initializeContractState(bytes calldata data) internal override {\n        (address bridgedToken_, IStarknetMessaging messagingContract_) = abi.decode(\n            data,\n            (address, IStarknetMessaging)\n        );\n        bridgedToken(bridgedToken_);\n        messagingContract(messagingContract_);\n    }\n\n    modifier isValidL2Address(uint256 l2Address) {\n        require(l2Address != 0, \"L2_ADDRESS_OUT_OF_RANGE\");\n        require(l2Address \u003c CairoConstants.FIELD_PRIME, \"L2_ADDRESS_OUT_OF_RANGE\");\n        _;\n    }\n\n    modifier l2TokenBridgeNotSet() {\n        require(l2TokenBridge() == 0, \"L2_TOKEN_CONTRACT_ALREADY_SET\");\n        _;\n    }\n\n    modifier l2TokenBridgeSet() {\n        require(l2TokenBridge() != 0, \"L2_TOKEN_CONTRACT_NOT_SET\");\n        _;\n    }\n\n    function onlyDepositor(uint256 nonce) internal {\n        require(depositors()[nonce] == msg.sender, \"ONLY_DEPOSITOR\");\n    }\n\n    function setL2TokenBridge(uint256 l2TokenBridge_)\n        external\n        l2TokenBridgeNotSet\n        isValidL2Address(l2TokenBridge_)\n        onlyGovernance\n    {\n        emit LogSetL2TokenBridge(l2TokenBridge_);\n        l2TokenBridge(l2TokenBridge_);\n    }\n\n    /*\n      Sets the maximum allowed balance of the bridge.\n\n      Note: It is possible to set a lower value than the current total balance.\n      In this case, deposits will not be possible, until enough withdrawls are done, such that the\n      total balance gets below the limit.\n    */\n    function setMaxTotalBalance(uint256 maxTotalBalance_) external onlyGovernance {\n        emit LogSetMaxTotalBalance(maxTotalBalance_);\n        maxTotalBalance(maxTotalBalance_);\n    }\n\n    function setMaxDeposit(uint256 maxDeposit_) external onlyGovernance {\n        emit LogSetMaxDeposit(maxDeposit_);\n        maxDeposit(maxDeposit_);\n    }\n\n    function depositMessagePayload(uint256 amount, uint256 l2Recipient)\n        private\n        returns (uint256[] memory)\n    {\n        uint256[] memory payload = new uint256[](3);\n        payload[0] = l2Recipient;\n        payload[1] = amount \u0026 (UINT256_PART_SIZE - 1);\n        payload[2] = amount \u003e\u003e UINT256_PART_SIZE_BITS;\n        return payload;\n    }\n\n    function sendMessage(uint256 amount, uint256 l2Recipient)\n        internal\n        l2TokenBridgeSet\n        isValidL2Address(l2Recipient)\n    {\n        require(amount \u003c= maxDeposit(), \"TRANSFER_TO_STARKNET_AMOUNT_EXCEEDED\");\n        emit LogDeposit(msg.sender, amount, l2Recipient);\n\n        (bool success, bytes memory returndata) = address(messagingContract()).staticcall(\n            abi.encodeWithSignature(\"l1ToL2MessageNonce()\")\n        );\n        require(success, string(returndata));\n        uint256 nonce = abi.decode(returndata, (uint256));\n        messagingContract().sendMessageToL2(\n            l2TokenBridge(),\n            DEPOSIT_SELECTOR,\n            depositMessagePayload(amount, l2Recipient)\n        );\n        require(depositors()[nonce] == address(0x0), \"DEPOSIT_ALREADY_REGISTERED\");\n        depositors()[nonce] = msg.sender;\n    }\n\n    function consumeMessage(uint256 amount, address recipient) internal {\n        emit LogWithdrawal(recipient, amount);\n\n        uint256[] memory payload = new uint256[](4);\n        payload[0] = TRANSFER_FROM_STARKNET;\n        payload[1] = uint256(recipient);\n        payload[2] = amount \u0026 (UINT256_PART_SIZE - 1);\n        payload[3] = amount \u003e\u003e UINT256_PART_SIZE_BITS;\n\n        messagingContract().consumeMessageFromL2(l2TokenBridge(), payload);\n    }\n\n    function withdraw(uint256 amount) external {\n        withdraw(amount, msg.sender);\n    }\n\n    /*\n      A deposit cancellation requires two steps:\n      1. The depositor should send a depositCancelRequest request with deposit details \u0026 nonce.\n      2. After a certain threshold time, (cancellation delay), they can claim back the funds\n         by calling depositReclaim (using the same arguments).\n\n      The nonce should be extracted from the LogMessageToL2 event that was emitted by the\n      StarknetMessaging contract upon deposit.\n\n      Note: As long as the depositReclaim was not performed, the deposit may be processed,\n            even if the cancellation delay time as already passed.\n    */\n    function depositCancelRequest(\n        uint256 amount,\n        uint256 l2Recipient,\n        uint256 nonce\n    ) external {\n        messagingContract().startL1ToL2MessageCancellation(\n            l2TokenBridge(),\n            DEPOSIT_SELECTOR,\n            depositMessagePayload(amount, l2Recipient),\n            nonce\n        );\n\n        // Only the depositor is allowed to cancel a deposit.\n        onlyDepositor(nonce);\n        emit LogDepositCancelRequest(msg.sender, amount, l2Recipient, nonce);\n    }\n\n    function depositReclaim(\n        uint256 amount,\n        uint256 l2Recipient,\n        uint256 nonce\n    ) external {\n        messagingContract().cancelL1ToL2Message(\n            l2TokenBridge(),\n            DEPOSIT_SELECTOR,\n            depositMessagePayload(amount, l2Recipient),\n            nonce\n        );\n\n        // Only the depositor is allowed to reclaim cancelled deposit funds.\n        onlyDepositor(nonce);\n        transferOutFunds(amount, msg.sender);\n        emit LogDepositReclaimed(msg.sender, amount, l2Recipient, nonce);\n    }\n}\n"},"StarknetTokenStorage.sol":{"content":"/*\n  Copyright 2019-2022 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\n// SPDX-License-Identifier: Apache-2.0.\npragma solidity ^0.6.12;\n\nimport \"NamedStorage.sol\";\nimport \"IStarknetMessaging.sol\";\n\nabstract contract StarknetTokenStorage {\n    // Random storage slot tags.\n    string internal constant BRIDGED_TOKEN_TAG = \"STARKNET_ERC20_TOKEN_BRIDGE_TOKEN_ADDRESS\";\n    string internal constant L2_TOKEN_TAG = \"STARKNET_TOKEN_BRIDGE_L2_TOKEN_CONTRACT\";\n    string internal constant MAX_DEPOSIT_TAG = \"STARKNET_TOKEN_BRIDGE_MAX_DEPOSIT\";\n    string internal constant MAX_TOTAL_BALANCE_TAG = \"STARKNET_TOKEN_BRIDGE_MAX_TOTAL_BALANCE\";\n    string internal constant MESSAGING_CONTRACT_TAG = \"STARKNET_TOKEN_BRIDGE_MESSAGING_CONTRACT\";\n    string internal constant DEPOSITOR_ADDRESSES_TAG = \"STARKNET_TOKEN_BRIDGE_DEPOSITOR_ADDRESSES\";\n\n    // Storage Getters.\n    function bridgedToken() internal view returns (address) {\n        return NamedStorage.getAddressValue(BRIDGED_TOKEN_TAG);\n    }\n\n    function l2TokenBridge() internal view returns (uint256) {\n        return NamedStorage.getUintValue(L2_TOKEN_TAG);\n    }\n\n    function maxDeposit() public view returns (uint256) {\n        return NamedStorage.getUintValue(MAX_DEPOSIT_TAG);\n    }\n\n    function maxTotalBalance() public view returns (uint256) {\n        return NamedStorage.getUintValue(MAX_TOTAL_BALANCE_TAG);\n    }\n\n    function messagingContract() internal view returns (IStarknetMessaging) {\n        return IStarknetMessaging(NamedStorage.getAddressValue(MESSAGING_CONTRACT_TAG));\n    }\n\n    // Storage Setters.\n    function bridgedToken(address contract_) internal {\n        NamedStorage.setAddressValueOnce(BRIDGED_TOKEN_TAG, contract_);\n    }\n\n    function l2TokenBridge(uint256 value) internal {\n        NamedStorage.setUintValueOnce(L2_TOKEN_TAG, value);\n    }\n\n    function maxDeposit(uint256 value) internal {\n        NamedStorage.setUintValue(MAX_DEPOSIT_TAG, value);\n    }\n\n    function maxTotalBalance(uint256 value) internal {\n        NamedStorage.setUintValue(MAX_TOTAL_BALANCE_TAG, value);\n    }\n\n    function messagingContract(IStarknetMessaging contract_) internal {\n        NamedStorage.setAddressValueOnce(MESSAGING_CONTRACT_TAG, address(contract_));\n    }\n\n    function depositors() internal pure returns (mapping(uint256 =\u003e address) storage) {\n        return NamedStorage.uintToAddressMapping(DEPOSITOR_ADDRESSES_TAG);\n    }\n}\n"}}