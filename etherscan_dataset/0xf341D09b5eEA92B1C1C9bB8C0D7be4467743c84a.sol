{{
  "language": "Solidity",
  "settings": {
    "evmVersion": "berlin",
    "libraries": {},
    "metadata": {
      "bytecodeHash": "ipfs",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 10000
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/JBReconfigurationBufferBallot.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport '@openzeppelin/contracts/utils/introspection/ERC165.sol';\nimport './interfaces/IJBReconfigurationBufferBallot.sol';\nimport './structs/JBFundingCycle.sol';\n\n/** \n  @notice \n  Manages approving funding cycle reconfigurations automatically after a buffer period.\n\n  @dev\n  Adheres to -\n  IJBReconfigurationBufferBallot: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules.\n\n  @dev\n  Inherits from -\n  ERC165: Introspection on interface adherance. \n*/\ncontract JBReconfigurationBufferBallot is IJBReconfigurationBufferBallot, ERC165 {\n  //*********************************************************************//\n  // ---------------- public immutable stored properties --------------- //\n  //*********************************************************************//\n\n  /**\n    @notice \n    The number of seconds that must pass for a funding cycle reconfiguration to become either `Approved` or `Failed`.\n  */\n  uint256 public immutable override duration;\n\n  /**\n    @notice\n    The contract storing all funding cycle configurations.\n  */\n  IJBFundingCycleStore public immutable override fundingCycleStore;\n\n  //*********************************************************************//\n  // --------------------- public stored properties -------------------- //\n  //*********************************************************************//\n\n  /**\n    @notice \n    The finalized state.\n\n    @dev\n    If `Active`, the ballot for the provided configuration can still be finalized whenever its state settles.\n\n    _projectId The ID of the project to check the final ballot state of.\n    _configuration The configuration of the funding cycle to check the final ballot state of.\n  */\n  mapping(uint256 => mapping(uint256 => JBBallotState)) public override finalState;\n\n  //*********************************************************************//\n  // -------------------------- public views --------------------------- //\n  //*********************************************************************//\n\n  /**\n    @notice \n    The approval state of a particular funding cycle.\n\n    @param _projectId The ID of the project to which the funding cycle being checked belongs.\n    @param _configured The configuration of the funding cycle to check the state of.\n    @param _start The start timestamp of the funding cycle to check the state of.\n\n    @return The state of the provided ballot.\n  */\n  function stateOf(\n    uint256 _projectId,\n    uint256 _configured,\n    uint256 _start\n  ) public view override returns (JBBallotState) {\n    // If there is a finalized state, return it.\n    if (finalState[_projectId][_configured] != JBBallotState.Active)\n      return finalState[_projectId][_configured];\n\n    // If the delay hasn't yet passed, the ballot is either failed or active.\n    if (block.timestamp < _configured + duration)\n      // If the current timestamp is past the start, the ballot is failed.\n      return (block.timestamp >= _start) ? JBBallotState.Failed : JBBallotState.Active;\n\n    // The ballot is otherwise approved.\n    return JBBallotState.Approved;\n  }\n\n  /**\n    @notice\n    Indicates if this contract adheres to the specified interface.\n\n    @dev \n    See {IERC165-supportsInterface}.\n\n    @param _interfaceId The ID of the interface to check for adherance to.\n\n    @return A flag indicating if this contract adheres to the specified interface.\n  */\n  function supportsInterface(bytes4 _interfaceId)\n    public\n    view\n    virtual\n    override(ERC165, IERC165)\n    returns (bool)\n  {\n    return\n      _interfaceId == type(IJBReconfigurationBufferBallot).interfaceId ||\n      _interfaceId == type(IJBFundingCycleBallot).interfaceId ||\n      super.supportsInterface(_interfaceId);\n  }\n\n  //*********************************************************************//\n  // -------------------------- constructor ---------------------------- //\n  //*********************************************************************//\n\n  /**\n    @param _duration The number of seconds to wait until a reconfiguration can be either `Approved` or `Failed`.\n    @param _fundingCycleStore A contract storing all funding cycle configurations.\n  */\n  constructor(uint256 _duration, IJBFundingCycleStore _fundingCycleStore) {\n    duration = _duration;\n    fundingCycleStore = _fundingCycleStore;\n  }\n\n  //*********************************************************************//\n  // ---------------------- external transactions ---------------------- //\n  //*********************************************************************//\n\n  /**\n    @notice \n    Finalizes a configuration state if the current state has settled.\n\n    @param _projectId The ID of the project to which the funding cycle being checked belongs.\n    @param _configured The configuration of the funding cycle to check the state of.\n\n    @return ballotState The state of the finalized ballot. If `Active`, the ballot can still later be finalized when it's state resolves.\n  */\n  function finalize(uint256 _projectId, uint256 _configured)\n    external\n    override\n    returns (JBBallotState ballotState)\n  {\n    // Get the funding cycle for the configuration in question.\n    JBFundingCycle memory _fundingCycle = fundingCycleStore.get(_projectId, _configured);\n\n    // Get the current ballot state.\n    ballotState = finalState[_projectId][_configured];\n\n    // If the final ballot state is still `Active`.\n    if (ballotState == JBBallotState.Active) {\n      ballotState = stateOf(_projectId, _configured, _fundingCycle.start);\n      // If the ballot is active after the cycle has started, it should be finalized as failed.\n      if (ballotState != JBBallotState.Active) {\n        // Store the updated value.\n        finalState[_projectId][_configured] = ballotState;\n\n        emit Finalize(_projectId, _configured, ballotState, msg.sender);\n      }\n    }\n  }\n}\n"
    },
    "contracts/enums/JBBallotState.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nenum JBBallotState {\n  Active,\n  Approved,\n  Failed\n}\n"
    },
    "contracts/interfaces/IJBFundingCycleBallot.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport '@openzeppelin/contracts/utils/introspection/IERC165.sol';\nimport './../enums/JBBallotState.sol';\nimport './IJBFundingCycleStore.sol';\n\ninterface IJBFundingCycleBallot is IERC165 {\n  function duration() external view returns (uint256);\n\n  function stateOf(\n    uint256 _projectId,\n    uint256 _configuration,\n    uint256 _start\n  ) external view returns (JBBallotState);\n}\n"
    },
    "contracts/interfaces/IJBFundingCycleStore.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport './../enums/JBBallotState.sol';\nimport './../structs/JBFundingCycle.sol';\nimport './../structs/JBFundingCycleData.sol';\n\ninterface IJBFundingCycleStore {\n  event Configure(\n    uint256 indexed configuration,\n    uint256 indexed projectId,\n    JBFundingCycleData data,\n    uint256 metadata,\n    uint256 mustStartAtOrAfter,\n    address caller\n  );\n\n  event Init(uint256 indexed configuration, uint256 indexed projectId, uint256 indexed basedOn);\n\n  function latestConfigurationOf(uint256 _projectId) external view returns (uint256);\n\n  function get(uint256 _projectId, uint256 _configuration)\n    external\n    view\n    returns (JBFundingCycle memory);\n\n  function latestConfiguredOf(uint256 _projectId)\n    external\n    view\n    returns (JBFundingCycle memory fundingCycle, JBBallotState ballotState);\n\n  function queuedOf(uint256 _projectId) external view returns (JBFundingCycle memory fundingCycle);\n\n  function currentOf(uint256 _projectId) external view returns (JBFundingCycle memory fundingCycle);\n\n  function currentBallotStateOf(uint256 _projectId) external view returns (JBBallotState);\n\n  function configureFor(\n    uint256 _projectId,\n    JBFundingCycleData calldata _data,\n    uint256 _metadata,\n    uint256 _mustStartAtOrAfter\n  ) external returns (JBFundingCycle memory fundingCycle);\n}\n"
    },
    "contracts/interfaces/IJBReconfigurationBufferBallot.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport './IJBFundingCycleBallot.sol';\n\ninterface IJBReconfigurationBufferBallot is IJBFundingCycleBallot {\n  event Finalize(\n    uint256 indexed projectId,\n    uint256 indexed configuration,\n    JBBallotState indexed ballotState,\n    address caller\n  );\n\n  function finalState(uint256 _projectId, uint256 _configuration)\n    external\n    view\n    returns (JBBallotState);\n\n  function fundingCycleStore() external view returns (IJBFundingCycleStore);\n\n  function finalize(uint256 _projectId, uint256 _configured) external returns (JBBallotState);\n}\n"
    },
    "contracts/structs/JBFundingCycle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport './../interfaces/IJBFundingCycleBallot.sol';\n\n/** \n  @member number The funding cycle number for the cycle's project. Each funding cycle has a number that is an increment of the cycle that directly preceded it. Each project's first funding cycle has a number of 1.\n  @member configuration The timestamp when the parameters for this funding cycle were configured. This value will stay the same for subsequent funding cycles that roll over from an originally configured cycle.\n  @member basedOn The `configuration` of the funding cycle that was active when this cycle was created.\n  @member start The timestamp marking the moment from which the funding cycle is considered active. It is a unix timestamp measured in seconds.\n  @member duration The number of seconds the funding cycle lasts for, after which a new funding cycle will start. A duration of 0 means that the funding cycle will stay active until the project owner explicitly issues a reconfiguration, at which point a new funding cycle will immediately start with the updated properties. If the duration is greater than 0, a project owner cannot make changes to a funding cycle's parameters while it is active – any proposed changes will apply to the subsequent cycle. If no changes are proposed, a funding cycle rolls over to another one with the same properties but new `start` timestamp and a discounted `weight`.\n  @member weight A fixed point number with 18 decimals that contracts can use to base arbitrary calculations on. For example, payment terminals can use this to determine how many tokens should be minted when a payment is received.\n  @member discountRate A percent by how much the `weight` of the subsequent funding cycle should be reduced, if the project owner hasn't configured the subsequent funding cycle with an explicit `weight`. If it's 0, each funding cycle will have equal weight. If the number is 90%, the next funding cycle will have a 10% smaller weight. This weight is out of `JBConstants.MAX_DISCOUNT_RATE`.\n  @member ballot An address of a contract that says whether a proposed reconfiguration should be accepted or rejected. It can be used to create rules around how a project owner can change funding cycle parameters over time.\n  @member metadata Extra data that can be associated with a funding cycle.\n*/\nstruct JBFundingCycle {\n  uint256 number;\n  uint256 configuration;\n  uint256 basedOn;\n  uint256 start;\n  uint256 duration;\n  uint256 weight;\n  uint256 discountRate;\n  IJBFundingCycleBallot ballot;\n  uint256 metadata;\n}\n"
    },
    "contracts/structs/JBFundingCycleData.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport './../interfaces/IJBFundingCycleBallot.sol';\n\n/** \n  @member duration The number of seconds the funding cycle lasts for, after which a new funding cycle will start. A duration of 0 means that the funding cycle will stay active until the project owner explicitly issues a reconfiguration, at which point a new funding cycle will immediately start with the updated properties. If the duration is greater than 0, a project owner cannot make changes to a funding cycle's parameters while it is active – any proposed changes will apply to the subsequent cycle. If no changes are proposed, a funding cycle rolls over to another one with the same properties but new `start` timestamp and a discounted `weight`.\n  @member weight A fixed point number with 18 decimals that contracts can use to base arbitrary calculations on. For example, payment terminals can use this to determine how many tokens should be minted when a payment is received.\n  @member discountRate A percent by how much the `weight` of the subsequent funding cycle should be reduced, if the project owner hasn't configured the subsequent funding cycle with an explicit `weight`. If it's 0, each funding cycle will have equal weight. If the number is 90%, the next funding cycle will have a 10% smaller weight. This weight is out of `JBConstants.MAX_DISCOUNT_RATE`.\n  @member ballot An address of a contract that says whether a proposed reconfiguration should be accepted or rejected. It can be used to create rules around how a project owner can change funding cycle parameters over time.\n*/\nstruct JBFundingCycleData {\n  uint256 duration;\n  uint256 weight;\n  uint256 discountRate;\n  IJBFundingCycleBallot ballot;\n}\n"
    }
  }
}}