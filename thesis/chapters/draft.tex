\chapter*{Draft} 
\addcontentsline{toc}{chapter}{Draft}

\section{Local optimizations}
Optimizing for loops.

\begin{lstlisting}[language=solidity]
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

contract VariableInsideLoop {
    function declareVariableInsideLoop() public pure {
        for (uint i = 1; i <= 1000; i++) {
            uint x = i * i;
        }
    }

    function declareVariableOutsideLoop() public pure {
        uint x;
        for (uint i = 1; i <= 1000; i++) {
            x = i * i;
        }
    }
}
\end{lstlisting}

\^ Compiled with solidity 0.8.7, no optimizations enabled.
inside loop gas cost: 420223 gas
outside loop gas cost: 415250 gas

with 200 optimization runs:
inside loop gas cost: 237215 gas
outside loop gas cost: 232242 gas

Still lower!

\begin{lstlisting}[language=bash]
sergiuiacob@Sergius-MacBook-Pro dataset % solhint variable_declaration_loops.sol

\end{lstlisting}

solhint outputs nothing – it sees no issues

nor does solium (eth lint)


\begin{lstlisting}[language=bash]
sergiuiacob@Sergius-MacBook-Pro dataset % solium -f variable_declaration_loops.sol

No issues found.

sergiuiacob@Sergius-MacBook-Pro dataset % solium -f variable_declaration_if.sol

No issues found.

\end{lstlisting}


variable declaration inside if: 21217 gas
variable declaration outside if: 21274 gas
in this case, outside consumes more gas

200 optimization runs did not change anything



Resurse utile
* https://homepages.dcc.ufmg.br/~fernando/classes/dcc888/ementa/
* https://etherscan.io/contractsVerified
  * statistici cu cat \% din contracte folosesc solc 0.8


De adaugat in prezentare
* detaliu: Ethereum blockchain only stores EVM bytecode, so the high level code needs to be optimized before turned into EVM, of course
* https://eprints.ucm.es/id/eprint/61812/1/HERNANDEZ_CEREZO_Tecnicas_de_analisis_para_contratos_inteligentes_generacion_de_grafos_de_control_de_flujo_completos_4398577_720285146.pdf     <------------- tool care imbunatateste Oyente / EthIR si gaseste security flaws. poate fi aplicat pe codul pe care il generez eu
* optimizer passes (etape): pot fi platform independent / dependent
* optimizari facute pe baza YUL, example: function inlining https://www.youtube.com/watch?v=VH4MgZDyZJU&ab_channel=EthereumFoundation
* despre cum CFG-urile sunt folosite: "Gastap is one of the few tools based on static analysis that manages to infer gas upper
bounds for transactions. Gastap is one of the most accurate tools in the field, having a
great success rate. It generates a Control-Flow-Graph (CFG) as an intermediate representation of the analysis. However, the current algorithm used by Gastap is not precise.
Therefore, a considerable number of smart contracts cannot be analyzed." din https://eprints.ucm.es/id/eprint/61812/1/HERNANDEZ_CEREZO_Tecnicas_de_analisis_para_contratos_inteligentes_generacion_de_grafos_de_control_de_flujo_completos_4398577_720285146.pdf



Misc stuff
* adaugat screenshot cu llvm-opt --help (optimizarile pe care le poate face0
* de vorbit despre ce e "--optimize-runs" (scrie in doc oficial). trade off intre code size / code efficiency
* Simple Inlining a fost adaugat in solidity 0.8.2!!! super recent
* YUL optimizer: "The optimizer currently follows a purely greedy strategy and does not do any backtracking."

Proprietati noduri CFG
* The	flow	of	control	can	only	
enter	the	basic	block	through	
the	first	instruction	in	the	
block.

Proprietati pentru solidity optimizer (on YUL)
* Disambiguatorul seteaza unique names pt fiecare functie / variabila
* loop related optimizations
  * stop condition is moved into the loop body
  * loop initialization body is moved before the loop
  * majoritatea optimizarilor listate in documentatia oficiala (0.8.14) graviteaza in jurul precalcularii constantelor si propagarii acestora

----din https://homepages.dcc.ufmg.br/~fernando/classes/dcc888/ementa/slides/ControlFlowGraphs.pdf

* first instruction of a block == leader (multiple moduri de a identifica leaders)
* basic blocks pot fi construite in functie de leader-ii identificati
  * un basic block incepe la primul leader si se termina la urmatorul leader

Idei cu ce pot face
* CFG intre contracte?
* diferite rezolutii CFG
* vizualizare CFG (graphviz?)
* dead code elimination (https://homepages.dcc.ufmg.br/~fernando/classes/dcc888/ementa/slides/ControlFlowGraphs.pdf)
  * ca pas intr-un CI
* izolarea codului – cred ca daca iau toate variabilele si le izolez (gen ce e folosit intr-un if sa fie definit acolo) etc. atunci o sa consume mai putin gas
  
* pentru a-mi testa softul: idei in capitolul 8.1 din https://eprints.ucm.es/id/eprint/61812/1/HERNANDEZ_CEREZO_Tecnicas_de_analisis_para_contratos_inteligentes_generacion_de_grafos_de_control_de_flujo_completos_4398577_720285146.pdf

Optimizari deja facute de solc
* Local common subexpression eliminator
* citat din doc oficial: "specializes or inlines functions" (probabil on in loc de or)
  * todo aici, de aratat un exemplu pe YUL direct, inlined vs uninlined (--optimize --ir-optimized versus --ir)


Tipuri de optimizari
* local optimizations – in interiorul unui basic block

Pentru prezentare, Proof of Concept:
* programul meu intr-un CI care propune optimizari la PR-uri pentru cod ;)


How does LLVM work? Let's take that for example
* Virtual Register Allocation (ca exemplu)
https://homepages.dcc.ufmg.br/~fernando/classes/dcc888/ementa/slides/ControlFlowGraphs.pdf