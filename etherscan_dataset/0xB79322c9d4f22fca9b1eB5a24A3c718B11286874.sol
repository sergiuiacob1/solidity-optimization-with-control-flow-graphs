{{
  "language": "Solidity",
  "settings": {
    "evmVersion": "london",
    "libraries": {},
    "metadata": {
      "bytecodeHash": "ipfs",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "contracts/BaseMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\ncontract BaseMath {\n\n    /// @notice Constant for the fractional arithmetics. Similar to 1 ETH = 1e18 wei.\n    uint256 constant internal DECIMAL_PRECISION = 1e18;\n\n    /// @notice Constant for the fractional arithmetics with ACR.\n    uint256 constant internal ACR_DECIMAL_PRECISION = 1e4;\n\n}\n"
    },
    "contracts/CentralLogger.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.10;\n\n/// @title Central logger contract\n/// @notice Log collector with only 1 purpose - to emit the event. Can be called from any contract\n/** @dev Use like this:\n*\n* bytes32 internal constant CENTRAL_LOGGER_ID = keccak256(\"CentralLogger\");\n* CentralLogger logger = CentralLogger(Registry(registry).getAddress(CENTRAL_LOGGER_ID));\n*\n* Or directly:\n*   CentralLogger logger = CentralLogger(0xDEPLOYEDADDRESS);\n*\n* logger.log(\n*            address(this),\n*            msg.sender,\n*            \"myGreatFunction\",\n*            abi.encode(msg.value, param1, param2)\n*        );\n*\n* DO NOT USE delegateCall as it defies the centralisation purpose of this logger.\n*/\ncontract CentralLogger {\n\n    event LogEvent(\n        address indexed contractAddress,\n        address indexed caller,\n        string indexed logName,\n        bytes data\n    );\n\n\t/* solhint-disable no-empty-blocks */\n\tconstructor() {\n\t}\n\n    /// @notice Log the event centrally\n    /// @dev For gas impact see https://www.evm.codes/#a3\n    /// @param _logName length must be less than 32 bytes\n    function log(\n        address _contract,\n        address _caller,\n        string memory _logName,\n        bytes memory _data\n    ) public {\n        emit LogEvent(_contract, _caller, _logName, _data);\n    }\n}\n"
    },
    "contracts/CommunityAcknowledgement.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0\npragma solidity =0.8.10;\n\nimport \"./Ownable.sol\";\n\ncontract CommunityAcknowledgement is Ownable {\n\n\t/// @notice Recognised Community Contributor Acknowledgement Rate\n\t/// @dev Id is keccak256 hash of contributor address\n\tmapping (bytes32 => uint16) public rccar;\n\n\t/// @notice Emit when owner recognises contributor\n\t/// @param contributor Keccak256 hash of recognised contributor address\n\t/// @param previousAcknowledgementRate Previous contributor acknowledgement rate\n\t/// @param newAcknowledgementRate New contributor acknowledgement rate\n\tevent ContributorRecognised(bytes32 indexed contributor, uint16 indexed previousAcknowledgementRate, uint16 indexed newAcknowledgementRate);\n\n\t/* solhint-disable-next-line no-empty-blocks */\n\tconstructor(address _adoptionDAOAddress) Ownable(_adoptionDAOAddress) {\n\n\t}\n\n\t/// @notice Getter for Recognised Community Contributor Acknowledgement Rate\n\t/// @param _contributor Keccak256 hash of contributor address\n\t/// @return Acknowledgement Rate\n\tfunction getAcknowledgementRate(bytes32 _contributor) external view returns (uint16) {\n\t\treturn rccar[_contributor];\n\t}\n\n\t/// @notice Getter for Recognised Community Contributor Acknowledgement Rate for msg.sender\n\t/// @return Acknowledgement Rate\n\tfunction senderAcknowledgementRate() external view returns (uint16) {\n\t\treturn rccar[keccak256(abi.encodePacked(msg.sender))];\n\t}\n\n\t/// @notice Recognise community contributor and set its acknowledgement rate\n\t/// @dev Only owner can recognise contributor\n\t/// @dev Emits `ContributorRecognised` event\n\t/// @param _contributor Keccak256 hash of recognised contributor address\n\t/// @param _acknowledgementRate Contributor new acknowledgement rate\n\tfunction recogniseContributor(bytes32 _contributor, uint16 _acknowledgementRate) public onlyOwner {\n\t\tuint16 _previousAcknowledgementRate = rccar[_contributor];\n\t\trccar[_contributor] = _acknowledgementRate;\n\t\temit ContributorRecognised(_contributor, _previousAcknowledgementRate, _acknowledgementRate);\n\t}\n\n\t/// @notice Recognise list of contributors\n\t/// @dev Only owner can recognise contributors\n\t/// @dev Emits `ContributorRecognised` event for every contributor\n\t/// @param _contributors List of keccak256 hash of recognised contributor addresses\n\t/// @param _acknowledgementRates List of contributors new acknowledgement rates\n\tfunction batchRecogniseContributor(bytes32[] calldata _contributors, uint16[] calldata _acknowledgementRates) external onlyOwner {\n\t\trequire(_contributors.length == _acknowledgementRates.length, \"Lists do not match in length\");\n\n\t\tfor (uint256 i = 0; i < _contributors.length; i++) {\n\t\t\trecogniseContributor(_contributors[i], _acknowledgementRates[i]);\n\t\t}\n\t}\n\n}\n"
    },
    "contracts/Config.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.10;\n\nimport \"./Ownable.sol\";\n\n/// @title APUS config contract\n/// @notice Holds global variables for the rest of APUS ecosystem\ncontract Config is Ownable {\n\n\t/// @notice Adoption Contribution Rate, where 100% = 10000 = ACR_DECIMAL_PRECISION. \n\t/// @dev Percent value where 0 -> 0%, 10 -> 0.1%, 100 -> 1%, 250 -> 2.5%, 550 -> 5.5%, 1000 -> 10%, 0xffff -> 655.35%\n\t/// @dev Example: x * adoptionContributionRate / ACR_DECIMAL_PRECISION\n\tuint16 public adoptionContributionRate;\n\n\t/// @notice Adoption DAO multisig address\n\taddress payable public adoptionDAOAddress;\n\n\t/// @notice Emit when owner changes Adoption Contribution Rate\n\t/// @param caller Who changed the Adoption Contribution Rate (i.e. who was owner at that moment)\n\t/// @param previousACR Previous Adoption Contribution Rate\n\t/// @param newACR New Adoption Contribution Rate\n\tevent ACRChanged(address indexed caller, uint16 previousACR, uint16 newACR);\n\n\t/// @notice Emit when owner changes Adoption DAO address\n\t/// @param caller Who changed the Adoption DAO address (i.e. who was owner at that moment)\n\t/// @param previousAdoptionDAOAddress Previous Adoption DAO address\n\t/// @param newAdoptionDAOAddress New Adoption DAO address\n\tevent AdoptionDAOAddressChanged(address indexed caller, address previousAdoptionDAOAddress, address newAdoptionDAOAddress);\n\n\t/* solhint-disable-next-line func-visibility */\n\tconstructor(address payable _adoptionDAOAddress, uint16 _initialACR) Ownable(_adoptionDAOAddress) {\n\t\tadoptionContributionRate = _initialACR;\n\t\tadoptionDAOAddress = _adoptionDAOAddress;\n\t}\n\n\n\t/// @notice Change Adoption Contribution Rate\n\t/// @dev Only owner can change Adoption Contribution Rate\n\t/// @dev Emits `ACRChanged` event\n\t/// @param _newACR Adoption Contribution Rate\n\tfunction setAdoptionContributionRate(uint16 _newACR) external onlyOwner {\n\t\tuint16 _previousACR = adoptionContributionRate;\n\t\tadoptionContributionRate = _newACR;\n\t\temit ACRChanged(msg.sender, _previousACR, _newACR);\n\t}\n\n\t/// @notice Change Adoption DAO address\n\t/// @dev Only owner can change Adoption DAO address\n\t/// @dev Emits `AdoptionDAOAddressChanged` event\n\tfunction setAdoptionDAOAddress(address payable _newAdoptionDAOAddress) external onlyOwner {\n\t\taddress payable _previousAdoptionDAOAddress = adoptionDAOAddress;\n\t\tadoptionDAOAddress = _newAdoptionDAOAddress;\n\t\temit AdoptionDAOAddressChanged(msg.sender, _previousAdoptionDAOAddress, _newAdoptionDAOAddress);\n\t}\n\n}\n"
    },
    "contracts/Executor.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0\npragma solidity =0.8.10;\n\nimport \"./Config.sol\";\nimport \"./Registry.sol\";\nimport \"./dapphub/DSProxyFactory.sol\";\nimport \"./CentralLogger.sol\";\nimport \"./CommunityAcknowledgement.sol\";\nimport \"./interfaces/IBorrowerOperations.sol\";\nimport \"./interfaces/ITroveManager.sol\";\nimport \"./interfaces/ICollSurplusPool.sol\";\nimport \"./interfaces/ILUSDToken.sol\";\nimport \"./interfaces/IPriceFeed.sol\";\nimport \"./LiquityMath.sol\";\n\n/// @title APUS execution logic\n/// @dev Should be called as delegatecall from APUS smart account proxy\ncontract Executor is LiquityMath{\n\n\t// ================================================================================\n\t// WARNING!!!!\n\t// Executor must not have or store any stored variables (constant and immutable variables are not stored).\n\t// It could conflict with proxy storage as it is called via delegatecall from proxy.\n\t// ================================================================================\n\t/* solhint-disable var-name-mixedcase */\n\n\t/// @notice Registry's contracts IDs\n\tbytes32 private constant CONFIG_ID = keccak256(\"Config\");\n\tbytes32 private constant CENTRAL_LOGGER_ID = keccak256(\"CentralLogger\");\n\tbytes32 private constant COMMUNITY_ACKNOWLEDGEMENT_ID = keccak256(\"CommunityAcknowledgement\");\n\n\t/// @notice APUS registry address\n\taddress public immutable registry;\n\t\n\t// MakerDAO's deployed contracts - Proxy Factory\n\t// see https://changelog.makerdao.com/\n\tDSProxyFactory public immutable ProxyFactory;\n\n\t// L1 Liquity deployed contracts\n\t// see https://docs.liquity.org/documentation/resources#contract-addresses\n\tIBorrowerOperations public immutable BorrowerOperations;\n\tITroveManager public immutable TroveManager;\n\tICollSurplusPool public immutable CollSurplusPool;\n    ILUSDToken public immutable LUSDToken;\n\tIPriceFeed public immutable PriceFeed;\n\t\n\t/* solhint-enable var-name-mixedcase */\n\n\t/// @dev enum for the logger events\n\tenum AdjustCreditLineLiquityChoices {\n\t\tDebtIncrease, DebtDecrease, CollateralIncrease, CollateralDecrease\n\t}\n\n    /* --- Variable container structs  ---\n    Used to hold, return and assign variables inside a function, in order to avoid the error:\n    \"CompilerError: Stack too deep\". */\n\t/* solhint-disable-next-line contract-name-camelcase */\n\tstruct LocalVariables_adjustCreditLineLiquity {\n\t\tConfig config;\n\t\tuint256 neededLUSDChange;\n\t\tuint256 expectedLiquityProtocolRate;\n\t\tuint256 previousLUSDBalance;\n\t\tuint256 previousETHBalance;\t\n\t\tuint16 acr;\n\t\tuint256 price;\n\t\tbool isDebtIncrease;\n\t\tuint256 mintedLUSD;\n\t\tuint256 adoptionContributionLUSD;\t\t\t\t\n\t}\n\n\n\t/// @notice Modifier will fail if function is not called within proxy contract\n\t/// @dev Mofifier checks if current address is valid (MakerDAO) proxy\n\tmodifier onlyProxy() {\n\t\trequire(ProxyFactory.isProxy(address(this)), \"Only proxy can call Executor\");\n\t\t_;\n\t}\n\n\t/* solhint-disable-next-line func-visibility */\n\tconstructor(\n\t\taddress _registry,\n\t\taddress _borrowerOperations,\n\t\taddress _troveManager,\n\t\taddress _collSurplusPool,\n\t\taddress _lusdToken,\n\t\taddress _priceFeed,\n\t\taddress _proxyFactory\n\t) {\n\t\tregistry = _registry;\n\t\tBorrowerOperations = IBorrowerOperations(_borrowerOperations);\n\t\tTroveManager = ITroveManager(_troveManager);\n\t\tCollSurplusPool = ICollSurplusPool(_collSurplusPool);\n\t\tLUSDToken = ILUSDToken(_lusdToken);\n\t\tPriceFeed = IPriceFeed(_priceFeed);\n\t\tProxyFactory = DSProxyFactory(_proxyFactory);\n\t}\n\n\t// ------------------------------------------ Liquity functions ------------------------------------------\n\n\t/// @notice Sends LUSD amount from Smart Account to _LUSDTo account. Sends total balance if uint256.max is given as the amount.\n\t/* solhint-disable-next-line var-name-mixedcase */\n\tfunction sendLUSD(address _LUSDTo, uint256 _amount) internal {\n\t\tif (_amount == type(uint256).max) {\n            _amount = getLUSDBalance(address(this));\n        }\n\t\t// Do not transfer from Smart Account to itself, silently pass such case.\n        if (_LUSDTo != address(this) && _amount != 0) {\n\t\t\t// LUSDToken.transfer reverts on recipient == adress(0) or == liquity contracts.\n\t\t\t// Overall either reverts or procedes returning true. Never returns false.\n            LUSDToken.transfer(_LUSDTo, _amount);\n\t\t}\n\t}\n\n\t/// @notice Pulls LUSD amount from `_from` address to Smart Account. Pulls total balance if uint256.max is given as the amount.\n\tfunction pullLUSDFrom(address _from, uint256 _amount) internal {\n\t\tif (_amount == type(uint256).max) {\n            _amount = getLUSDBalance(_from);\n        }\n\t\t// Do not transfer from Smart Account to itself, silently pass such case.\n\t\tif (_from != address(this) && _amount != 0) {\n\t\t\t// function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\t\t\t// LUSDToken.transfer reverts on allowance issue, recipient == adress(0) or == liquity contracts.\n\t\t\t// Overall either reverts or procedes returning true. Never returns false.\n\t\t\tLUSDToken.transferFrom(_from, address(this), _amount);\n\t\t}\n\t}\n\n\t/// @notice Gets the LUSD balance of the account\n\tfunction getLUSDBalance(address _acc) internal view returns (uint256) {\n\t\treturn LUSDToken.balanceOf(_acc);\n\t}\n\n\t/// @notice Get and apply Recognised Community Contributor Acknowledgement Rate to ACR for the Contributor\n\t/// @param _acr Adoption Contribution Rate in uint16\n\t/// @param _requestor Requestor for whom to apply Contributor Acknowledgement if is set\n\tfunction adjustAcrForRequestor(uint16 _acr, address _requestor) internal view returns (uint16) {\n\t\t// Get and apply Recognised Community Contributor Acknowledgement Rate\n\t\tCommunityAcknowledgement ca = CommunityAcknowledgement(Registry(registry).getAddress(COMMUNITY_ACKNOWLEDGEMENT_ID));\n\n\t\tuint16 rccar = ca.getAcknowledgementRate(keccak256(abi.encodePacked(_requestor)));\n\n\t\treturn applyRccarOnAcr(rccar, _acr);\n\t}\n\n\n\t/// @notice Open a new credit line using Liquity protocol by depositing ETH collateral and borrowing LUSD.\n\t/// @dev Value is amount of ETH to deposit into Liquity Trove\n\t/// @param _LUSDRequestedDebt Amount of LUSD caller wants to borrow and withdraw.\n\t/// @param _LUSDTo Address that will receive the generated LUSD.\n\t/// @param _upperHint For gas optimalisation. Referring to the prevId of the two adjacent nodes in the linked list that are (or would become) the neighbors of the given Liquity Trove.\n\t/// @param _lowerHint For gas optimalisation. Referring to the nextId of the two adjacent nodes in the linked list that are (or would become) the neighbors of the given Liquity Trove.\n\t/// @param _caller msg.sender in the Stargate\n\t/// @dev Hints explained: https://github.com/liquity/dev#supplying-hints-to-trove-operations\n\t/// @dev Hints should reflect calculated neededLUSDAmount instead of _LUSDRequestedDebt\n\t/* solhint-disable-next-line var-name-mixedcase */\n\tfunction openCreditLineLiquity(uint256 _LUSDRequestedDebt, address _LUSDTo, address _upperHint, address _lowerHint, address _caller) external payable onlyProxy {\n\n\t\t// Assertions and relevant reverts are done within Liquity protocol\n\t\t// Re-entrancy is avoided by calling the openTrove (cannot open the additional trove for the same smart account)\n\t\t\n\t\tConfig config = Config(Registry(registry).getAddress(CONFIG_ID));\n\n\t\tuint256 mintedLUSD;\n\t\tuint256 neededLUSDAmount;\n\t\tuint256 expectedLiquityProtocolRate;\n\n\t\t{ // scope to avoid stack too deep errors\n\t\t\tuint16 acr = adjustAcrForRequestor(config.adoptionContributionRate(), _caller);\n\n\t\t\t// Find effectively that Liquity is in Recovery mode => 0 rate\n\t\t\t// TroveManager.checkRecoveryMode() requires priceFeed.fetchPrice(), \n\t\t\t// which is expensive to run and will be run again when openTrove is called.\n\t\t\t// We use much cheaper view PriceFeed.lastGoodPrice instead, which might be outdated by 1 call\n\t\t\t// Consequence in such situation is that the Adoption Contribution is decreased by otherwise non applicable protocol fee.\n\t\t\t// There is no negative impact on the user.\n\t\t\tuint256 price = PriceFeed.lastGoodPrice();\n\t\t\texpectedLiquityProtocolRate = (TroveManager.checkRecoveryMode(price)) ? 0 : TroveManager.getBorrowingRateWithDecay();\n\n\t\t\tneededLUSDAmount = calcNeededLiquityLUSDAmount(_LUSDRequestedDebt, expectedLiquityProtocolRate, acr);\n\n\t\t\tuint256 previousLUSDBalance = getLUSDBalance(address(this));\n\n\t\t\tBorrowerOperations.openTrove{value: msg.value}(\n\t\t\t\tLIQUITY_PROTOCOL_MAX_BORROWING_FEE,\n\t\t\t\tneededLUSDAmount,\n\t\t\t\t_upperHint,\n\t\t\t\t_lowerHint\n\t\t\t);\n\n\t\t\tmintedLUSD = getLUSDBalance(address(this)) - previousLUSDBalance;\n\t\t}\n\n\t\t// Can send only what was minted\n\t\t// assert (_LUSDRequestedDebt <= mintedLUSD); // asserts in adoptionContributionLUSD calculation by avoiding underflow\n\t\tuint256 adoptionContributionLUSD = mintedLUSD - _LUSDRequestedDebt;\n\n\t\tCentralLogger logger = CentralLogger(Registry(registry).getAddress(CENTRAL_LOGGER_ID));\n\t\tlogger.log(\n\t\t\taddress(this), _caller, \"openCreditLineLiquity\",\n\t\t\tabi.encode(_LUSDRequestedDebt, _LUSDTo, _upperHint, _lowerHint, neededLUSDAmount, mintedLUSD, expectedLiquityProtocolRate)\n\t\t);\n\n\t\t// Send LUSD to the Adoption DAO\n\t\tsendLUSD(config.adoptionDAOAddress(), adoptionContributionLUSD);\n\n\t\t// Send LUSD to the requested address\n\t\t// Must be located at the end to avoid withdrawal by re-entrancy into potential LUSD withdrawal function\n\t\tsendLUSD(_LUSDTo, _LUSDRequestedDebt);\n\t}\n\n\n\t/// @notice Closes the Liquity trove\n\t/// @param _LUSDFrom Address where the LUSD is being pulled from to repay debt.\n\t/// @param _collateralTo Address that will receive the withdrawn collateral ETH.\n\t/// @param _caller msg.sender in the Stargate\n\t/// @dev Closing Liquity Credit Line pulls required LUSD and therefore requires approval on LUSD spending\n\t/* solhint-disable-next-line var-name-mixedcase */\n\tfunction closeCreditLineLiquity(address _LUSDFrom, address payable _collateralTo, address _caller) public onlyProxy {\n\n\t\tuint256 collateral = TroveManager.getTroveColl(address(this));\n\n\t\t// getTroveDebt returns composite debt including 200 LUSD gas compensation\n\t\t// Liquity Trove cannot have less than 2000 LUSD total composite debt\n\t\t// @dev Substraction is safe since solidity 0.8 reverts on underflow\n\t\tuint256 debtToRepay = TroveManager.getTroveDebt(address(this)) - LIQUITY_LUSD_GAS_COMPENSATION;\n\n\t\t// Liquity requires to have LUSD on the msg.sender, i.e. on Smart Account proxy\n\t\t// Pull LUSD from _from (typically EOA) to Smart Account proxy\n\t\tpullLUSDFrom(_LUSDFrom, debtToRepay);\n\n\t\t// Closing trove results in ETH to be stored on Smart Account proxy\n\t\tBorrowerOperations.closeTrove(); \n\n\t\tCentralLogger logger = CentralLogger(Registry(registry).getAddress(CENTRAL_LOGGER_ID));\n\t\tlogger.log(\n\t\t\taddress(this), _caller, \"closeCreditLineLiquity\",\n\t\t\tabi.encode(_LUSDFrom, _collateralTo, debtToRepay, collateral)\n\t\t);\n\n\t\t// Must be last to avoid re-entrancy attack\n\t\t// In fact BorrowerOperations.closeTrove() fails on re-entrancy since Trove would be closed in re-entrancy\n\t\t// solhint-disable-next-line avoid-low-level-calls\n\t\t(bool success, ) = _collateralTo.call{ value: collateral }(\"\");\n\t\trequire(success, \"Sending collateral ETH failed\");\n\n\t}\n\n\t/// @notice Closes the Liquity trove using EIP2612 Permit.\n\t/// @param _LUSDFrom Address where the LUSD is being pulled from to repay debt.\n\t/// @param _collateralTo Address that will receive the withdrawn collateral ETH.\n\t/// @param v EIP2612 secp256k1 permit signature part\n\t/// @param r EIP2612 secp256k1 permit signature part\n\t/// @param s EIP2612 secp256k1 permit signature part\n\t/// @param _caller msg.sender in the Stargate\n\t/// @dev Closing Liquity Credit Line pulls required LUSD and therefore requires approval on LUSD spending\n\t/* solhint-disable-next-line var-name-mixedcase */\n\tfunction closeCreditLineLiquityWithPermit(address _LUSDFrom, address payable _collateralTo, uint8 v, bytes32 r, bytes32 s, address _caller) external onlyProxy {\n\t\t// getTroveDebt returns composite debt including 200 LUSD gas compensation\n\t\t// Liquity Trove cannot have less than 2000 LUSD total composite debt\n\t\t// @dev Substraction is safe since solidity 0.8 reverts on underflow\n\t\tuint256 debtToRepay = TroveManager.getTroveDebt(address(this)) - LIQUITY_LUSD_GAS_COMPENSATION;\n\n\t\tLUSDToken.permit(_LUSDFrom, address(this), debtToRepay, type(uint256).max, v, r, s);\n\n\t\tcloseCreditLineLiquity(_LUSDFrom, _collateralTo, _caller);\n\t}\n\n\t/// @notice Enables a borrower to simultaneously change both their collateral and debt.\n\t/// @param _isDebtIncrease Indication whether _LUSDRequestedChange increases debt (true), decreases debt(false) or does not impact debt (false).\n\t/// @param _LUSDRequestedChange Amount of LUSD to be returned or further borrowed.\n\t///\t\t\tThe increase or decrease is indicated by _isDebtIncrease.\n\t///\t\t\tAdoption Contribution and protocol's fees are applied in the form of additional debt in case of requested debt increase.\n\t/// @param _LUSDAddress Address where the LUSD is being pulled from in case of to repaying debt.\n\t/// Or address that will receive the generated LUSD in case of increasing debt.\n\t/// Approval of LUSD transfers for given Smart Account is required in case of repaying debt.\n\t/// @param _collWithdrawal Amount of ETH collateral to withdraw. MUST be 0 if ETH is provided to increase collateral.\n\t/// @param _collateralTo Address that will receive the withdrawn collateral ETH.\n\t/// @param _upperHint For gas optimalisation. Referring to the prevId of the two adjacent nodes in the linked list that are (or would become) the neighbors of the given Liquity Trove.\n\t/// @param _lowerHint For gas optimalisation. Referring to the nextId of the two adjacent nodes in the linked list that are (or would become) the neighbors of the given Liquity Trove.\n\t/// @param _caller msg.sender in the Stargate\n\t/// @dev Hints explained: https://github.com/liquity/dev#supplying-hints-to-trove-operations\n\t/// @dev Hints should reflect calculated neededLUSDChange instead of _LUSDRequestedChange\n\t/// @dev Value is amount of ETH to deposit into Liquity protocol\n\t/* solhint-disable var-name-mixedcase */\n\tfunction adjustCreditLineLiquity(\n\t\tbool _isDebtIncrease,\n\t\tuint256 _LUSDRequestedChange,\n\t\taddress _LUSDAddress,\n\t\tuint256 _collWithdrawal,\n\t\taddress _collateralTo,\n\t\taddress _upperHint, address _lowerHint, address _caller\n\t\t/* solhint-enable var-name-mixedcase */\n\t) public payable onlyProxy {\n\n\t\t// Assertions and relevant reverts are done within Liquity protocol\n\n\t\tLocalVariables_adjustCreditLineLiquity memory vars;\n\t\t\n\t\tvars.config = Config(Registry(registry).getAddress(CONFIG_ID));\n\n\t\t// Make sure there is a requested increase in debt\n\t\tvars.isDebtIncrease = _isDebtIncrease && (_LUSDRequestedChange > 0);\n\n\t\t// Handle pre trove action regarding debt.\n\t\tif (vars.isDebtIncrease) {\n\t\t\t{\n\t\t\tvars.acr = adjustAcrForRequestor(vars.config.adoptionContributionRate(), _caller);\n\n\t\t\t// Find effectively that Liquity is in Recovery mode => 0 rate\n\t\t\t// TroveManager.checkRecoveryMode() requires priceFeed.fetchPrice(), \n\t\t\t// which is expensive to run and will be run again when adjustTrove is called.\n\t\t\t// We use much cheaper view PriceFeed.lastGoodPrice instead, which might be outdated by 1 call\n\t\t\t// Consequence in such situation is that the Adoption Contribution is decreased by otherwise non applicable protocol fee.\n\t\t\t// There is no negative impact on the user.\n\t\t\tvars.price = PriceFeed.lastGoodPrice();\n\t\t\tvars.expectedLiquityProtocolRate = (TroveManager.checkRecoveryMode(vars.price)) ? 0 : TroveManager.getBorrowingRateWithDecay();\n\n\t\t\tvars.neededLUSDChange = calcNeededLiquityLUSDAmount(_LUSDRequestedChange, vars.expectedLiquityProtocolRate, vars.acr);\n\t\t\t}\n\t\t} else {\n\t\t\t// Debt decrease (= repayment) or no change in debt\n\t\t\tvars.neededLUSDChange = _LUSDRequestedChange;\n\n\t\t\tif (vars.neededLUSDChange > 0) {\n\t\t\t\t// Debt decrease\n\t\t\t\t// Liquity requires to have LUSD on the msg.sender, i.e. on Smart Account proxy\n\t\t\t\t// Pull LUSD from _LUSDAddress (typically EOA) to Smart Account proxy\n\t\t\t\t// Pull is re-entrancy safe as we call non upgradable LUSDToken\n\t\t\t\tpullLUSDFrom(_LUSDAddress, vars.neededLUSDChange);\n\t\t\t}\n\t\t}\n\n\t\tvars.previousLUSDBalance = getLUSDBalance(address(this));\n\t\tvars.previousETHBalance = address(this).balance;\n\n\t\t// Check on singular-collateral-change is done within Liquity\n\t\t// Receiving ETH in case of collateral increase is implemented by passing the value. \n\t\tBorrowerOperations.adjustTrove{value: msg.value}(\n\t\t\t\tLIQUITY_PROTOCOL_MAX_BORROWING_FEE,\n\t\t\t\t_collWithdrawal,\n\t\t\t\tvars.neededLUSDChange,\n\t\t\t\tvars.isDebtIncrease,\n\t\t\t\t_upperHint,\n\t\t\t\t_lowerHint\n\t\t\t);\n\n\t\tCentralLogger logger = CentralLogger(Registry(registry).getAddress(CENTRAL_LOGGER_ID));\n\n\t\t// Handle post trove-change regarding debt.\n\t\t// Only debt increase requires actions, as debt decrease was handled by pre trove operation.\n\t\tif (vars.isDebtIncrease) {\n\t\t\tvars.mintedLUSD = getLUSDBalance(address(this)) - vars.previousLUSDBalance;\n\t\t\t// Can send only what was minted\n\t\t\t// assert (_LUSDRequestedChange <= mintedLUSD); // asserts in adoptionContributionLUSD calculation by avoiding underflow\n\t\t\tvars.adoptionContributionLUSD = vars.mintedLUSD - _LUSDRequestedChange;\n\n\t\t\t// Send LUSD to the Adoption DAO\n\t\t\tsendLUSD(vars.config.adoptionDAOAddress(), vars.adoptionContributionLUSD);\n\n\t\t\t// Send LUSD to the requested address\n\t\t\tsendLUSD(_LUSDAddress, _LUSDRequestedChange);\n\n\n\t\t\tlogger.log(\n\t\t\t\taddress(this), _caller, \"adjustCreditLineLiquity\",\n\t\t\t\tabi.encode(\n\t\t\t\t\tAdjustCreditLineLiquityChoices.DebtIncrease, \n\t\t\t\t\tvars.mintedLUSD, \n\t\t\t\t\t_LUSDRequestedChange,\n\t\t\t\t\t_LUSDAddress\n\t\t\t\t\t)\n\t\t\t);\n\n\t\t} else if (vars.neededLUSDChange > 0) {\n\t\t\t// Log debt decrease\n\t\t\tlogger.log(\n\t\t\t\taddress(this), _caller, \"adjustCreditLineLiquity\",\n\t\t\t\tabi.encode(AdjustCreditLineLiquityChoices.DebtDecrease, _LUSDRequestedChange, _LUSDAddress)\n\t\t\t);\n\t\t}\n\n\t\t// Handle post trove-change regarding collateral.\n\t\t// Only collateral decrease (withdrawal) requires actions, \n\t\t// as collateral increase was handled by passing value to the trove operation (= getting ETH from sender into the trove).\n\t\tif (msg.value > 0) {\n\t\t\t// Log collateral increase\n\t\t\tlogger.log(\n\t\t\t\taddress(this), _caller, \"adjustCreditLineLiquity\",\n\t\t\t\tabi.encode(AdjustCreditLineLiquityChoices.CollateralIncrease, msg.value, _caller)\n\t\t\t);\n\n\t\t} else if (_collWithdrawal > 0) {\n\t\t\t// Collateral decrease\n\n\t\t\t// Make sure we send what was provided by the Trove\n\t\t\tuint256 collateralChange = address(this).balance - vars.previousETHBalance;\n\n\t\t\tlogger.log(\n\t\t\t\taddress(this), _caller, \"adjustCreditLineLiquity\",\n\t\t\t\tabi.encode(AdjustCreditLineLiquityChoices.CollateralDecrease, collateralChange, _collWithdrawal, _collateralTo)\n\t\t\t);\n\n\t\t\t// Must be last to avoid re-entrancy attack\n\t\t\t// solhint-disable-next-line avoid-low-level-calls\n\t\t\t(bool success, ) = _collateralTo.call{ value: collateralChange }(\"\");\n\t\t\trequire(success, \"Sending collateral ETH failed\");\n\t\t}\n\t}\n\n\t/// @notice Enables a borrower to simultaneously change both their collateral and decrease debt providing LUSD from ANY ADDRESS using EIP2612 Permit. \n\t/// Use calculateChangedLiquityParameters for gasless calculation of proper Hints for _LUSDRequestedChange.\n\t/// It is useful only when the debt decrease is requested while working with collateral.\n\t/// In all other cases [adjustCreditLineLiquity()] MUST be used. It is cheaper on gas.\n\t/// @param _LUSDRequestedChange Amount of LUSD to be returned.\n\t/// @param _LUSDFrom Address where the LUSD is being pulled from. Can be ANY ADDRESS with enough LUSD.\n\t/// Approval of LUSD transfers for given Smart Account is ensured by the offchain signature from that address.\n\t/// @param _collWithdrawal Amount of ETH collateral to withdraw. MUST be 0 if ETH is provided to increase collateral.\n\t/// @param _collateralTo Address that will receive the withdrawn collateral ETH.\n\t/// @param _upperHint For gas optimalisation when using Liquity protocol. Use calculateChangedLiquityParameters for gasless calculation of proper Hints for _LUSDRequestedChange.\n\t/// @param _lowerHint For gas optimalisation when using Liquity protocol. Use calculateChangedLiquityParameters for gasless calculation of proper Hints for _LUSDRequestedChange.\n\t/// @param v EIP2612 secp256k1 permit signature part\n\t/// @param r EIP2612 secp256k1 permit signature part\n\t/// @param s EIP2612 secp256k1 permit signature part\n\t/// @param _caller msg.sender in the Stargate\n\t/// @dev Hints explained: https://github.com/liquity/dev#supplying-hints-to-trove-operations\n\t/// @dev Value is amount of ETH to deposit into Liquity protocol\n\t/* solhint-disable var-name-mixedcase */\n\tfunction adjustCreditLineLiquityWithPermit(\n\t\tuint256 _LUSDRequestedChange,\n\t\taddress _LUSDFrom,\n\t\tuint256 _collWithdrawal,\n\t\taddress _collateralTo,\n\t\taddress _upperHint, address _lowerHint,\n\t\tuint8 v, bytes32 r, bytes32 s,\n\t\taddress _caller\n\t\t/* solhint-enable var-name-mixedcase */\n\t) external payable onlyProxy {\n\t\tLUSDToken.permit(_LUSDFrom, address(this), _LUSDRequestedChange, type(uint256).max, v, r, s);\n\n\t\tadjustCreditLineLiquity(false, _LUSDRequestedChange, _LUSDFrom, _collWithdrawal, _collateralTo, _upperHint, _lowerHint, _caller);\n\t}\n\n\t/// @notice Claims remaining collateral from the user's closed Liquity Trove due to a redemption or a liquidation with ICR > MCR in Recovery Mode\n\t/// @param _collateralTo Address that will receive the claimed collateral ETH.\n\t/// @param _caller msg.sender in the Stargate\n\tfunction claimRemainingCollateralLiquity(address payable _collateralTo, address _caller) external onlyProxy {\n\t\t\n\t\tuint256 remainingCollateral = CollSurplusPool.getCollateral(address(this));\n\n\t\t// Reverts if there is no collateral to claim \n\t\tBorrowerOperations.claimCollateral();\n\n\t\tCentralLogger logger = CentralLogger(Registry(registry).getAddress(CENTRAL_LOGGER_ID));\n\t\tlogger.log(\n\t\t\taddress(this), _caller, \"claimRemainingCollateralLiquity\",\n\t\t\tabi.encode(_collateralTo, remainingCollateral)\n\t\t);\n\n\t\t// Send claimed ETH\n\t\t// Must be last to avoid re-entrancy attack\n\t\t// In fact BorrowerOperations.claimCollateral() reverts on re-entrancy since there will be no residual collateral to claim\n\t\t// solhint-disable-next-line avoid-low-level-calls\n\t\t(bool success, ) = _collateralTo.call{ value: remainingCollateral }(\"\");\n\t\t/* solhint-disable-next-line reason-string */\n\t\trequire(success, \"Sending of claimed collateral failed.\");\n\t}\n\n\t/// @notice Allows ANY ADDRESS (calling and paying) to add ETH collateral to borrower's Credit Line (Liquity protocol) and thus increase CR (decrease LTV ratio).\n\t/// @param _upperHint For gas optimalisation when using Liquity protocol. Use calculateChangedLiquityParameters for gasless calculation of proper Hints.\n\t/// @param _lowerHint For gas optimalisation when using Liquity protocol. Use calculateChangedLiquityParameters for gasless calculation of proper Hints.\n\t/// @param _caller msg.sender in the Stargate\n\t/// @dev Hints explained: https://github.com/liquity/dev#supplying-hints-to-trove-operations\n\t/// \tDANGEROUS operation, which can be initiated by non-owner of Smart Account (via Smart Account, though)\n\t///\t\tHaving the impact on the Smart Account storage. Therefore no 3rd party contract besides Liquity is called.\n\tfunction addCollateralLiquity(address _upperHint, address _lowerHint, address _caller) external payable onlyProxy {\n\n\t\tBorrowerOperations.addColl{value: msg.value}(_upperHint, _lowerHint);\n\n\t\tCentralLogger logger = CentralLogger(Registry(registry).getAddress(CENTRAL_LOGGER_ID));\n\t\tlogger.log(\n\t\t\taddress(this), _caller, \"addCollateralLiquity\",\n\t\t\tabi.encode(msg.value, _caller)\n\t\t);\n\t}\n\n\n\t/// @notice Withdraws amount of ETH collateral from the Credit Line and transfer to _collateralTo address.\n\t/// @param _collWithdrawal Amount of ETH collateral to withdraw\n\t/// @param _collateralTo Address that will receive the withdrawn collateral ETH\n\t/// @param _upperHint For gas optimalisation when using Liquity protocol. Use calculateChangedLiquityParameters for gasless calculation of proper Hints.\n\t/// @param _lowerHint For gas optimalisation when using Liquity protocol. Use calculateChangedLiquityParameters for gasless calculation of proper Hints.\n\t/// @param _caller msg.sender in the Stargate\n\t/// @dev Hints explained: https://github.com/liquity/dev#supplying-hints-to-trove-operations\n\tfunction withdrawCollateralLiquity(uint256 _collWithdrawal, address payable _collateralTo, address _upperHint, address _lowerHint, address _caller) external onlyProxy {\n\n\t\t// Withdrawing results in ETH to be stored on Smart Account proxy\n\t\tBorrowerOperations.withdrawColl(_collWithdrawal, _upperHint, _lowerHint);\n\n\t\tCentralLogger logger = CentralLogger(Registry(registry).getAddress(CENTRAL_LOGGER_ID));\n\t\tlogger.log(\n\t\t\taddress(this), _caller, \"withdrawCollateralLiquity\",\n\t\t\tabi.encode(_collWithdrawal, _collateralTo)\n\t\t);\n\n\t\t// Must be last to mitigate re-entrancy attack\n\t\t// Re-entrancy only enables caller to withdraw and transfer more ETH if allowed by the trove.\n\t\t// Having just negative impact on the caller (by spending more gas).\n\t\t// solhint-disable-next-line avoid-low-level-calls\n\t\t(bool success, ) = _collateralTo.call{ value: _collWithdrawal }(\"\");\n\t\trequire(success, \"Sending collateral ETH failed\");\n\n\t}\n\n\t/// @notice Enables credit line owner to partially repay the debt from ANY ADDRESS by the given amount of LUSD.\n\t/// Approval of LUSD transfers for given Smart Account is required.\n\t/// Cannot repay below 2000 LUSD composite debt. Use closeCreditLineLiquity to repay whole debt instead.\n\t/// @param _LUSDRequestedChange Amount of LUSD to be repaid. Repaying is subject to leaving 2000 LUSD min. debt in the Liquity protocol.\n\t/// @param _LUSDFrom Address where the LUSD is being pulled from to repay debt.\n\t/// @param _upperHint For gas optimalisation when using Liquity protocol. Use calculateChangedLiquityParameters for gasless calculation of proper Hints for _LUSDRequestedChange.\n\t/// @param _lowerHint For gas optimalisation when using Liquity protocol. Use calculateChangedLiquityParameters for gasless calculation of proper Hints for _LUSDRequestedChange.\n\t/// @param _caller msg.sender in the Stargate\n\t/// @dev Hints explained: https://github.com/liquity/dev#supplying-hints-to-trove-operations\n\t/* solhint-disable-next-line var-name-mixedcase */\t\n\tfunction repayLUSDLiquity(uint256 _LUSDRequestedChange, address _LUSDFrom, address _upperHint, address _lowerHint, address _caller) public onlyProxy {\n\t\t// Debt decrease\n\t\t// Liquity requires to have LUSD on the msg.sender, i.e. on Smart Account proxy\n\t\t// Pull LUSD from _LUSDFrom (typically EOA) to Smart Account proxy\n\t\t// Pull is re-entrancy safe as we call non upgradable LUSDToken contract\n\t\tpullLUSDFrom(_LUSDFrom, _LUSDRequestedChange);\n\n\t\tBorrowerOperations.repayLUSD(_LUSDRequestedChange, _upperHint, _lowerHint);\n\n\t\tCentralLogger logger = CentralLogger(Registry(registry).getAddress(CENTRAL_LOGGER_ID));\n\t\tlogger.log(\n\t\t\taddress(this), _caller, \"repayLUSDLiquity\",\n\t\t\tabi.encode(_LUSDRequestedChange, _LUSDFrom)\n\t\t);\n\n\t}\n\n\t/// @notice Enables credit line owner to partially repay the debt from ANY ADDRESS by the given amount of LUSD using EIP 2612 Permit.\n\t/// Approval of LUSD transfers for given Smart Account is ensured by the offchain signature from that address.\n\t/// Cannot repay below 2000 LUSD composite debt. Use closeCreditLineLiquity to repay whole debt instead.\n\t/// @param _LUSDRequestedChange Amount of LUSD to be repaid. Repaying is subject to leaving 2000 LUSD min. debt in the Liquity protocol.\n\t/// @param _LUSDFrom Address where the LUSD is being pulled from to repay debt.\n\t/// @param _upperHint For gas optimalisation when using Liquity protocol. Use calculateChangedLiquityParameters for gasless calculation of proper Hints for _LUSDRequestedChange.\n\t/// @param _lowerHint For gas optimalisation when using Liquity protocol. Use calculateChangedLiquityParameters for gasless calculation of proper Hints for _LUSDRequestedChange.\n\t/// @param v EIP2612 secp256k1 permit signature part\n\t/// @param r EIP2612 secp256k1 permit signature part\n\t/// @param s EIP2612 secp256k1 permit signature part\n\t/// @param _caller msg.sender in the Stargate\n\t/// @dev Hints explained: https://github.com/liquity/dev#supplying-hints-to-trove-operations\n\t/* solhint-disable-next-line var-name-mixedcase */\t\n\tfunction repayLUSDLiquityWithPermit(uint256 _LUSDRequestedChange, address _LUSDFrom, address _upperHint, address _lowerHint, uint8 v, bytes32 r, bytes32 s, address _caller) external onlyProxy {\n\t\tLUSDToken.permit(_LUSDFrom, address(this), _LUSDRequestedChange, type(uint256).max, v, r, s);\n\n\t\trepayLUSDLiquity(_LUSDRequestedChange, _LUSDFrom, _upperHint, _lowerHint, _caller);\n\t}\n\n}\n"
    },
    "contracts/LiquityMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"./BaseMath.sol\";\n\n/// @title Business calculation logic related to the Liquity protocol\n/// @dev To be inherited only\ncontract LiquityMath is BaseMath {\n\n    // Maximum protocol fee as defined in the Liquity contracts\n    // https://github.com/liquity/dev/blob/cb583ddf5e7de6010e196cfe706bd0ca816ea40e/packages/contracts/contracts/TroveManager.sol#L48\n    uint256 internal constant LIQUITY_PROTOCOL_MAX_BORROWING_FEE = DECIMAL_PRECISION / 100 * 5; // 5%\n\n    // Amount of LUSD to be locked in Liquity's gas pool on opening troves\n    // https://github.com/liquity/dev/blob/cb583ddf5e7de6010e196cfe706bd0ca816ea40e/packages/contracts/contracts/TroveManager.sol#L334\n    uint256 internal constant LIQUITY_LUSD_GAS_COMPENSATION = 200e18;\n\n\t/// @notice Calculates the needed amount of LUSD parameter for Liquity protocol when borrowing LUSD\n    /// @param _LUSDRequestedAmount Amount the user wants to withdraw\n    /// @param _expectedLiquityProtocolRate Current / expected borrowing rate of the Liquity protocol\n    /// @param _adoptionContributionRate Adoption Contribution Rate in uint16 form (xxyy defines xx.yy %). LPR is applied when ACR < LPR. Thus LPR is always used When AR is set to 0.\n    /* solhint-disable-next-line var-name-mixedcase */\n    function calcNeededLiquityLUSDAmount(uint256 _LUSDRequestedAmount, uint256 _expectedLiquityProtocolRate, uint16 _adoptionContributionRate) internal pure returns (\n        uint256 neededLiquityLUSDAmount\n    ) {\n\n        // Normalise ACR 1e4 -> 1e18\n        uint256 acr = DECIMAL_PRECISION / ACR_DECIMAL_PRECISION * _adoptionContributionRate;\n\n        // Apply Liquity protocol rate when ACR is lower\n        acr = acr < _expectedLiquityProtocolRate ? _expectedLiquityProtocolRate : acr;\n\n        // Includes requested debt and adoption contribution which covers also liquity protocol fee\n        uint256 expectedDebtToRepay = _LUSDRequestedAmount * acr / DECIMAL_PRECISION + _LUSDRequestedAmount;\n\n        // = x / ( 1 + fee rate<0.005 - 0.05> )\n        neededLiquityLUSDAmount = DECIMAL_PRECISION * expectedDebtToRepay / ( DECIMAL_PRECISION + _expectedLiquityProtocolRate ); \n\n        require(neededLiquityLUSDAmount >= _LUSDRequestedAmount, \"Cannot mint less than requested.\");\n    }\n\n    /// @notice Calculates adjusted Adoption Contribution Rate decreased by RCCAR down to min 0.\n    /// @param _rccar Recognised Community Contributor Acknowledgement Rate in uint16 form (xxyy defines xx.yy % points).\n    /// @param _adoptionContributionRate Adoption Contribution Rate in uint16 form (xxyy defines xx.yy %).\n    function applyRccarOnAcr(uint16 _rccar, uint16 _adoptionContributionRate) internal pure returns (\n        uint16 adjustedAcr\n    ) {\n        return (_adoptionContributionRate > _rccar ? _adoptionContributionRate - _rccar : 0);\n    }\n}\n"
    },
    "contracts/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Adapted from OpenZeppelin Contracts v4.4.0 (access/Ownable.sol)\r\n// Using less gas and initiating the first owner to the provided multisig address\r\n\r\npragma solidity ^0.8.10;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one provided during the deployment of the contract. \r\n * This can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable {\r\n\r\n    /**\r\n     * @dev Address of the current owner. \r\n     */\r\n    address public owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @param _firstOwner Initial owner\r\n     * @dev Initializes the contract setting the initial owner.\r\n     */\r\n    constructor(address _firstOwner) {\r\n        _transferOwnership(_firstOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address _newOwner) public virtual onlyOwner {\r\n        require(_newOwner != address(0), \"Ownable: cannot be zero address\");\r\n        _transferOwnership(_newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address _newOwner) internal virtual {\r\n        address oldOwner = owner;\r\n        owner = _newOwner;\r\n        emit OwnershipTransferred(oldOwner, _newOwner);\r\n    }\r\n}\r\n"
    },
    "contracts/Registry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.10;\n\nimport \"./Ownable.sol\";\n\n/// @title Registry contract for whole Apus ecosystem\n/// @notice Holds addresses of all essential Apus contracts\ncontract Registry is Ownable {\n\n\t/// @notice Stores address under its id\n\t/// @dev Id is keccak256 hash of its string representation\n\tmapping (bytes32 => address) public addresses;\n\n\t/// @notice Emit when owner registers address\n\t/// @param id Keccak256 hash of its string id representation\n\t/// @param previousAddress Previous address value under given id\n\t/// @param newAddress New address under given id\n\tevent AddressRegistered(bytes32 indexed id, address indexed previousAddress, address indexed newAddress);\n\n\t/* solhint-disable-next-line no-empty-blocks */\n\tconstructor(address _initialOwner) Ownable(_initialOwner) {\n\n\t}\n\n\n\t/// @notice Getter for registered addresses\n\t/// @dev Returns zero address if address have not been registered before\n\t/// @param _id Registered address identifier\n\tfunction getAddress(bytes32 _id) external view returns(address) {\n\t\treturn addresses[_id];\n\t}\n\n\n\t/// @notice Register address under given id\n\t/// @dev Only owner can register addresses\n\t/// @dev Emits `AddressRegistered` event\n\t/// @param _id Keccak256 hash of its string id representation\n\t/// @param _address Registering address\n\tfunction registerAddress(bytes32 _id, address _address) public onlyOwner {\n\t\trequire(_address != address(0), \"Can't register 0x0 address\");\n\t\taddress _previousAddress = addresses[_id];\n\t\taddresses[_id] = _address;\n\t\temit AddressRegistered(_id, _previousAddress, _address);\n\t}\n\n\t/// @notice Register list of addresses under given list of ids\n\t/// @dev Only owner can register addresses\n\t/// @dev Emits `AddressRegistered` event for every address\n\t/// @param _ids List of keccak256 hashes of its string id representation\n\t/// @param _addresses List of registering addresses\n\tfunction batchRegisterAddresses(bytes32[] calldata _ids, address[] calldata _addresses) external onlyOwner {\n\t\trequire(_ids.length == _addresses.length, \"Lists do not match in length\");\n\n\t\tfor (uint256 i = 0; i < _ids.length; i++) {\n\t\t\tregisterAddress(_ids[i], _addresses[i]);\n\t\t}\n\t}\n}\n"
    },
    "contracts/dapphub/DSAuth.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.10;\n\nimport \"./DSAuthority.sol\";\n\ncontract DSAuthEvents {\n    event LogSetAuthority(address indexed authority);\n    event LogSetOwner(address indexed owner);\n}\n\nabstract contract DSAuth is DSAuthEvents {\n    DSAuthority public authority;\n    address public owner;\n\n    constructor() {\n        owner = msg.sender;\n        emit LogSetOwner(msg.sender);\n    }\n\n    function setOwner(address owner_) public virtual;\n\n    function setAuthority(DSAuthority authority_) public virtual;\n\n    function isAuthorized(address src, bytes4 sig) internal view virtual returns (bool);\n}\n"
    },
    "contracts/dapphub/DSAuthority.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.10;\n\nabstract contract DSAuthority {\n    function canCall(\n        address src,\n        address dst,\n        bytes4 sig\n    ) public view virtual returns (bool);\n}\n"
    },
    "contracts/dapphub/DSProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.10;\n\nimport \"./DSAuth.sol\";\n\nabstract contract DSProxy is DSAuth {\n    DSProxyCache public cache; // global cache for contracts\n\n    constructor(address _cacheAddr) {\n        require(setCache(_cacheAddr), \"Cache not set\");\n    }\n\n    // solhint-disable-next-line no-empty-blocks\n    receive() external payable {}\n\n    // use the proxy to execute calldata _data on contract _code\n    function execute(bytes memory _code, bytes memory _data)\n        public\n        payable\n        virtual\n        returns (address target, bytes32 response);\n\n    function execute(address _target, bytes memory _data)\n        public\n        payable\n        virtual\n        returns (bytes32 response);\n\n    //set new cache\n    function setCache(address _cacheAddr) public payable virtual returns (bool);\n}\n\nabstract contract DSProxyCache {\n    mapping(bytes32 => address) cache;\n\n    function read(bytes memory _code) public view virtual returns (address);\n\n    function write(bytes memory _code) public virtual returns (address target);\n}\n"
    },
    "contracts/dapphub/DSProxyFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.10;\n\nimport \"./DSProxy.sol\";\n\nabstract contract DSProxyFactory {\n    function build(address owner) public virtual returns (DSProxy proxy);\n    function build() public virtual returns (DSProxy proxy);\n    function isProxy(address proxy) public virtual view returns (bool);\n}\n"
    },
    "contracts/interfaces/IBorrowerOperations.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.10;\n\n// Common interface for the Liquity Trove management.\ninterface IBorrowerOperations {\n\n    // --- Events ---\n\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event ActivePoolAddressChanged(address _activePoolAddress);\n    event DefaultPoolAddressChanged(address _defaultPoolAddress);\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\n    event GasPoolAddressChanged(address _gasPoolAddress);\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\n    event PriceFeedAddressChanged(address  _newPriceFeedAddress);\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\n    event LUSDTokenAddressChanged(address _lusdTokenAddress);\n    event LQTYStakingAddressChanged(address _lqtyStakingAddress);\n\n    event TroveCreated(address indexed _borrower, uint arrayIndex);\n    event TroveUpdated(address indexed _borrower, uint _debt, uint _coll, uint stake, uint8 operation);\n    event LUSDBorrowingFeePaid(address indexed _borrower, uint _LUSDFee);\n\n    // --- Functions ---\n\n    function openTrove(uint _maxFee, uint _LUSDAmount, address _upperHint, address _lowerHint) external payable;\n\n    function addColl(address _upperHint, address _lowerHint) external payable;\n\n    function moveETHGainToTrove(address _user, address _upperHint, address _lowerHint) external payable;\n\n    function withdrawColl(uint _amount, address _upperHint, address _lowerHint) external;\n\n    function withdrawLUSD(uint _maxFee, uint _amount, address _upperHint, address _lowerHint) external;\n\n    function repayLUSD(uint _amount, address _upperHint, address _lowerHint) external;\n\n    function closeTrove() external;\n\n    function adjustTrove(uint _maxFee, uint _collWithdrawal, uint _debtChange, bool isDebtIncrease, address _upperHint, address _lowerHint) external payable;\n\n    function claimCollateral() external;\n\n    function getCompositeDebt(uint _debt) external pure returns (uint);\n}\n"
    },
    "contracts/interfaces/ICollSurplusPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.10;\n\n\ninterface ICollSurplusPool {\n\n    // --- Events ---\n    \n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\n\n    event CollBalanceUpdated(address indexed _account, uint _newBalance);\n    event EtherSent(address _to, uint _amount);\n\n    // --- Contract setters ---\n\n    function setAddresses(\n        address _borrowerOperationsAddress,\n        address _troveManagerAddress,\n        address _activePoolAddress\n    ) external;\n\n    function getETH() external view returns (uint);\n\n    function getCollateral(address _account) external view returns (uint);\n\n    function accountSurplus(address _account, uint _amount) external;\n\n    function claimColl(address _account) external;\n}\n"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\n/**\n * Based on the OpenZeppelin IER20 interface:\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol\n *\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    \n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}"
    },
    "contracts/interfaces/IERC2612.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\n/**\n * @dev Interface of the ERC2612 standard as defined in the EIP.\n *\n * Adds the {permit} method, which can be used to change one's\n * {IERC20-allowance} without having to send a transaction, by signing a\n * message. This allows users to spend tokens without having to hold Ether.\n *\n * See https://eips.ethereum.org/EIPS/eip-2612.\n * \n * Code adapted from https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2237/\n */\ninterface IERC2612 {\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over `owner`'s tokens,\n     * given `owner`'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(address owner, address spender, uint256 amount, \n                    uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\n    \n    /**\n     * @dev Returns the current ERC2612 nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases `owner`'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     *\n     * `owner` can limit the time a Permit is valid for by setting `deadline` to \n     * a value in the near future. The deadline argument can be set to uint(-1) to \n     * create Permits that effectively never expire.\n     */\n    function nonces(address owner) external view returns (uint256);\n    \n    function version() external view returns (string memory);\n    function permitTypeHash() external view returns (bytes32);\n    function domainSeparator() external view returns (bytes32);\n}\n"
    },
    "contracts/interfaces/ILUSDToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\nimport \"./IERC20.sol\";\nimport \"./IERC2612.sol\";\n\ninterface ILUSDToken is IERC20, IERC2612 { \n    \n    // --- Events ---\n\n    event TroveManagerAddressChanged(address _troveManagerAddress);\n    event StabilityPoolAddressChanged(address _newStabilityPoolAddress);\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\n\n    event LUSDTokenBalanceUpdated(address _user, uint _amount);\n\n    // --- Functions ---\n\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\n\n    function mint(address _account, uint256 _amount) external;\n\n    function burn(address _account, uint256 _amount) external;\n\n    function sendToPool(address _sender,  address poolAddress, uint256 _amount) external;\n\n    function returnFromPool(address poolAddress, address user, uint256 _amount ) external;\n}\n"
    },
    "contracts/interfaces/IPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.10;\n\ninterface IPriceFeed {\n\n    // --- Events ---\n    event LastGoodPriceUpdated(uint _lastGoodPrice);\n   \n    // --- Function ---\n    function fetchPrice() external returns (uint);\n\n    // Getter for the last good price seen from an oracle by Liquity\n    function lastGoodPrice() external view returns (uint);\n\n}\n"
    },
    "contracts/interfaces/ITroveManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.10;\n\n\n// Common interface for the Trove Manager.\ninterface ITroveManager {\n    \n    // --- Events ---\n\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\n    event PriceFeedAddressChanged(address _newPriceFeedAddress);\n    event LUSDTokenAddressChanged(address _newLUSDTokenAddress);\n    event ActivePoolAddressChanged(address _activePoolAddress);\n    event DefaultPoolAddressChanged(address _defaultPoolAddress);\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\n    event GasPoolAddressChanged(address _gasPoolAddress);\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\n    event LQTYTokenAddressChanged(address _lqtyTokenAddress);\n    event LQTYStakingAddressChanged(address _lqtyStakingAddress);\n\n    event Liquidation(uint _liquidatedDebt, uint _liquidatedColl, uint _collGasCompensation, uint _LUSDGasCompensation);\n    event Redemption(uint _attemptedLUSDAmount, uint _actualLUSDAmount, uint _ETHSent, uint _ETHFee);\n    event TroveUpdated(address indexed _borrower, uint _debt, uint _coll, uint stake, uint8 operation);\n    event TroveLiquidated(address indexed _borrower, uint _debt, uint _coll, uint8 operation);\n    event BaseRateUpdated(uint _baseRate);\n    event LastFeeOpTimeUpdated(uint _lastFeeOpTime);\n    event TotalStakesUpdated(uint _newTotalStakes);\n    event SystemSnapshotsUpdated(uint _totalStakesSnapshot, uint _totalCollateralSnapshot);\n    event LTermsUpdated(uint _L_ETH, uint _L_LUSDDebt);\n    event TroveSnapshotsUpdated(uint _L_ETH, uint _L_LUSDDebt);\n    event TroveIndexUpdated(address _borrower, uint _newIndex);\n\n    function getTroveOwnersCount() external view returns (uint);\n\n    function getTroveFromTroveOwnersArray(uint _index) external view returns (address);\n\n    function getNominalICR(address _borrower) external view returns (uint);\n    function getCurrentICR(address _borrower, uint _price) external view returns (uint);\n\n    function liquidate(address _borrower) external;\n\n    function liquidateTroves(uint _n) external;\n\n    function batchLiquidateTroves(address[] calldata _troveArray) external;\n\n    function redeemCollateral(\n        uint _LUSDAmount,\n        address _firstRedemptionHint,\n        address _upperPartialRedemptionHint,\n        address _lowerPartialRedemptionHint,\n        uint _partialRedemptionHintNICR,\n        uint _maxIterations,\n        uint _maxFee\n    ) external; \n\n    function updateStakeAndTotalStakes(address _borrower) external returns (uint);\n\n    function updateTroveRewardSnapshots(address _borrower) external;\n\n    function addTroveOwnerToArray(address _borrower) external returns (uint index);\n\n    function applyPendingRewards(address _borrower) external;\n\n    function getPendingETHReward(address _borrower) external view returns (uint);\n\n    function getPendingLUSDDebtReward(address _borrower) external view returns (uint);\n\n     function hasPendingRewards(address _borrower) external view returns (bool);\n\n    function getEntireDebtAndColl(address _borrower) external view returns (\n        uint debt, \n        uint coll, \n        uint pendingLUSDDebtReward, \n        uint pendingETHReward\n    );\n\n    function closeTrove(address _borrower) external;\n\n    function removeStake(address _borrower) external;\n\n    function getRedemptionRate() external view returns (uint);\n    function getRedemptionRateWithDecay() external view returns (uint);\n\n    function getRedemptionFeeWithDecay(uint _ETHDrawn) external view returns (uint);\n\n    function getBorrowingRate() external view returns (uint);\n    function getBorrowingRateWithDecay() external view returns (uint);\n\n    function getBorrowingFee(uint LUSDDebt) external view returns (uint);\n    function getBorrowingFeeWithDecay(uint _LUSDDebt) external view returns (uint);\n\n    function decayBaseRateFromBorrowing() external;\n\n    function getTroveStatus(address _borrower) external view returns (uint);\n    \n    function getTroveStake(address _borrower) external view returns (uint);\n\n    function getTroveDebt(address _borrower) external view returns (uint);\n\n    function getTroveColl(address _borrower) external view returns (uint);\n\n    function setTroveStatus(address _borrower, uint num) external;\n\n    function increaseTroveColl(address _borrower, uint _collIncrease) external returns (uint);\n\n    function decreaseTroveColl(address _borrower, uint _collDecrease) external returns (uint); \n\n    function increaseTroveDebt(address _borrower, uint _debtIncrease) external returns (uint); \n\n    function decreaseTroveDebt(address _borrower, uint _collDecrease) external returns (uint); \n\n    function getTCR(uint _price) external view returns (uint);\n\n    function checkRecoveryMode(uint _price) external view returns (bool);\n\n    function Troves(address) external view returns (uint256, uint256, uint256, uint8, uint128); \n}\n"
    }
  }
}}