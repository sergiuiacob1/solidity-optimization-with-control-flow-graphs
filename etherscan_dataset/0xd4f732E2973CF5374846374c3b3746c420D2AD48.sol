{{
  "language": "Solidity",
  "sources": {
    "BNPLFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"Ownable.sol\";\nimport \"Initializable.sol\";\nimport \"OwnableUpgradeable.sol\";\nimport \"BankingNode.sol\";\nimport \"TransferHelper.sol\";\n\n//CUSTOM ERRORS\n\n//occurs when trying to create a node without a whitelisted baseToken\nerror InvalidBaseToken();\n//occurs when a user tries to set up a second node from same account\nerror OneNodePerAccountOnly();\n\ncontract BNPLFactory is Initializable, OwnableUpgradeable {\n\n    mapping(address => address) public operatorToNode;\n    address[] public bankingNodesList;\n    address public BNPL;\n    address public lendingPoolAddressesProvider;\n    address public WETH;\n    address public uniswapFactory;\n    mapping(address => bool) public approvedBaseTokens;\n    address public aaveDistributionController;\n\n    event NewNode(address indexed _operator, address indexed _node);\n\n    /**\n     * Upgradeable contracts uses an initializer function instead of a constructor\n     * Reference: https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#initializers\n    */\n    function initialize(\n        address _BNPL,\n        address _lendingPoolAddressesProvider,\n        address _WETH,\n        address _aaveDistributionController,\n        address _uniswapFactory\n    ) public initializer {\n        __Ownable_init();\n\n        BNPL = _BNPL;\n        lendingPoolAddressesProvider = _lendingPoolAddressesProvider;\n        WETH = _WETH;\n        aaveDistributionController = _aaveDistributionController;\n        uniswapFactory = _uniswapFactory;\n    }\n\n    //STATE CHANGING FUNCTIONS\n\n    /**\n     * Creates a new banking node\n     */\n    function createNewNode(\n        address _baseToken,\n        bool _requireKYC,\n        uint256 _gracePeriod\n    ) external returns (address node) {\n        //collect the 2M BNPL\n        uint256 bondAmount = 0x1A784379D99DB42000000; //2M BNPL to bond a node\n        address _bnpl = BNPL;\n        TransferHelper.safeTransferFrom(\n            _bnpl,\n            msg.sender,\n            address(this),\n            bondAmount\n        );\n        //one node per operator and base token must be approved\n        if (!approvedBaseTokens[_baseToken]) {\n            revert InvalidBaseToken();\n        }\n        if (operatorToNode[msg.sender] != address(0)) {\n            revert OneNodePerAccountOnly();\n        }\n        //create a new node\n        bytes memory bytecode = type(BankingNode).creationCode;\n        bytes32 salt = keccak256(\n            abi.encodePacked(_baseToken, _requireKYC, _gracePeriod, msg.sender)\n        );\n        assembly {\n            node := create2(0, add(bytecode, 32), mload(bytecode), salt)\n        }\n        BankingNode(node).initialize(\n            _baseToken,\n            _bnpl,\n            _requireKYC,\n            msg.sender,\n            _gracePeriod,\n            lendingPoolAddressesProvider,\n            WETH,\n            aaveDistributionController,\n            uniswapFactory\n        );\n\n        bankingNodesList.push(node);\n        operatorToNode[msg.sender] = node;\n        \n        TransferHelper.safeApprove(_bnpl, node, bondAmount);\n        BankingNode(node).stake(bondAmount);\n    }\n\n    //ONLY OWNER FUNCTIONS\n\n    /**\n     * Whitelist or Delist a base token for banking nodes(e.g. USDC)\n     */\n    function whitelistToken(address _baseToken, bool _status)\n        external\n        onlyOwner\n    {\n        if (_baseToken == BNPL) {\n            revert InvalidBaseToken();\n        }\n        approvedBaseTokens[_baseToken] = _status;\n    }\n\n    /**\n     * Get number of current nodes\n     */\n    function bankingNodeCount() external view returns (uint256) {\n        return bankingNodesList.length;\n    }\n}\n"
    },
    "Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = _setInitializedVersion(1);\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\n     * initialization.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     */\n    modifier reinitializer(uint8 version) {\n        bool isTopLevelCall = _setInitializedVersion(version);\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(version);\n        }\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     */\n    function _disableInitializers() internal virtual {\n        _setInitializedVersion(type(uint8).max);\n    }\n\n    function _setInitializedVersion(uint8 version) private returns (bool) {\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\n        // inheritance patterns, but we only do this in the context of a constructor, and for the lowest level\n        // of initializers, because in other contexts the contract may have been reentered.\n        if (_initializing) {\n            require(\n                version == 1 && !AddressUpgradeable.isContract(address(this)),\n                \"Initializable: contract is already initialized\"\n            );\n            return false;\n        } else {\n            require(_initialized < version, \"Initializable: contract is already initialized\");\n            _initialized = version;\n            return true;\n        }\n    }\n}\n"
    },
    "AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"ContextUpgradeable.sol\";\nimport \"Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "BankingNode.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// NOTE: BankingNode.sol should only be created through the BNPLFactory contract to\n// ensure compatibility of baseToken and minimum bond amounts. Before interacting,\n// please ensure that the contract deployer was BNPLFactory.sol\n\npragma solidity ^0.8.0;\n\nimport \"ERC20.sol\";\nimport \"Pausable.sol\";\nimport \"ReentrancyGuard.sol\";\nimport \"ILendingPool.sol\";\nimport \"ILendingPoolAddressesProvider.sol\";\nimport \"IAaveIncentivesController.sol\";\nimport \"UniswapV2Library.sol\";\nimport \"TransferHelper.sol\";\n\n//CUSTOM ERRORS\n\n//occurs when trying to do privledged functions\nerror InvalidUser(address requiredUser);\n//occurs when users try to add funds if node operator hasn't maintaioned enough pledged BNPL\nerror NodeInactive();\n//occurs when trying to interact without being KYC's (if node requires it)\nerror KYCNotApproved();\n//occurs when trying to pay loans that are completed or not started\nerror NoPrincipalRemaining();\n//occurs when trying to swap/deposit/withdraw a zero\nerror ZeroInput();\n//occurs if interest rate, loanAmount, or paymentInterval or is applied as 0\nerror InvalidLoanInput();\n//occurs if trying to apply for a loan with >5 year loan length\nerror MaximumLoanDurationExceeded();\n//occurs if user tries to withdraw collateral while loan is still ongoing\nerror LoanStillOngoing();\n//edge case occurence if all BNPL is slashed, but there are still BNPL shares\nerror DonationRequired();\n//occurs if operator tries to unstake while there are active loans\nerror ActiveLoansOngoing();\n//occurs when trying to withdraw too much funds\nerror InsufficientBalance();\n//occurs during swaps, if amount received is lower than minOut (slippage tolerance exceeded)\nerror InsufficentOutput();\n//occurs if trying to approve a loan that has already started\nerror LoanAlreadyStarted();\n//occurs if trying to approve a loan without enough collateral posted\nerror InsufficientCollateral();\n//occurs when trying to slash a loan that is not yet considered defaulted\nerror LoanNotExpired();\n//occurs is trying to slash an already slashed loan\nerror LoanAlreadySlashed();\n//occurs if trying to withdraw staked BNPL where 7 day unbonding hasnt passed\nerror LoanStillUnbonding();\n//occurs if trying to post baseToken as collateral\nerror InvalidCollateral();\n//first deposit to prevent edge case must be at least 10M wei\nerror InvalidInitialDeposit();\n\ncontract BankingNode is ERC20(\"BNPL USD\", \"pUSD\") {\n    //Node specific variables\n    address public operator;\n    address public baseToken; //base liquidity token, e.g. USDT or USDC\n    uint256 public gracePeriod;\n    bool public requireKYC;\n\n    //variables used for swaps, private to reduce contract size\n    address private uniswapFactory;\n    address private WETH;\n    uint256 private incrementor;\n\n    //constants set by factory\n    address public BNPL;\n    ILendingPoolAddressesProvider public lendingPoolProvider;\n    address public immutable bnplFactory;\n    //used by treasury can be private\n    IAaveIncentivesController private aaveRewardController;\n    address private treasury;\n\n    //For loans\n    mapping(uint256 => Loan) public idToLoan;\n    uint256[] public pendingRequests;\n    uint256[] public currentLoans;\n    mapping(uint256 => uint256) defaultedLoans;\n    uint256 public defaultedLoanCount;\n\n    //For Staking, Slashing and Balances\n    uint256 public accountsReceiveable;\n    mapping(address => bool) public whitelistedAddresses;\n    mapping(address => uint256) public unbondBlock;\n    mapping(uint256 => address) public loanToAgent;\n    uint256 public slashingBalance;\n    mapping(address => uint256) public stakingShares;\n    //can be private as there is a getter function for staking balance\n    uint256 public totalStakingShares;\n\n    uint256 public unbondingAmount;\n    mapping(address => uint256) public unbondingShares;\n    //can be private as there is getter function for unbonding balance\n    uint256 private totalUnbondingShares;\n    uint256 public timeCreated;\n\n    //For Collateral in loans\n    mapping(address => uint256) public collateralOwed;\n\n    struct Loan {\n        address borrower;\n        bool interestOnly; //interest only or principal + interest\n        uint256 loanStartTime; //unix timestamp of start\n        uint256 loanAmount;\n        uint256 paymentInterval; //unix interval of payment (e.g. monthly = 2,628,000)\n        uint256 interestRate; //interest rate per peiod * 10000, e.g., 10% on a 12 month loan = : 0.1 * 10000 / 12 = 83\n        uint256 numberOfPayments;\n        uint256 principalRemaining;\n        uint256 paymentsMade;\n        address collateral;\n        uint256 collateralAmount;\n        bool isSlashed;\n    }\n\n    //EVENTS\n    event LoanRequest(uint256 loanId, string message);\n    event collateralWithdrawn(\n        uint256 loanId,\n        address collateral,\n        uint256 collateralAmount\n    );\n    event approvedLoan(uint256 loanId);\n    event loanPaymentMade(uint256 loanId);\n    event loanRepaidEarly(uint256 loanId);\n    event baseTokenDeposit(address user, uint256 amount);\n    event baseTokenWithdrawn(address user, uint256 amount);\n    event feesCollected(uint256 operatorFees, uint256 stakerFees);\n    event baseTokensDonated(uint256 amount);\n    event loanSlashed(uint256 loanId);\n    event slashingSale(uint256 bnplSold, uint256 baseTokenRecovered);\n    event bnplStaked(address user, uint256 bnplStaked);\n    event unbondingInitiated(address user, uint256 unbondAmount);\n    event bnplWithdrawn(address user, uint256 bnplWithdrawn);\n    event KYCRequirementChanged(bool newStatus);\n\n    constructor() {\n        bnplFactory = msg.sender;\n    }\n\n    // MODIFIERS\n\n    /**\n     * Ensure a node is active for deposit, stake functions\n     * Require KYC is also batched in\n     */\n    modifier ensureNodeActive() {\n        address _operator = operator;\n        if (msg.sender != bnplFactory && msg.sender != _operator) {\n            if (getBNPLBalance(_operator) < 0x13DA329B6336471800000) {\n                revert NodeInactive();\n            }\n            if (requireKYC && whitelistedAddresses[msg.sender] == false) {\n                revert KYCNotApproved();\n            }\n        }\n        _;\n    }\n\n    /**\n     * Ensure that the loan has principal to be paid\n     */\n    modifier ensurePrincipalRemaining(uint256 loanId) {\n        if (idToLoan[loanId].principalRemaining == 0) {\n            revert NoPrincipalRemaining();\n        }\n        _;\n    }\n\n    /**\n     * For operator only functions\n     */\n    modifier operatorOnly() {\n        address _operator = operator;\n        if (msg.sender != _operator) {\n            revert InvalidUser(_operator);\n        }\n        _;\n    }\n\n    /**\n     * Requires input value to be non-zero\n     */\n    modifier nonZeroInput(uint256 input) {\n        if (input == 0) {\n            revert ZeroInput();\n        }\n        _;\n    }\n\n    /**\n     * Ensures collateral is not the baseToken\n     */\n    modifier nonBaseToken(address collateral) {\n        if (collateral == baseToken) {\n            revert InvalidCollateral();\n        }\n        _;\n    }\n\n    //STATE CHANGING FUNCTIONS\n\n    /**\n     * Called once by the factory at time of deployment\n     */\n    function initialize(\n        address _baseToken,\n        address _BNPL,\n        bool _requireKYC,\n        address _operator,\n        uint256 _gracePeriod,\n        address _lendingPoolProvider,\n        address _WETH,\n        address _aaveDistributionController,\n        address _uniswapFactory\n    ) external {\n        //only to be done by factory, no need for error msgs in here as not used by users\n        require(msg.sender == bnplFactory);\n        baseToken = _baseToken;\n        BNPL = _BNPL;\n        requireKYC = _requireKYC;\n        operator = _operator;\n        gracePeriod = _gracePeriod;\n        lendingPoolProvider = ILendingPoolAddressesProvider(\n            _lendingPoolProvider\n        );\n        aaveRewardController = IAaveIncentivesController(\n            _aaveDistributionController\n        );\n        WETH = _WETH;\n        uniswapFactory = _uniswapFactory;\n        treasury = address(0x27a99802FC48b57670846AbFFf5F2DcDE8a6fC29);\n        timeCreated = block.timestamp;\n        //decimal check on baseToken and aToken to make sure math logic on future steps\n        require(\n            ERC20(_baseToken).decimals() ==\n                ERC20(\n                    _getLendingPool().getReserveData(_baseToken).aTokenAddress\n                ).decimals()\n        );\n    }\n\n    /**\n     * Request a loan from the banking node\n     * Saves the loan with the operator able to approve or reject\n     * Can post collateral if chosen, collateral accepted is anything that is accepted by aave\n     * Collateral can not be the same token as baseToken\n     */\n    function requestLoan(\n        uint256 loanAmount,\n        uint256 paymentInterval,\n        uint256 numberOfPayments,\n        uint256 interestRate,\n        bool interestOnly,\n        address collateral,\n        uint256 collateralAmount,\n        address agent,\n        string memory message\n    )\n        external\n        ensureNodeActive\n        nonBaseToken(collateral)\n        returns (uint256 requestId)\n    {\n        if (\n            loanAmount < 10000000 ||\n            paymentInterval == 0 ||\n            interestRate == 0 ||\n            numberOfPayments == 0\n        ) {\n            revert InvalidLoanInput();\n        }\n        //157,680,000 seconds in 5 years\n        if (paymentInterval * numberOfPayments > 157680000) {\n            revert MaximumLoanDurationExceeded();\n        }\n        requestId = incrementor;\n        incrementor++;\n        pendingRequests.push(requestId);\n        idToLoan[requestId] = Loan(\n            msg.sender, //set borrower\n            interestOnly,\n            0, //start time initiated to 0\n            loanAmount,\n            paymentInterval, //interval of payments (e.g. Monthly)\n            interestRate, //annualized interest rate per period * 10000 (e.g. 12 month loan 10% = 83)\n            numberOfPayments,\n            0, //initalize principalRemaining to 0\n            0, //intialize paymentsMade to 0\n            collateral,\n            collateralAmount,\n            false\n        );\n        //post the collateral if any\n        if (collateralAmount > 0) {\n            //update the collateral owed (interest accrued on collateral is given to lend)\n            collateralOwed[collateral] += collateralAmount;\n            TransferHelper.safeTransferFrom(\n                collateral,\n                msg.sender,\n                address(this),\n                collateralAmount\n            );\n            //deposit the collateral in AAVE to accrue interest\n            _depositToLendingPool(collateral, collateralAmount);\n        }\n        //save the agent of the loan\n        loanToAgent[requestId] = agent;\n\n        emit LoanRequest(requestId, message);\n    }\n\n    /**\n     * Withdraw the collateral from a loan\n     * Loan must have no principal remaining (not approved, or payments finsihed)\n     */\n    function withdrawCollateral(uint256 loanId) external {\n        Loan storage loan = idToLoan[loanId];\n        address collateral = loan.collateral;\n        uint256 amount = loan.collateralAmount;\n\n        //must be the borrower or operator to withdraw, and loan must be either paid/not initiated\n        if (msg.sender != loan.borrower) {\n            revert InvalidUser(loan.borrower);\n        }\n        if (loan.principalRemaining > 0) {\n            revert LoanStillOngoing();\n        }\n\n        //update the amounts\n        collateralOwed[collateral] -= amount;\n        loan.collateralAmount = 0;\n\n        //no need to check if loan is slashed as collateral amont set to 0 on slashing\n        _withdrawFromLendingPool(collateral, amount, loan.borrower);\n        emit collateralWithdrawn(loanId, collateral, amount);\n    }\n\n    /**\n     * Collect AAVE rewards to be sent to the treasury\n     */\n    function collectAaveRewards(address[] calldata assets) external {\n        uint256 rewardAmount = aaveRewardController.getUserUnclaimedRewards(\n            address(this)\n        );\n        address _treasuy = treasury;\n        if (rewardAmount == 0) {\n            revert ZeroInput();\n        }\n        //claim rewards to the treasury\n        aaveRewardController.claimRewards(assets, rewardAmount, _treasuy);\n        //no need for event as its a function that will only be used by treasury\n    }\n\n    /**\n     * Collect the interest earnt on collateral posted to distribute to stakers\n     * Collateral can not be the same as baseToken\n     */\n    function collectCollateralFees(address collateral)\n        external\n        nonBaseToken(collateral)\n    {\n        //get the aToken address\n        ILendingPool lendingPool = _getLendingPool();\n        address _bnpl = BNPL;\n        uint256 feesAccrued = IERC20(\n            lendingPool.getReserveData(collateral).aTokenAddress\n        ).balanceOf(address(this)) - collateralOwed[collateral];\n        //ensure there is collateral to collect inside of _swap\n        lendingPool.withdraw(collateral, feesAccrued, address(this));\n        //no slippage for small swaps\n        _swapToken(collateral, _bnpl, 0, feesAccrued);\n    }\n\n    /*\n     * Make a loan payment\n     */\n    function makeLoanPayment(uint256 loanId)\n        external\n        ensurePrincipalRemaining(loanId)\n    {\n        Loan storage loan = idToLoan[loanId];\n        uint256 paymentAmount = getNextPayment(loanId);\n        uint256 interestPortion = (loan.principalRemaining *\n            loan.interestRate) / 10000;\n        address _baseToken = baseToken;\n        loan.paymentsMade++;\n        //reduce accounts receiveable and loan principal if principal + interest payment\n        bool finalPayment = loan.paymentsMade == loan.numberOfPayments;\n\n        if (!loan.interestOnly) {\n            uint256 principalPortion = paymentAmount - interestPortion;\n            loan.principalRemaining -= principalPortion;\n            accountsReceiveable -= principalPortion;\n        } else {\n            //interest only, principal change only on final payment\n            if (finalPayment) {\n                accountsReceiveable -= loan.principalRemaining;\n                loan.principalRemaining = 0;\n            }\n        }\n        //make payment\n        TransferHelper.safeTransferFrom(\n            _baseToken,\n            msg.sender,\n            address(this),\n            paymentAmount\n        );\n        //deposit the tokens into AAVE on behalf of the pool contract, withholding 30% and the interest as baseToken\n        _depositToLendingPool(\n            _baseToken,\n            paymentAmount - ((interestPortion * 3) / 10)\n        );\n        //remove if final payment\n        if (finalPayment) {\n            _removeCurrentLoan(loanId);\n        }\n        //increment the loan status\n\n        emit loanPaymentMade(loanId);\n    }\n\n    /**\n     * Repay remaining balance to save on interest cost\n     * Payment amount is remaining principal + 1 period of interest\n     */\n    function repayEarly(uint256 loanId)\n        external\n        ensurePrincipalRemaining(loanId)\n    {\n        Loan storage loan = idToLoan[loanId];\n        uint256 principalLeft = loan.principalRemaining;\n        //make a payment of remaining principal + 1 period of interest\n        uint256 interestAmount = (principalLeft * loan.interestRate) / 10000;\n        uint256 paymentAmount = principalLeft + interestAmount;\n        address _baseToken = baseToken;\n\n        //update accounts\n        accountsReceiveable -= principalLeft;\n        loan.principalRemaining = 0;\n        //increment the loan status to final and remove from current loans array\n        loan.paymentsMade = loan.numberOfPayments;\n        _removeCurrentLoan(loanId);\n\n        //make payment\n        TransferHelper.safeTransferFrom(\n            _baseToken,\n            msg.sender,\n            address(this),\n            paymentAmount\n        );\n        //deposit withholding 30% of the interest as fees\n        _depositToLendingPool(\n            _baseToken,\n            paymentAmount - ((interestAmount * 3) / 10)\n        );\n\n        emit loanRepaidEarly(loanId);\n    }\n\n    /**\n     * Converts the baseToken (e.g. USDT) 20% BNPL for stakers, and sends 10% to the Banking Node Operator\n     * Slippage set to 0 here as they would be small purchases of BNPL\n     */\n    function collectFees() external {\n        //requirement check for nonzero inside of _swap\n        //33% to go to operator as baseToken\n        address _baseToken = baseToken;\n        address _bnpl = BNPL;\n        address _operator = operator;\n        uint256 _operatorFees = IERC20(_baseToken).balanceOf(address(this)) / 3;\n        TransferHelper.safeTransfer(_baseToken, _operator, _operatorFees);\n        //remainder (67%) is traded for staking rewards\n        //no need for slippage on small trade\n        uint256 _stakingRewards = _swapToken(\n            _baseToken,\n            _bnpl,\n            0,\n            IERC20(_baseToken).balanceOf(address(this))\n        );\n        emit feesCollected(_operatorFees, _stakingRewards);\n    }\n\n    /**\n     * Deposit liquidity to the banking node in the baseToken (e.g. usdt) specified\n     * Mints tokens, with check on decimals of base tokens\n     */\n    function deposit(uint256 _amount)\n        external\n        ensureNodeActive\n        nonZeroInput(_amount)\n    {\n        //First deposit must be at least 10M wei to prevent initial attack\n        if (getTotalAssetValue() == 0 && _amount < 10000000) {\n            revert InvalidInitialDeposit();\n        }\n        //check the decimals of the baseTokens\n        address _baseToken = baseToken;\n        uint256 decimalAdjust = 1;\n        uint256 tokenDecimals = ERC20(_baseToken).decimals();\n        if (tokenDecimals != 18) {\n            decimalAdjust = 10**(18 - tokenDecimals);\n        }\n        //get the amount of tokens to mint\n        uint256 what = _amount * decimalAdjust;\n        if (totalSupply() != 0) {\n            //no need to decimal adjust here as total asset value adjusts\n            //unable to deposit if getTotalAssetValue() == 0 and totalSupply() != 0, but this\n            //should never occur as defaults will get slashed for some base token recovery\n            what = (_amount * totalSupply()) / getTotalAssetValue();\n        }\n        //transfer tokens from the user and mint\n        TransferHelper.safeTransferFrom(\n            _baseToken,\n            msg.sender,\n            address(this),\n            _amount\n        );\n        _mint(msg.sender, what);\n\n        _depositToLendingPool(_baseToken, _amount);\n\n        emit baseTokenDeposit(msg.sender, _amount);\n    }\n\n    /**\n     * Withdraw liquidity from the banking node\n     * To avoid need to decimal adjust, input _amount is in USDT(or equiv) to withdraw\n     * , not BNPL USD to burn\n     */\n    function withdraw(uint256 _amount) external nonZeroInput(_amount) {\n        uint256 userBaseBalance = getBaseTokenBalance(msg.sender);\n        if (userBaseBalance < _amount) {\n            revert InsufficientBalance();\n        }\n        //safe div, if _amount > 0, asset value always >0;\n        uint256 what = (_amount * totalSupply()) / getTotalAssetValue();\n        address _baseToken = baseToken;\n        _burn(msg.sender, what);\n        //non-zero revert with checked in \"_withdrawFromLendingPool\"\n        _withdrawFromLendingPool(_baseToken, _amount, msg.sender);\n\n        emit baseTokenWithdrawn(msg.sender, _amount);\n    }\n\n    /**\n     * Stake BNPL into a node\n     */\n    function stake(uint256 _amount)\n        external\n        ensureNodeActive\n        nonZeroInput(_amount)\n    {\n        address staker = msg.sender;\n        //factory initial bond counted as operator\n        if (msg.sender == bnplFactory) {\n            staker = operator;\n        }\n        //calcualte the number of shares to give\n        uint256 what = _amount;\n        uint256 _totalStakingShares = totalStakingShares;\n        if (_totalStakingShares > 0) {\n            //edge case - if totalStakingShares != 0, but all bnpl has been slashed:\n            //node will require a donation to work again\n            uint256 totalStakedBNPL = getStakedBNPL();\n            if (totalStakedBNPL == 0) {\n                revert DonationRequired();\n            }\n            what = (_amount * _totalStakingShares) / totalStakedBNPL;\n        }\n        //collect the BNPL\n        address _bnpl = BNPL;\n        TransferHelper.safeTransferFrom(\n            _bnpl,\n            msg.sender,\n            address(this),\n            _amount\n        );\n        //issue the shares\n        stakingShares[staker] += what;\n        totalStakingShares += what;\n\n        emit bnplStaked(msg.sender, _amount);\n    }\n\n    /**\n     * Unbond BNPL from a node, input is the number shares (sBNPL)\n     * Requires a 7 day unbond to prevent frontrun of slashing events or interest repayments\n     * Operator can not unstake unless there are no loans active\n     */\n    function initiateUnstake(uint256 _amount) external nonZeroInput(_amount) {\n        //operator cannot withdraw unless there are no active loans\n        address _operator = operator;\n        if (msg.sender == _operator && currentLoans.length > 0) {\n            revert ActiveLoansOngoing();\n        }\n        uint256 stakingSharesUser = stakingShares[msg.sender];\n        //require the user has enough\n        if (stakingShares[msg.sender] < _amount) {\n            revert InsufficientBalance();\n        }\n        //set the time of the unbond\n        unbondBlock[msg.sender] = block.number;\n        //get the amount of BNPL to issue back\n        //safe div: if user staking shares >0, totalStakingShares always > 0\n        uint256 what = (_amount * getStakedBNPL()) / totalStakingShares;\n        //subtract the number of shares of BNPL from the user\n        stakingShares[msg.sender] -= _amount;\n        totalStakingShares -= _amount;\n        //initiate as 1:1 for unbonding shares with BNPL sent\n        uint256 _newUnbondingShares = what;\n        uint256 _unbondingAmount = unbondingAmount;\n        //update amount if there is a pool of unbonding\n        if (_unbondingAmount != 0) {\n            _newUnbondingShares =\n                (what * totalUnbondingShares) /\n                _unbondingAmount;\n        }\n        //add the balance to their unbonding\n        unbondingShares[msg.sender] += _newUnbondingShares;\n        totalUnbondingShares += _newUnbondingShares;\n        unbondingAmount += what;\n\n        emit unbondingInitiated(msg.sender, _amount);\n    }\n\n    /**\n     * Withdraw BNPL from a bond once unbond period ends\n     * Unbonding period is 46523 blocks (~7 days assuming a 13s avg. block time)\n     */\n    function unstake() external {\n        uint256 _userAmount = unbondingShares[msg.sender];\n        if (_userAmount == 0) {\n            revert ZeroInput();\n        }\n        //assuming 13s block, 46523 blocks for 1 week\n        if (block.number < unbondBlock[msg.sender] + 46523) {\n            revert LoanStillUnbonding();\n        }\n        uint256 _unbondingAmount = unbondingAmount;\n        uint256 _totalUnbondingShares = totalUnbondingShares;\n        address _bnpl = BNPL;\n        //safe div: if user amount > 0, then totalUnbondingShares always > 0\n        uint256 _what = (_userAmount * _unbondingAmount) /\n            _totalUnbondingShares;\n        //update the balances\n        unbondingShares[msg.sender] = 0;\n        unbondingAmount -= _what;\n        totalUnbondingShares -= _userAmount;\n\n        //transfer the tokens to user\n        TransferHelper.safeTransfer(_bnpl, msg.sender, _what);\n        emit bnplWithdrawn(msg.sender, _what);\n    }\n\n    /**\n     * Declare a loan defaulted and slash the loan\n     * Can be called by anyone\n     * Move BNPL to a slashing balance, to be sold in seperate function\n     * minOut used for sale of collateral, if no collateral, put 0\n     */\n    function slashLoan(uint256 loanId, uint256 minOut)\n        external\n        ensurePrincipalRemaining(loanId)\n    {\n        //Step 1. load loan as local variable\n        Loan storage loan = idToLoan[loanId];\n\n        //Step 2. requirement checks: loan is ongoing and expired past grace period\n        if (loan.isSlashed) {\n            revert LoanAlreadySlashed();\n        }\n        if (block.timestamp <= getNextDueDate(loanId) + gracePeriod) {\n            revert LoanNotExpired();\n        }\n\n        //Step 3, Check if theres any collateral to slash\n        uint256 _collateralPosted = loan.collateralAmount;\n        uint256 baseTokenOut = 0;\n        address _baseToken = baseToken;\n        if (_collateralPosted > 0) {\n            //Step 3a. load local variables\n            address _collateral = loan.collateral;\n\n            //Step 3b. update the colleral owed and loan amounts\n            collateralOwed[_collateral] -= _collateralPosted;\n            loan.collateralAmount = 0;\n\n            //Step 3c. withdraw collateral from aave\n            _withdrawFromLendingPool(\n                _collateral,\n                _collateralPosted,\n                address(this)\n            );\n            //Step 3d. sell collateral for baseToken\n            baseTokenOut = _swapToken(\n                _collateral,\n                _baseToken,\n                minOut,\n                _collateralPosted\n            );\n            //Step 3e. deposit the recovered baseTokens to aave\n            _depositToLendingPool(_baseToken, baseTokenOut);\n        }\n        //Step 4. calculate the amount to be slashed\n        uint256 principalLost = loan.principalRemaining;\n        //Check if there was a full recovery for the loan, if so\n        if (baseTokenOut >= principalLost) {\n            //return excess to the lender (if any)\n            _withdrawFromLendingPool(\n                _baseToken,\n                baseTokenOut - principalLost,\n                loan.borrower\n            );\n        }\n        //slash loan only if losses are greater than recovered\n        else {\n            principalLost -= baseTokenOut;\n            //safe div: principal > 0 => totalassetvalue > 0\n            uint256 slashPercent = (1e12 * principalLost) /\n                getTotalAssetValue();\n            uint256 unbondingSlash = (unbondingAmount * slashPercent) / 1e12;\n            uint256 stakingSlash = (getStakedBNPL() * slashPercent) / 1e12;\n            //Step 5. deduct slashed from respective balances\n            accountsReceiveable -= principalLost;\n            slashingBalance += unbondingSlash + stakingSlash;\n            unbondingAmount -= unbondingSlash;\n        }\n\n        //Step 6. remove loan from currentLoans and add to defaulted loans\n        defaultedLoans[defaultedLoanCount] = loanId;\n        defaultedLoanCount++;\n\n        loan.isSlashed = true;\n        _removeCurrentLoan(loanId);\n        emit loanSlashed(loanId);\n    }\n\n    /**\n     * Sell the slashing balance of BNPL to give to lenders as <aBaseToken>\n     * Slashing sale moved to seperate function to simplify logic with minOut\n     */\n    function sellSlashed(uint256 minOut) external {\n        //Step 1. load local variables\n        address _baseToken = baseToken;\n        address _bnpl = BNPL;\n        uint256 _slashingBalance = slashingBalance;\n        //Step 2. check there is a balance to sell\n        if (_slashingBalance == 0) {\n            revert ZeroInput();\n        }\n        //Step 3. sell the slashed BNPL for baseToken\n        uint256 baseTokenOut = _swapToken(\n            _bnpl,\n            _baseToken,\n            minOut,\n            _slashingBalance\n        );\n        //Step 4. deposit baseToken received to aave and update slashing balance\n        slashingBalance = 0;\n        _depositToLendingPool(_baseToken, baseTokenOut);\n\n        emit slashingSale(_slashingBalance, baseTokenOut);\n    }\n\n    /**\n     * Donate baseToken for when debt is collected post default\n     * BNPL can be donated by simply sending it to the contract\n     */\n    function donateBaseToken(uint256 _amount) external nonZeroInput(_amount) {\n        //Step 1. load local variables\n        address _baseToken = baseToken;\n        //Step 2. collect the baseTokens\n        TransferHelper.safeTransferFrom(\n            _baseToken,\n            msg.sender,\n            address(this),\n            _amount\n        );\n        //Step 3. deposit baseToken to aave\n        _depositToLendingPool(_baseToken, _amount);\n\n        emit baseTokensDonated(_amount);\n    }\n\n    //OPERATOR ONLY FUNCTIONS\n\n    /**\n     * Approve a pending loan request\n     * Ensures collateral amount has been posted to prevent front run withdrawal\n     */\n    function approveLoan(uint256 loanId, uint256 requiredCollateralAmount)\n        external\n        operatorOnly\n    {\n        Loan storage loan = idToLoan[loanId];\n        uint256 length = pendingRequests.length;\n        uint256 loanSize = loan.loanAmount;\n        address _baseToken = baseToken;\n\n        if (getBNPLBalance(operator) < 0x13DA329B6336471800000) {\n            revert NodeInactive();\n        }\n        //ensure the loan was never started and collateral enough\n        if (loan.loanStartTime > 0) {\n            revert LoanAlreadyStarted();\n        }\n        if (loan.collateralAmount < requiredCollateralAmount) {\n            revert InsufficientCollateral();\n        }\n\n        //remove from loanRequests and add loan to current loans\n\n        for (uint256 i = 0; i < length; i++) {\n            if (loanId == pendingRequests[i]) {\n                pendingRequests[i] = pendingRequests[length - 1];\n                pendingRequests.pop();\n                break;\n            }\n        }\n\n        currentLoans.push(loanId);\n\n        //add the principal remaining and start the loan\n\n        loan.principalRemaining = loanSize;\n        loan.loanStartTime = block.timestamp;\n        accountsReceiveable += loanSize;\n        //send the funds and update accounts (minus 0.5% origination fee)\n\n        _withdrawFromLendingPool(\n            _baseToken,\n            (loanSize * 199) / 200,\n            loan.borrower\n        );\n        //send the 0.25% origination fee to treasury and agent\n        _withdrawFromLendingPool(_baseToken, loanSize / 400, treasury);\n        _withdrawFromLendingPool(\n            _baseToken,\n            loanSize / 400,\n            loanToAgent[loanId]\n        );\n\n        emit approvedLoan(loanId);\n    }\n\n    /**\n     * Used to reject all current pending loan requests\n     */\n    function clearPendingLoans() external operatorOnly {\n        pendingRequests = new uint256[](0);\n    }\n\n    /**\n     * Whitelist or delist a given list of addresses\n     * Only relevant on KYC nodes\n     */\n    function whitelistAddresses(\n        address[] memory whitelistAddition,\n        bool _status\n    ) external operatorOnly {\n        uint256 length = whitelistAddition.length;\n        for (uint256 i; i < length; i++) {\n            address newWhistelist = whitelistAddition[i];\n            whitelistedAddresses[newWhistelist] = _status;\n        }\n    }\n\n    /**\n     * Updates the KYC Status of a node\n     */\n    function setKYC(bool _newStatus) external operatorOnly {\n        requireKYC = _newStatus;\n        emit KYCRequirementChanged(_newStatus);\n    }\n\n    //PRIVATE FUNCTIONS\n\n    /**\n     * Deposit token onto AAVE lending pool, receiving aTokens in return\n     */\n    function _depositToLendingPool(address tokenIn, uint256 amountIn) private {\n        address _lendingPool = address(_getLendingPool());\n        TransferHelper.safeApprove(tokenIn, _lendingPool, 0);\n        TransferHelper.safeApprove(tokenIn, _lendingPool, amountIn);\n        _getLendingPool().deposit(tokenIn, amountIn, address(this), 0);\n    }\n\n    /**\n     * Withdraw token from AAVE lending pool, converting from aTokens to ERC20 equiv\n     */\n    function _withdrawFromLendingPool(\n        address tokenOut,\n        uint256 amountOut,\n        address to\n    ) private nonZeroInput(amountOut) {\n        _getLendingPool().withdraw(tokenOut, amountOut, to);\n    }\n\n    /**\n     * Get the latest AAVE Lending Pool contract\n     */\n    function _getLendingPool() private view returns (ILendingPool) {\n        return ILendingPool(lendingPoolProvider.getLendingPool());\n    }\n\n    /**\n     * Remove given loan from current loan list\n     */\n    function _removeCurrentLoan(uint256 loanId) private {\n        for (uint256 i = 0; i < currentLoans.length; i++) {\n            if (loanId == currentLoans[i]) {\n                currentLoans[i] = currentLoans[currentLoans.length - 1];\n                currentLoans.pop();\n                return;\n            }\n        }\n    }\n\n    /**\n     * Swaps given token, with path of length 3, tokenIn => WETH => tokenOut\n     * Uses Sushiswap pairs only\n     * Ensures slippage with minOut\n     */\n    function _swapToken(\n        address tokenIn,\n        address tokenOut,\n        uint256 minOut,\n        uint256 amountIn\n    ) private returns (uint256 tokenOutput) {\n        if (amountIn == 0) {\n            revert ZeroInput();\n        }\n        //Step 1. load data to local variables\n        address _uniswapFactory = uniswapFactory;\n        address _weth = WETH;\n        address pair1 = UniswapV2Library.pairFor(\n            _uniswapFactory,\n            tokenIn,\n            _weth\n        );\n        address pair2 = UniswapV2Library.pairFor(\n            _uniswapFactory,\n            _weth,\n            tokenOut\n        );\n        //if tokenIn = weth, only need to swap with pair2 with amountIn as input\n        if (tokenIn == _weth) {\n            pair1 = pair2;\n            tokenOutput = amountIn;\n        }\n        //Step 2. transfer the tokens to first pair (pair 2 if tokenIn == weth)\n        TransferHelper.safeTransfer(tokenIn, pair1, amountIn);\n        //Step 3. Swap tokenIn to WETH (only if tokenIn != weth)\n        if (tokenIn != _weth) {\n            tokenOutput = _swap(tokenIn, _weth, amountIn, pair1, pair2);\n        }\n        //Step 4. Swap ETH for tokenOut\n        tokenOutput = _swap(_weth, tokenOut, tokenOutput, pair2, address(this));\n        //Step 5. Check slippage parameters\n        if (minOut > tokenOutput) {\n            revert InsufficentOutput();\n        }\n    }\n\n    /**\n     * Helper function for _swapToken\n     * Modified from uniswap router to save gas, makes a single trade\n     * with uniswap pair without needing address[] path or uit256[] amounts\n     */\n    function _swap(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn,\n        address pair,\n        address to\n    ) private returns (uint256 tokenOutput) {\n        address _uniswapFactory = uniswapFactory;\n        //Step 1. get the reserves of each token\n        (uint256 reserveIn, uint256 reserveOut) = UniswapV2Library.getReserves(\n            _uniswapFactory,\n            tokenIn,\n            tokenOut\n        );\n        //Step 2. get the tokens that will be received\n        tokenOutput = UniswapV2Library.getAmountOut(\n            amountIn,\n            reserveIn,\n            reserveOut\n        );\n        //Step 3. sort the tokens to pass IUniswapV2Pair\n        (address token0, ) = UniswapV2Library.sortTokens(tokenIn, tokenOut);\n        (uint256 amount0Out, uint256 amount1Out) = tokenIn == token0\n            ? (uint256(0), tokenOutput)\n            : (tokenOutput, uint256(0));\n        //Step 4. make the trade\n        IUniswapV2Pair(pair).swap(amount0Out, amount1Out, to, new bytes(0));\n    }\n\n    //VIEW ONLY FUNCTIONS\n\n    /**\n     * Get the total BNPL in the staking account\n     * Given by (total BNPL of node) - (unbonding balance) - (slashing balance)\n     */\n    function getStakedBNPL() public view returns (uint256) {\n        return\n            IERC20(BNPL).balanceOf(address(this)) -\n            unbondingAmount -\n            slashingBalance;\n    }\n\n    /**\n     * Gets the given users balance in baseToken\n     */\n    function getBaseTokenBalance(address user) public view returns (uint256) {\n        uint256 _balance = balanceOf(user);\n        if (totalSupply() == 0) {\n            return 0;\n        }\n        return (_balance * getTotalAssetValue()) / totalSupply();\n    }\n\n    /**\n     * Get the value of the BNPL staked by user\n     * Given by (user's shares) * (total BNPL staked) / (total number of shares)\n     */\n    function getBNPLBalance(address user) public view returns (uint256 what) {\n        uint256 _balance = stakingShares[user];\n        uint256 _totalStakingShares = totalStakingShares;\n        if (_totalStakingShares == 0) {\n            what = 0;\n        } else {\n            what = (_balance * getStakedBNPL()) / _totalStakingShares;\n        }\n    }\n\n    /**\n     * Get the amount a user has that is being unbonded\n     * Given by (user's unbonding shares) * (total unbonding BNPL) / (total unbonding shares)\n     */\n    function getUnbondingBalance(address user) external view returns (uint256) {\n        uint256 _totalUnbondingShares = totalUnbondingShares;\n        uint256 _userUnbondingShare = unbondingShares[user];\n        if (_totalUnbondingShares == 0) {\n            return 0;\n        }\n        return (_userUnbondingShare * unbondingAmount) / _totalUnbondingShares;\n    }\n\n    /**\n     * Gets the next payment amount due\n     * If loan is completed or not approved, returns 0\n     */\n    function getNextPayment(uint256 loanId) public view returns (uint256) {\n        //if loan is completed or not approved, return 0\n        Loan storage loan = idToLoan[loanId];\n        if (loan.principalRemaining == 0) {\n            return 0;\n        }\n        uint256 _interestRate = loan.interestRate;\n        uint256 _loanAmount = loan.loanAmount;\n        uint256 _numberOfPayments = loan.numberOfPayments;\n        //check if it is an interest only loan\n        if (loan.interestOnly) {\n            //check if its the final payment\n            if (loan.paymentsMade + 1 == _numberOfPayments) {\n                //if final payment, then principal + final interest amount\n                return _loanAmount + ((_loanAmount * _interestRate) / 10000);\n            } else {\n                //if not final payment, simple interest amount\n                return (_loanAmount * _interestRate) / 10000;\n            }\n        } else {\n            //principal + interest payments, payment given by the formula:\n            //p : principal\n            //i : interest rate per period\n            //d : duration\n            // p * (i * (1+i) ** d) / ((1+i) ** d - 1)\n            uint256 numerator = _loanAmount *\n                _interestRate *\n                (10000 + _interestRate)**_numberOfPayments;\n            uint256 denominator = (10000 + _interestRate)**_numberOfPayments -\n                (10**(4 * _numberOfPayments));\n            return numerator / (denominator * 10000);\n        }\n    }\n\n    /**\n     * Gets the next due date (unix timestamp) of a given loan\n     * Returns 0 if loan is not a current loan or loan has already been paid\n     */\n    function getNextDueDate(uint256 loanId) public view returns (uint256) {\n        //check that the loan has been approved and loan is not completed;\n        Loan storage loan = idToLoan[loanId];\n        if (loan.principalRemaining == 0) {\n            return 0;\n        }\n        return\n            loan.loanStartTime +\n            ((loan.paymentsMade + 1) * loan.paymentInterval);\n    }\n\n    /**\n     * Get the total assets (accounts receivable + aToken balance)\n     * Only principal owed is counted as accounts receivable\n     */\n    function getTotalAssetValue() public view returns (uint256) {\n        return\n            IERC20(_getLendingPool().getReserveData(baseToken).aTokenAddress)\n                .balanceOf(address(this)) + accountsReceiveable;\n    }\n\n    /**\n     * Get number of pending requests\n     */\n    function getPendingRequestCount() external view returns (uint256) {\n        return pendingRequests.length;\n    }\n\n    /**\n     * Get the current number of active loans\n     */\n    function getCurrentLoansCount() external view returns (uint256) {\n        return currentLoans.length;\n    }\n\n    /**\n     * Get the total Losses occurred\n     */\n    function getTotalDefaultLoss() external view returns (uint256) {\n        uint256 totalLosses = 0;\n        for (uint256 i; i < defaultedLoanCount; i++) {\n            Loan storage loan = idToLoan[defaultedLoans[i]];\n            totalLosses += loan.principalRemaining;\n        }\n        return totalLosses;\n    }\n}\n"
    },
    "ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"IERC20.sol\";\nimport \"IERC20Metadata.sol\";\nimport \"Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "ILendingPool.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\nimport {ILendingPoolAddressesProvider} from \"ILendingPoolAddressesProvider.sol\";\nimport {DataTypes} from \"DataTypes.sol\";\n\ninterface ILendingPool {\n    /**\n     * @dev Emitted on deposit()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The address initiating the deposit\n     * @param onBehalfOf The beneficiary of the deposit, receiving the aTokens\n     * @param amount The amount deposited\n     * @param referral The referral code used\n     **/\n    event Deposit(\n        address indexed reserve,\n        address user,\n        address indexed onBehalfOf,\n        uint256 amount,\n        uint16 indexed referral\n    );\n\n    /**\n     * @dev Emitted on withdraw()\n     * @param reserve The address of the underlyng asset being withdrawn\n     * @param user The address initiating the withdrawal, owner of aTokens\n     * @param to Address that will receive the underlying\n     * @param amount The amount to be withdrawn\n     **/\n    event Withdraw(\n        address indexed reserve,\n        address indexed user,\n        address indexed to,\n        uint256 amount\n    );\n\n    /**\n     * @dev Emitted on borrow() and flashLoan() when debt needs to be opened\n     * @param reserve The address of the underlying asset being borrowed\n     * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just\n     * initiator of the transaction on flashLoan()\n     * @param onBehalfOf The address that will be getting the debt\n     * @param amount The amount borrowed out\n     * @param borrowRateMode The rate mode: 1 for Stable, 2 for Variable\n     * @param borrowRate The numeric rate at which the user has borrowed\n     * @param referral The referral code used\n     **/\n    event Borrow(\n        address indexed reserve,\n        address user,\n        address indexed onBehalfOf,\n        uint256 amount,\n        uint256 borrowRateMode,\n        uint256 borrowRate,\n        uint16 indexed referral\n    );\n\n    /**\n     * @dev Emitted on repay()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The beneficiary of the repayment, getting his debt reduced\n     * @param repayer The address of the user initiating the repay(), providing the funds\n     * @param amount The amount repaid\n     **/\n    event Repay(\n        address indexed reserve,\n        address indexed user,\n        address indexed repayer,\n        uint256 amount\n    );\n\n    /**\n     * @dev Emitted on swapBorrowRateMode()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The address of the user swapping his rate mode\n     * @param rateMode The rate mode that the user wants to swap to\n     **/\n    event Swap(address indexed reserve, address indexed user, uint256 rateMode);\n\n    /**\n     * @dev Emitted on setUserUseReserveAsCollateral()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The address of the user enabling the usage as collateral\n     **/\n    event ReserveUsedAsCollateralEnabled(\n        address indexed reserve,\n        address indexed user\n    );\n\n    /**\n     * @dev Emitted on setUserUseReserveAsCollateral()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The address of the user enabling the usage as collateral\n     **/\n    event ReserveUsedAsCollateralDisabled(\n        address indexed reserve,\n        address indexed user\n    );\n\n    /**\n     * @dev Emitted on rebalanceStableBorrowRate()\n     * @param reserve The address of the underlying asset of the reserve\n     * @param user The address of the user for which the rebalance has been executed\n     **/\n    event RebalanceStableBorrowRate(\n        address indexed reserve,\n        address indexed user\n    );\n\n    /**\n     * @dev Emitted on flashLoan()\n     * @param target The address of the flash loan receiver contract\n     * @param initiator The address initiating the flash loan\n     * @param asset The address of the asset being flash borrowed\n     * @param amount The amount flash borrowed\n     * @param premium The fee flash borrowed\n     * @param referralCode The referral code used\n     **/\n    event FlashLoan(\n        address indexed target,\n        address indexed initiator,\n        address indexed asset,\n        uint256 amount,\n        uint256 premium,\n        uint16 referralCode\n    );\n\n    /**\n     * @dev Emitted when the pause is triggered.\n     */\n    event Paused();\n\n    /**\n     * @dev Emitted when the pause is lifted.\n     */\n    event Unpaused();\n\n    /**\n     * @dev Emitted when a borrower is liquidated. This event is emitted by the LendingPool via\n     * LendingPoolCollateral manager using a DELEGATECALL\n     * This allows to have the events in the generated ABI for LendingPool.\n     * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n     * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n     * @param user The address of the borrower getting liquidated\n     * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n     * @param liquidatedCollateralAmount The amount of collateral received by the liiquidator\n     * @param liquidator The address of the liquidator\n     * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\n     * to receive the underlying collateral asset directly\n     **/\n    event LiquidationCall(\n        address indexed collateralAsset,\n        address indexed debtAsset,\n        address indexed user,\n        uint256 debtToCover,\n        uint256 liquidatedCollateralAmount,\n        address liquidator,\n        bool receiveAToken\n    );\n\n    /**\n     * @dev Emitted when the state of a reserve is updated. NOTE: This event is actually declared\n     * in the ReserveLogic library and emitted in the updateInterestRates() function. Since the function is internal,\n     * the event will actually be fired by the LendingPool contract. The event is therefore replicated here so it\n     * gets added to the LendingPool ABI\n     * @param reserve The address of the underlying asset of the reserve\n     * @param liquidityRate The new liquidity rate\n     * @param stableBorrowRate The new stable borrow rate\n     * @param variableBorrowRate The new variable borrow rate\n     * @param liquidityIndex The new liquidity index\n     * @param variableBorrowIndex The new variable borrow index\n     **/\n    event ReserveDataUpdated(\n        address indexed reserve,\n        uint256 liquidityRate,\n        uint256 stableBorrowRate,\n        uint256 variableBorrowRate,\n        uint256 liquidityIndex,\n        uint256 variableBorrowIndex\n    );\n\n    /**\n     * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n     * - E.g. User deposits 100 USDC and gets in return 100 aUSDC\n     * @param asset The address of the underlying asset to deposit\n     * @param amount The amount to be deposited\n     * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n     *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n     *   is a different wallet\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     **/\n    function deposit(\n        address asset,\n        uint256 amount,\n        address onBehalfOf,\n        uint16 referralCode\n    ) external;\n\n    /**\n     * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\n     * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\n     * @param asset The address of the underlying asset to withdraw\n     * @param amount The underlying amount to be withdrawn\n     *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\n     * @param to Address that will receive the underlying, same as msg.sender if the user\n     *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n     *   different wallet\n     * @return The final amount withdrawn\n     **/\n    function withdraw(\n        address asset,\n        uint256 amount,\n        address to\n    ) external returns (uint256);\n\n    /**\n     * @dev Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\n     * already deposited enough collateral, or he was given enough allowance by a credit delegator on the\n     * corresponding debt token (StableDebtToken or VariableDebtToken)\n     * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\n     *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\n     * @param asset The address of the underlying asset to borrow\n     * @param amount The amount to be borrowed\n     * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     * @param onBehalfOf Address of the user who will receive the debt. Should be the address of the borrower itself\n     * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\n     * if he has been given credit delegation allowance\n     **/\n    function borrow(\n        address asset,\n        uint256 amount,\n        uint256 interestRateMode,\n        uint16 referralCode,\n        address onBehalfOf\n    ) external;\n\n    /**\n     * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\n     * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\n     * @param asset The address of the borrowed underlying asset previously borrowed\n     * @param amount The amount to repay\n     * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n     * @param rateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n     * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\n     * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n     * other borrower whose debt should be removed\n     * @return The final amount repaid\n     **/\n    function repay(\n        address asset,\n        uint256 amount,\n        uint256 rateMode,\n        address onBehalfOf\n    ) external returns (uint256);\n\n    /**\n     * @dev Allows a borrower to swap his debt between stable and variable mode, or viceversa\n     * @param asset The address of the underlying asset borrowed\n     * @param rateMode The rate mode that the user wants to swap to\n     **/\n    function swapBorrowRateMode(address asset, uint256 rateMode) external;\n\n    /**\n     * @dev Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.\n     * - Users can be rebalanced if the following conditions are satisfied:\n     *     1. Usage ratio is above 95%\n     *     2. the current deposit APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too much has been\n     *        borrowed at a stable rate and depositors are not earning enough\n     * @param asset The address of the underlying asset borrowed\n     * @param user The address of the user to be rebalanced\n     **/\n    function rebalanceStableBorrowRate(address asset, address user) external;\n\n    /**\n     * @dev Allows depositors to enable/disable a specific deposited asset as collateral\n     * @param asset The address of the underlying asset deposited\n     * @param useAsCollateral `true` if the user wants to use the deposit as collateral, `false` otherwise\n     **/\n    function setUserUseReserveAsCollateral(address asset, bool useAsCollateral)\n        external;\n\n    /**\n     * @dev Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\n     * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\n     *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\n     * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\n     * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\n     * @param user The address of the borrower getting liquidated\n     * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\n     * @param receiveAToken `true` if the liquidators wants to receive the collateral aTokens, `false` if he wants\n     * to receive the underlying collateral asset directly\n     **/\n    function liquidationCall(\n        address collateralAsset,\n        address debtAsset,\n        address user,\n        uint256 debtToCover,\n        bool receiveAToken\n    ) external;\n\n    /**\n     * @dev Allows smartcontracts to access the liquidity of the pool within one transaction,\n     * as long as the amount taken plus a fee is returned.\n     * IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept into consideration.\n     * For further details please visit https://developers.aave.com\n     * @param receiverAddress The address of the contract receiving the funds, implementing the IFlashLoanReceiver interface\n     * @param assets The addresses of the assets being flash-borrowed\n     * @param amounts The amounts amounts being flash-borrowed\n     * @param modes Types of the debt to open if the flash loan is not returned:\n     *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\n     *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n     *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\n     * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\n     * @param params Variadic packed params to pass to the receiver as extra information\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     **/\n    function flashLoan(\n        address receiverAddress,\n        address[] calldata assets,\n        uint256[] calldata amounts,\n        uint256[] calldata modes,\n        address onBehalfOf,\n        bytes calldata params,\n        uint16 referralCode\n    ) external;\n\n    /**\n     * @dev Returns the user account data across all the reserves\n     * @param user The address of the user\n     * @return totalCollateralETH the total collateral in ETH of the user\n     * @return totalDebtETH the total debt in ETH of the user\n     * @return availableBorrowsETH the borrowing power left of the user\n     * @return currentLiquidationThreshold the liquidation threshold of the user\n     * @return ltv the loan to value of the user\n     * @return healthFactor the current health factor of the user\n     **/\n    function getUserAccountData(address user)\n        external\n        view\n        returns (\n            uint256 totalCollateralETH,\n            uint256 totalDebtETH,\n            uint256 availableBorrowsETH,\n            uint256 currentLiquidationThreshold,\n            uint256 ltv,\n            uint256 healthFactor\n        );\n\n    function initReserve(\n        address reserve,\n        address aTokenAddress,\n        address stableDebtAddress,\n        address variableDebtAddress,\n        address interestRateStrategyAddress\n    ) external;\n\n    function setReserveInterestRateStrategyAddress(\n        address reserve,\n        address rateStrategyAddress\n    ) external;\n\n    function setConfiguration(address reserve, uint256 configuration) external;\n\n    /**\n     * @dev Returns the configuration of the reserve\n     * @param asset The address of the underlying asset of the reserve\n     * @return The configuration of the reserve\n     **/\n    function getConfiguration(address asset)\n        external\n        view\n        returns (DataTypes.ReserveConfigurationMap memory);\n\n    /**\n     * @dev Returns the configuration of the user across all the reserves\n     * @param user The user address\n     * @return The configuration of the user\n     **/\n    function getUserConfiguration(address user)\n        external\n        view\n        returns (DataTypes.UserConfigurationMap memory);\n\n    /**\n     * @dev Returns the normalized income normalized income of the reserve\n     * @param asset The address of the underlying asset of the reserve\n     * @return The reserve's normalized income\n     */\n    function getReserveNormalizedIncome(address asset)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Returns the normalized variable debt per unit of asset\n     * @param asset The address of the underlying asset of the reserve\n     * @return The reserve normalized variable debt\n     */\n    function getReserveNormalizedVariableDebt(address asset)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Returns the state and configuration of the reserve\n     * @param asset The address of the underlying asset of the reserve\n     * @return The state of the reserve\n     **/\n    function getReserveData(address asset)\n        external\n        view\n        returns (DataTypes.ReserveData memory);\n\n    function finalizeTransfer(\n        address asset,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 balanceFromAfter,\n        uint256 balanceToBefore\n    ) external;\n\n    function getReservesList() external view returns (address[] memory);\n\n    function getAddressesProvider()\n        external\n        view\n        returns (ILendingPoolAddressesProvider);\n\n    function setPause(bool val) external;\n\n    function paused() external view returns (bool);\n}\n"
    },
    "ILendingPoolAddressesProvider.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\n/**\n * @title LendingPoolAddressesProvider contract\n * @dev Main registry of addresses part of or connected to the protocol, including permissioned roles\n * - Acting also as factory of proxies and admin of those, so with right to change its implementations\n * - Owned by the Aave Governance\n * @author Aave\n **/\ninterface ILendingPoolAddressesProvider {\n    event MarketIdSet(string newMarketId);\n    event LendingPoolUpdated(address indexed newAddress);\n    event ConfigurationAdminUpdated(address indexed newAddress);\n    event EmergencyAdminUpdated(address indexed newAddress);\n    event LendingPoolConfiguratorUpdated(address indexed newAddress);\n    event LendingPoolCollateralManagerUpdated(address indexed newAddress);\n    event PriceOracleUpdated(address indexed newAddress);\n    event LendingRateOracleUpdated(address indexed newAddress);\n    event ProxyCreated(bytes32 id, address indexed newAddress);\n    event AddressSet(bytes32 id, address indexed newAddress, bool hasProxy);\n\n    function getMarketId() external view returns (string memory);\n\n    function setMarketId(string calldata marketId) external;\n\n    function setAddress(bytes32 id, address newAddress) external;\n\n    function setAddressAsProxy(bytes32 id, address impl) external;\n\n    function getAddress(bytes32 id) external view returns (address);\n\n    function getLendingPool() external view returns (address);\n\n    function setLendingPoolImpl(address pool) external;\n\n    function getLendingPoolConfigurator() external view returns (address);\n\n    function setLendingPoolConfiguratorImpl(address configurator) external;\n\n    function getLendingPoolCollateralManager() external view returns (address);\n\n    function setLendingPoolCollateralManager(address manager) external;\n\n    function getPoolAdmin() external view returns (address);\n\n    function setPoolAdmin(address admin) external;\n\n    function getEmergencyAdmin() external view returns (address);\n\n    function setEmergencyAdmin(address admin) external;\n\n    function getPriceOracle() external view returns (address);\n\n    function setPriceOracle(address priceOracle) external;\n\n    function getLendingRateOracle() external view returns (address);\n\n    function setLendingRateOracle(address lendingRateOracle) external;\n}\n"
    },
    "DataTypes.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nlibrary DataTypes {\n    // refer to the whitepaper, section 1.1 basic concepts for a formal description of these properties.\n    struct ReserveData {\n        //stores the reserve configuration\n        ReserveConfigurationMap configuration;\n        //the liquidity index. Expressed in ray\n        uint128 liquidityIndex;\n        //variable borrow index. Expressed in ray\n        uint128 variableBorrowIndex;\n        //the current supply rate. Expressed in ray\n        uint128 currentLiquidityRate;\n        //the current variable borrow rate. Expressed in ray\n        uint128 currentVariableBorrowRate;\n        //the current stable borrow rate. Expressed in ray\n        uint128 currentStableBorrowRate;\n        uint40 lastUpdateTimestamp;\n        //tokens addresses\n        address aTokenAddress;\n        address stableDebtTokenAddress;\n        address variableDebtTokenAddress;\n        //address of the interest rate strategy\n        address interestRateStrategyAddress;\n        //the id of the reserve. Represents the position in the list of the active reserves\n        uint8 id;\n    }\n\n    struct ReserveConfigurationMap {\n        //bit 0-15: LTV\n        //bit 16-31: Liq. threshold\n        //bit 32-47: Liq. bonus\n        //bit 48-55: Decimals\n        //bit 56: Reserve is active\n        //bit 57: reserve is frozen\n        //bit 58: borrowing is enabled\n        //bit 59: stable rate borrowing enabled\n        //bit 60-63: reserved\n        //bit 64-79: reserve factor\n        uint256 data;\n    }\n\n    struct UserConfigurationMap {\n        uint256 data;\n    }\n\n    enum InterestRateMode {\n        NONE,\n        STABLE,\n        VARIABLE\n    }\n}\n"
    },
    "IAaveIncentivesController.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\npragma experimental ABIEncoderV2;\n\nimport {IAaveDistributionManager} from \"IAaveDistributionManager.sol\";\n\ninterface IAaveIncentivesController is IAaveDistributionManager {\n    event RewardsAccrued(address indexed user, uint256 amount);\n\n    event RewardsClaimed(\n        address indexed user,\n        address indexed to,\n        address indexed claimer,\n        uint256 amount\n    );\n\n    event ClaimerSet(address indexed user, address indexed claimer);\n\n    /**\n     * @dev Whitelists an address to claim the rewards on behalf of another address\n     * @param user The address of the user\n     * @param claimer The address of the claimer\n     */\n    function setClaimer(address user, address claimer) external;\n\n    /**\n     * @dev Returns the whitelisted claimer for a certain address (0x0 if not set)\n     * @param user The address of the user\n     * @return The claimer address\n     */\n    function getClaimer(address user) external view returns (address);\n\n    /**\n     * @dev Configure assets for a certain rewards emission\n     * @param assets The assets to incentivize\n     * @param emissionsPerSecond The emission for each asset\n     */\n    function configureAssets(\n        address[] calldata assets,\n        uint256[] calldata emissionsPerSecond\n    ) external;\n\n    /**\n     * @dev Called by the corresponding asset on any update that affects the rewards distribution\n     * @param asset The address of the user\n     * @param userBalance The balance of the user of the asset in the lending pool\n     * @param totalSupply The total supply of the asset in the lending pool\n     **/\n    function handleAction(\n        address asset,\n        uint256 userBalance,\n        uint256 totalSupply\n    ) external;\n\n    /**\n     * @dev Returns the total of rewards of an user, already accrued + not yet accrued\n     * @param user The address of the user\n     * @return The rewards\n     **/\n    function getRewardsBalance(address[] calldata assets, address user)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Claims reward for an user to the desired address, on all the assets of the lending pool, accumulating the pending rewards\n     * @param amount Amount of rewards to claim\n     * @param to Address that will be receiving the rewards\n     * @return Rewards claimed\n     **/\n    function claimRewards(\n        address[] calldata assets,\n        uint256 amount,\n        address to\n    ) external returns (uint256);\n\n    /**\n     * @dev Claims reward for an user on behalf, on all the assets of the lending pool, accumulating the pending rewards. The caller must\n     * be whitelisted via \"allowClaimOnBehalf\" function by the RewardsAdmin role manager\n     * @param amount Amount of rewards to claim\n     * @param user Address to check and claim rewards\n     * @param to Address that will be receiving the rewards\n     * @return Rewards claimed\n     **/\n    function claimRewardsOnBehalf(\n        address[] calldata assets,\n        uint256 amount,\n        address user,\n        address to\n    ) external returns (uint256);\n\n    /**\n     * @dev Claims reward for msg.sender, on all the assets of the lending pool, accumulating the pending rewards\n     * @param amount Amount of rewards to claim\n     * @return Rewards claimed\n     **/\n    function claimRewardsToSelf(address[] calldata assets, uint256 amount)\n        external\n        returns (uint256);\n\n    /**\n     * @dev returns the unclaimed rewards of the user\n     * @param user the address of the user\n     * @return the unclaimed user rewards\n     */\n    function getUserUnclaimedRewards(address user)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev for backward compatibility with previous implementation of the Incentives controller\n     */\n    function REWARD_TOKEN() external view returns (address);\n}\n"
    },
    "IAaveDistributionManager.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\nimport {DistributionTypes} from \"DistributionTypes.sol\";\n\ninterface IAaveDistributionManager {\n    event AssetConfigUpdated(address indexed asset, uint256 emission);\n    event AssetIndexUpdated(address indexed asset, uint256 index);\n    event UserIndexUpdated(\n        address indexed user,\n        address indexed asset,\n        uint256 index\n    );\n    event DistributionEndUpdated(uint256 newDistributionEnd);\n\n    /**\n     * @dev Sets the end date for the distribution\n     * @param distributionEnd The end date timestamp\n     **/\n    function setDistributionEnd(uint256 distributionEnd) external;\n\n    /**\n     * @dev Gets the end date for the distribution\n     * @return The end of the distribution\n     **/\n    function getDistributionEnd() external view returns (uint256);\n\n    /**\n     * @dev for backwards compatibility with the previous DistributionManager used\n     * @return The end of the distribution\n     **/\n    function DISTRIBUTION_END() external view returns (uint256);\n\n    /**\n     * @dev Returns the data of an user on a distribution\n     * @param user Address of the user\n     * @param asset The address of the reference asset of the distribution\n     * @return The new index\n     **/\n    function getUserAssetData(address user, address asset)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Returns the configuration of the distribution for a certain asset\n     * @param asset The address of the reference asset of the distribution\n     * @return The asset index, the emission per second and the last updated timestamp\n     **/\n    function getAssetData(address asset)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        );\n}\n"
    },
    "DistributionTypes.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\npragma experimental ABIEncoderV2;\n\nlibrary DistributionTypes {\n    struct AssetConfigInput {\n        uint104 emissionPerSecond;\n        uint256 totalStaked;\n        address underlyingAsset;\n    }\n\n    struct UserStakeInput {\n        address underlyingAsset;\n        uint256 stakedByUser;\n        uint256 totalStaked;\n    }\n}\n"
    },
    "UniswapV2Library.sol": {
      "content": "pragma solidity >=0.5.0;\n\nimport \"IUniswapV2Pair.sol\";\n\nimport \"SafeMath.sol\";\n\nlibrary UniswapV2Library {\n    using SafeMath for uint256;\n\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\n    function sortTokens(address tokenA, address tokenB)\n        internal\n        pure\n        returns (address token0, address token1)\n    {\n        require(tokenA != tokenB, \"UniswapV2Library: IDENTICAL_ADDRESSES\");\n        (token0, token1) = tokenA < tokenB\n            ? (tokenA, tokenB)\n            : (tokenB, tokenA);\n        require(token0 != address(0), \"UniswapV2Library: ZERO_ADDRESS\");\n    }\n\n    // calculates the CREATE2 address for a pair without making any external calls\n    function pairFor(\n        address factory,\n        address tokenA,\n        address tokenB\n    ) internal pure returns (address pair) {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            hex\"ff\",\n                            factory,\n                            keccak256(abi.encodePacked(token0, token1)),\n                            // hex\"96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f\" // init code hash\n                            //mainnet hash for sushiSwap:\n                            hex\"e18a34eb0e04b04f7a0ac29a6e80748dca96319b42c54d679cb821dca90c6303\"\n                        )\n                    )\n                )\n            )\n        );\n    }\n\n    // fetches and sorts the reserves for a pair\n    function getReserves(\n        address factory,\n        address tokenA,\n        address tokenB\n    ) internal view returns (uint256 reserveA, uint256 reserveB) {\n        (address token0, ) = sortTokens(tokenA, tokenB);\n        (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(\n            pairFor(factory, tokenA, tokenB)\n        ).getReserves();\n        (reserveA, reserveB) = tokenA == token0\n            ? (reserve0, reserve1)\n            : (reserve1, reserve0);\n    }\n\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) internal pure returns (uint256 amountB) {\n        require(amountA > 0, \"UniswapV2Library: INSUFFICIENT_AMOUNT\");\n        require(\n            reserveA > 0 && reserveB > 0,\n            \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\"\n        );\n        amountB = amountA.mul(reserveB) / reserveA;\n    }\n\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountOut) {\n        require(amountIn > 0, \"UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT\");\n        require(\n            reserveIn > 0 && reserveOut > 0,\n            \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\"\n        );\n        uint256 amountInWithFee = amountIn.mul(997);\n        uint256 numerator = amountInWithFee.mul(reserveOut);\n        uint256 denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountIn) {\n        require(amountOut > 0, \"UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT\");\n        require(\n            reserveIn > 0 && reserveOut > 0,\n            \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\"\n        );\n        uint256 numerator = reserveIn.mul(amountOut).mul(1000);\n        uint256 denominator = reserveOut.sub(amountOut).mul(997);\n        amountIn = (numerator / denominator).add(1);\n    }\n\n    // performs chained getAmountOut calculations on any number of pairs\n    function getAmountsOut(\n        address factory,\n        uint256 amountIn,\n        address[] memory path\n    ) internal view returns (uint256[] memory amounts) {\n        require(path.length >= 2, \"UniswapV2Library: INVALID_PATH\");\n        amounts = new uint256[](path.length);\n        amounts[0] = amountIn;\n        for (uint256 i; i < path.length - 1; i++) {\n            (uint256 reserveIn, uint256 reserveOut) = getReserves(\n                factory,\n                path[i],\n                path[i + 1]\n            );\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n        }\n    }\n\n    // performs chained getAmountIn calculations on any number of pairs\n    function getAmountsIn(\n        address factory,\n        uint256 amountOut,\n        address[] memory path\n    ) internal view returns (uint256[] memory amounts) {\n        require(path.length >= 2, \"UniswapV2Library: INVALID_PATH\");\n        amounts = new uint256[](path.length);\n        amounts[amounts.length - 1] = amountOut;\n        for (uint256 i = path.length - 1; i > 0; i--) {\n            (uint256 reserveIn, uint256 reserveOut) = getReserves(\n                factory,\n                path[i - 1],\n                path[i]\n            );\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\n        }\n    }\n}\n"
    },
    "IUniswapV2Pair.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function name() external pure returns (string memory);\n\n    function symbol() external pure returns (string memory);\n\n    function decimals() external pure returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n    function nonces(address owner) external view returns (uint256);\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n    event Burn(\n        address indexed sender,\n        uint256 amount0,\n        uint256 amount1,\n        address indexed to\n    );\n    event Swap(\n        address indexed sender,\n        uint256 amount0In,\n        uint256 amount1In,\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\n\n    function factory() external view returns (address);\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function getReserves()\n        external\n        view\n        returns (\n            uint112 reserve0,\n            uint112 reserve1,\n            uint32 blockTimestampLast\n        );\n\n    function price0CumulativeLast() external view returns (uint256);\n\n    function price1CumulativeLast() external view returns (uint256);\n\n    function kLast() external view returns (uint256);\n\n    function mint(address to) external returns (uint256 liquidity);\n\n    function burn(address to)\n        external\n        returns (uint256 amount0, uint256 amount1);\n\n    function swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to,\n        bytes calldata data\n    ) external;\n\n    function skim(address to) external;\n\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "SafeMath.sol": {
      "content": "pragma solidity >=0.6.6;\n\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\n\nlibrary SafeMath {\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\n    }\n\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\n    }\n\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\n    }\n}\n"
    },
    "TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.6.0;\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(0x095ea7b3, to, value)\n        );\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"TransferHelper: APPROVE_FAILED\"\n        );\n    }\n\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(0xa9059cbb, to, value)\n        );\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"TransferHelper: TRANSFER_FAILED\"\n        );\n    }\n\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(0x23b872dd, from, to, value)\n        );\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"TransferHelper: TRANSFER_FROM_FAILED\"\n        );\n    }\n\n    function safeTransferETH(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(success, \"TransferHelper: ETH_TRANSFER_FAILED\");\n    }\n}\n"
    }
  },
  "settings": {
    "evmVersion": "istanbul",
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "libraries": {
      "BNPLFactory.sol": {}
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  }
}}