{{
  "language": "Solidity",
  "settings": {
    "evmVersion": "istanbul",
    "libraries": {},
    "metadata": {
      "bytecodeHash": "ipfs",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 100000
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "src/libraries/MathLib.sol": {
      "content": "//SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.4;\n\n/**\n * @title MathLib\n * @author ElasticDAO\n */\nlibrary MathLib {\n    struct InternalBalances {\n        // x*y=k - we track these internally to compare to actual balances of the ERC20's\n        // in order to calculate the \"decay\" or the amount of balances that are not\n        // participating in the pricing curve and adding additional liquidity to swap.\n        uint256 baseTokenReserveQty; // x\n        uint256 quoteTokenReserveQty; // y\n        uint256 kLast; // as of the last add / rem liquidity event\n    }\n\n    // aids in avoiding stack too deep errors.\n    struct TokenQtys {\n        uint256 baseTokenQty;\n        uint256 quoteTokenQty;\n        uint256 liquidityTokenQty;\n        uint256 liquidityTokenFeeQty;\n    }\n\n    uint256 public constant BASIS_POINTS = 10000;\n    uint256 public constant WAD = 1e18; // represent a decimal with 18 digits of precision\n\n    /**\n     * @dev divides two float values, required since solidity does not handle\n     * floating point values.\n     *\n     * inspiration: https://github.com/dapphub/ds-math/blob/master/src/math.sol\n     *\n     * NOTE: this rounds to the nearest integer (up or down). For example .666666 would end up\n     * rounding to .66667.\n     *\n     * @return uint256 wad value (decimal with 18 digits of precision)\n     */\n    function wDiv(uint256 a, uint256 b) public pure returns (uint256) {\n        return ((a * WAD) + (b / 2)) / b;\n    }\n\n    /**\n     * @dev rounds a integer (a) to the nearest n places.\n     * IE roundToNearest(123, 10) would round to the nearest 10th place (120).\n     */\n    function roundToNearest(uint256 a, uint256 n)\n        public\n        pure\n        returns (uint256)\n    {\n        return ((a + (n / 2)) / n) * n;\n    }\n\n    /**\n     * @dev multiplies two float values, required since solidity does not handle\n     * floating point values\n     *\n     * inspiration: https://github.com/dapphub/ds-math/blob/master/src/math.sol\n     *\n     * @return uint256 wad value (decimal with 18 digits of precision)\n     */\n    function wMul(uint256 a, uint256 b) public pure returns (uint256) {\n        return ((a * b) + (WAD / 2)) / WAD;\n    }\n\n    /**\n     * @dev calculates an absolute diff between two integers. Basically the solidity\n     * equivalent of Math.abs(a-b);\n     */\n    function diff(uint256 a, uint256 b) public pure returns (uint256) {\n        if (a >= b) {\n            return a - b;\n        }\n        return b - a;\n    }\n\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\n    function sqrt(uint256 x) public pure returns (uint256 y) {\n        uint256 z = (x + 1) / 2;\n        y = x;\n        while (z < y) {\n            y = z;\n            z = (x / z + z) / 2;\n        }\n    }\n\n    /**\n     * @dev defines the amount of decay needed in order for us to require a user to handle the\n     * decay prior to a double asset entry as the equivalent of 1 unit of quote token\n     */\n    function isSufficientDecayPresent(\n        uint256 _baseTokenReserveQty,\n        InternalBalances memory _internalBalances\n    ) public pure returns (bool) {\n        return (wDiv(\n            diff(_baseTokenReserveQty, _internalBalances.baseTokenReserveQty) *\n                WAD,\n            wDiv(\n                _internalBalances.baseTokenReserveQty,\n                _internalBalances.quoteTokenReserveQty\n            )\n        ) >= WAD); // the amount of base token (a) decay is greater than 1 unit of quote token (token b)\n    }\n\n    /**\n     * @dev used to calculate the qty of token a liquidity provider\n     * must add in order to maintain the current reserve ratios\n     * @param _tokenAQty base or quote token qty to be supplied by the liquidity provider\n     * @param _tokenAReserveQty current reserve qty of the base or quote token (same token as tokenA)\n     * @param _tokenBReserveQty current reserve qty of the other base or quote token (not tokenA)\n     */\n    function calculateQty(\n        uint256 _tokenAQty,\n        uint256 _tokenAReserveQty,\n        uint256 _tokenBReserveQty\n    ) public pure returns (uint256 tokenBQty) {\n        require(_tokenAQty != 0, \"MathLib: INSUFFICIENT_QTY\");\n        require(\n            _tokenAReserveQty != 0 && _tokenBReserveQty != 0,\n            \"MathLib: INSUFFICIENT_LIQUIDITY\"\n        );\n        tokenBQty = (_tokenAQty * _tokenBReserveQty) / _tokenAReserveQty;\n    }\n\n    /**\n     * @dev used to calculate the qty of token a trader will receive (less fees)\n     * given the qty of token A they are providing\n     * @param _tokenASwapQty base or quote token qty to be swapped by the trader\n     * @param _tokenAReserveQty current reserve qty of the base or quote token (same token as tokenA)\n     * @param _tokenBReserveQty current reserve qty of the other base or quote token (not tokenA)\n     * @param _liquidityFeeInBasisPoints fee to liquidity providers represented in basis points\n     */\n    function calculateQtyToReturnAfterFees(\n        uint256 _tokenASwapQty,\n        uint256 _tokenAReserveQty,\n        uint256 _tokenBReserveQty,\n        uint256 _liquidityFeeInBasisPoints\n    ) public pure returns (uint256 qtyToReturn) {\n        uint256 tokenASwapQtyLessFee =\n            _tokenASwapQty * (BASIS_POINTS - _liquidityFeeInBasisPoints);\n        qtyToReturn =\n            (tokenASwapQtyLessFee * _tokenBReserveQty) /\n            ((_tokenAReserveQty * BASIS_POINTS) + tokenASwapQtyLessFee);\n    }\n\n    /**\n     * @dev used to calculate the qty of liquidity tokens (deltaRo) we will be issued to a supplier\n     * of a single asset entry when base token decay is present.\n     * @param _baseTokenReserveBalance the total balance (external) of base tokens in our pool (Alpha)\n     * @param _totalSupplyOfLiquidityTokens the total supply of our exchange's liquidity tokens (aka Ro)\n     * @param _tokenQtyAToAdd the amount of tokens being added by the caller to remove the current decay\n     * @param _internalTokenAReserveQty the internal balance (X or Y) of token A as a result of this transaction\n     * @param _omega - ratio of internal balances of baseToken and quoteToken: baseToken/quoteToken\n     * @return liquidityTokenQty qty of liquidity tokens to be issued in exchange\n     */\n    function calculateLiquidityTokenQtyForSingleAssetEntryWithBaseTokenDecay(\n        uint256 _baseTokenReserveBalance,\n        uint256 _totalSupplyOfLiquidityTokens,\n        uint256 _tokenQtyAToAdd,\n        uint256 _internalTokenAReserveQty,\n        uint256 _omega\n    ) public pure returns (uint256 liquidityTokenQty) {\n        /**\n        \n        (is the formula in the terms of quoteToken)\n                    ΔY \n            = ---------------------                                                    \n                Alpha/Omega + Y'\n\n\n         */\n        uint256 wRatio = wDiv(_baseTokenReserveBalance, _omega);\n        uint256 denominator = wRatio + _internalTokenAReserveQty;\n        uint256 wGamma = wDiv(_tokenQtyAToAdd, denominator);\n\n        liquidityTokenQty =\n            wDiv(\n                wMul(_totalSupplyOfLiquidityTokens * WAD, wGamma),\n                WAD - wGamma\n            ) /\n            WAD;\n    }\n\n    /**\n     * @dev used to calculate the qty of liquidity tokens (deltaRo) we will be issued to a supplier\n     * of a single asset entry when quote decay is present.\n     * @param _baseTokenReserveBalance the total balance (external) of base tokens in our pool (Alpha)\n     * @param _totalSupplyOfLiquidityTokens the total supply of our exchange's liquidity tokens (aka Ro)\n     * @param _tokenQtyAToAdd the amount of tokens being added by the caller to remove the current decay\n     * @param _internalTokenAReserveQty the internal balance (X or Y) of token A as a result of this transaction\n     * @return liquidityTokenQty qty of liquidity tokens to be issued in exchange\n     */\n    function calculateLiquidityTokenQtyForSingleAssetEntryWithQuoteTokenDecay(\n        uint256 _baseTokenReserveBalance,\n        uint256 _totalSupplyOfLiquidityTokens,\n        uint256 _tokenQtyAToAdd,\n        uint256 _internalTokenAReserveQty\n    ) public pure returns (uint256 liquidityTokenQty) {\n        /**\n        \n               ΔX\n        = -------------------  / (denominator may be Alpha' instead of X)\n           X + (Alpha + ΔX)\n\n        */\n\n        uint256 denominator =\n            _internalTokenAReserveQty +\n                _baseTokenReserveBalance +\n                _tokenQtyAToAdd;\n        uint256 wGamma = wDiv(_tokenQtyAToAdd, denominator);\n\n        liquidityTokenQty =\n            wDiv(\n                wMul(_totalSupplyOfLiquidityTokens * WAD, wGamma),\n                WAD - wGamma\n            ) /\n            WAD;\n    }\n\n    /**\n     * @dev used to calculate the qty of liquidity tokens (deltaRo) we will be issued to a supplier\n     * of a single asset entry when decay is present.\n     * @param _totalSupplyOfLiquidityTokens the total supply of our exchange's liquidity tokens (aka Ro)\n     * @param _quoteTokenQty the amount of quote token the user it adding to the pool (deltaB or deltaY)\n     * @param _quoteTokenReserveBalance the total balance (external) of quote tokens in our pool (Beta)\n     *\n     * @return liquidityTokenQty qty of liquidity tokens to be issued in exchange\n     */\n    function calculateLiquidityTokenQtyForDoubleAssetEntry(\n        uint256 _totalSupplyOfLiquidityTokens,\n        uint256 _quoteTokenQty,\n        uint256 _quoteTokenReserveBalance\n    ) public pure returns (uint256 liquidityTokenQty) {\n        liquidityTokenQty =\n            (_quoteTokenQty * _totalSupplyOfLiquidityTokens) /\n            _quoteTokenReserveBalance;\n    }\n\n    /**\n     * @dev used to calculate the qty of quote token required and liquidity tokens (deltaRo) to be issued\n     * in order to add liquidity and remove base token decay.\n     * @param _quoteTokenQtyDesired the amount of quote token the user wants to contribute\n     * @param _baseTokenReserveQty the external base token reserve qty prior to this transaction\n     * @param _totalSupplyOfLiquidityTokens the total supply of our exchange's liquidity tokens (aka Ro)\n     * @param _internalBalances internal balances struct from our exchange's internal accounting\n     *\n     *\n     * @return quoteTokenQty qty of quote token the user must supply\n     * @return liquidityTokenQty qty of liquidity tokens to be issued in exchange\n     */\n    function calculateAddQuoteTokenLiquidityQuantities(\n        uint256 _quoteTokenQtyDesired,\n        uint256 _baseTokenReserveQty,\n        uint256 _totalSupplyOfLiquidityTokens,\n        InternalBalances storage _internalBalances\n    ) public returns (uint256 quoteTokenQty, uint256 liquidityTokenQty) {\n        uint256 baseTokenDecay =\n            _baseTokenReserveQty - _internalBalances.baseTokenReserveQty;\n\n        // determine max amount of quote token that can be added to offset the current decay\n        uint256 wInternalBaseTokenToQuoteTokenRatio =\n            wDiv(\n                _internalBalances.baseTokenReserveQty,\n                _internalBalances.quoteTokenReserveQty\n            );\n\n        // alphaDecay / omega (A/B)\n        uint256 maxQuoteTokenQty =\n            wDiv(baseTokenDecay, wInternalBaseTokenToQuoteTokenRatio);\n\n        if (_quoteTokenQtyDesired > maxQuoteTokenQty) {\n            quoteTokenQty = maxQuoteTokenQty;\n        } else {\n            quoteTokenQty = _quoteTokenQtyDesired;\n        }\n\n        uint256 baseTokenQtyDecayChange =\n            roundToNearest(\n                (quoteTokenQty * wInternalBaseTokenToQuoteTokenRatio),\n                WAD\n            ) / WAD;\n\n        require(\n            baseTokenQtyDecayChange != 0,\n            \"MathLib: INSUFFICIENT_CHANGE_IN_DECAY\"\n        );\n        //x += alphaDecayChange\n        //y += deltaBeta\n        _internalBalances.baseTokenReserveQty += baseTokenQtyDecayChange;\n        _internalBalances.quoteTokenReserveQty += quoteTokenQty;\n\n        // calculate the number of liquidity tokens to return to user using\n        liquidityTokenQty = calculateLiquidityTokenQtyForSingleAssetEntryWithBaseTokenDecay(\n            _baseTokenReserveQty,\n            _totalSupplyOfLiquidityTokens,\n            quoteTokenQty,\n            _internalBalances.quoteTokenReserveQty,\n            wInternalBaseTokenToQuoteTokenRatio\n        );\n        return (quoteTokenQty, liquidityTokenQty);\n    }\n\n    /**\n     * @dev used to calculate the qty of base tokens required and liquidity tokens (deltaRo) to be issued\n     * in order to add liquidity and remove base token decay.\n     * @param _baseTokenQtyDesired the amount of base token the user wants to contribute\n     * @param _baseTokenQtyMin the minimum amount of base token the user wants to contribute (allows for slippage)\n     * @param _baseTokenReserveQty the external base token reserve qty prior to this transaction\n     * @param _totalSupplyOfLiquidityTokens the total supply of our exchange's liquidity tokens (aka Ro)\n     * @param _internalBalances internal balances struct from our exchange's internal accounting\n     *\n     * @return baseTokenQty qty of base token the user must supply\n     * @return liquidityTokenQty qty of liquidity tokens to be issued in exchange\n     */\n    function calculateAddBaseTokenLiquidityQuantities(\n        uint256 _baseTokenQtyDesired,\n        uint256 _baseTokenQtyMin,\n        uint256 _baseTokenReserveQty,\n        uint256 _totalSupplyOfLiquidityTokens,\n        InternalBalances memory _internalBalances\n    ) public pure returns (uint256 baseTokenQty, uint256 liquidityTokenQty) {\n        uint256 maxBaseTokenQty =\n            _internalBalances.baseTokenReserveQty - _baseTokenReserveQty;\n        require(\n            _baseTokenQtyMin <= maxBaseTokenQty,\n            \"MathLib: INSUFFICIENT_DECAY\"\n        );\n\n        if (_baseTokenQtyDesired > maxBaseTokenQty) {\n            baseTokenQty = maxBaseTokenQty;\n        } else {\n            baseTokenQty = _baseTokenQtyDesired;\n        }\n\n        // determine the quote token qty decay change quoted on our current ratios\n        uint256 wInternalQuoteToBaseTokenRatio =\n            wDiv(\n                _internalBalances.quoteTokenReserveQty,\n                _internalBalances.baseTokenReserveQty\n            );\n\n        // NOTE we need this function to use the same\n        // rounding scheme as wDiv in order to avoid a case\n        // in which a user is trying to resolve decay in which\n        // quoteTokenQtyDecayChange ends up being 0 and we are stuck in\n        // a bad state.\n        uint256 quoteTokenQtyDecayChange =\n            roundToNearest(\n                (baseTokenQty * wInternalQuoteToBaseTokenRatio),\n                MathLib.WAD\n            ) / WAD;\n\n        require(\n            quoteTokenQtyDecayChange != 0,\n            \"MathLib: INSUFFICIENT_CHANGE_IN_DECAY\"\n        );\n\n        // we can now calculate the total amount of quote token decay\n        uint256 quoteTokenDecay =\n            (maxBaseTokenQty * wInternalQuoteToBaseTokenRatio) / WAD;\n\n        // this may be redundant quoted on the above math, but will check to ensure the decay wasn't so small\n        // that it was <1 and rounded down to 0 saving the caller some gas\n        // also could fix a potential revert due to div by zero.\n        require(quoteTokenDecay != 0, \"MathLib: NO_QUOTE_DECAY\");\n\n        // we are not changing anything about our internal accounting here. We are simply adding tokens\n        // to make our internal account \"right\"...or rather getting the external balances to match our internal\n        // quoteTokenReserveQty += quoteTokenQtyDecayChange;\n        // baseTokenReserveQty += baseTokenQty;\n\n        // calculate the number of liquidity tokens to return to user using:\n        liquidityTokenQty = calculateLiquidityTokenQtyForSingleAssetEntryWithQuoteTokenDecay(\n            _baseTokenReserveQty,\n            _totalSupplyOfLiquidityTokens,\n            baseTokenQty,\n            _internalBalances.baseTokenReserveQty\n        );\n    }\n\n    /**\n     * @dev used to calculate the qty of tokens a user will need to contribute and be issued in order to add liquidity\n     * @param _baseTokenQtyDesired the amount of base token the user wants to contribute\n     * @param _quoteTokenQtyDesired the amount of quote token the user wants to contribute\n     * @param _baseTokenQtyMin the minimum amount of base token the user wants to contribute (allows for slippage)\n     * @param _quoteTokenQtyMin the minimum amount of quote token the user wants to contribute (allows for slippage)\n     * @param _baseTokenReserveQty the external base token reserve qty prior to this transaction\n     * @param _totalSupplyOfLiquidityTokens the total supply of our exchange's liquidity tokens (aka Ro)\n     * @param _internalBalances internal balances struct from our exchange's internal accounting\n     *\n     * @return tokenQtys qty of tokens needed to complete transaction\n     */\n    function calculateAddLiquidityQuantities(\n        uint256 _baseTokenQtyDesired,\n        uint256 _quoteTokenQtyDesired,\n        uint256 _baseTokenQtyMin,\n        uint256 _quoteTokenQtyMin,\n        uint256 _baseTokenReserveQty,\n        uint256 _totalSupplyOfLiquidityTokens,\n        InternalBalances storage _internalBalances\n    ) public returns (TokenQtys memory tokenQtys) {\n        if (_totalSupplyOfLiquidityTokens != 0) {\n            // we have outstanding liquidity tokens present and an existing price curve\n\n            tokenQtys.liquidityTokenFeeQty = calculateLiquidityTokenFees(\n                _totalSupplyOfLiquidityTokens,\n                _internalBalances\n            );\n\n            // we need to take this amount (that will be minted) into account for below calculations\n            _totalSupplyOfLiquidityTokens += tokenQtys.liquidityTokenFeeQty;\n\n            // confirm that we have no beta or alpha decay present\n            // if we do, we need to resolve that first\n            if (\n                isSufficientDecayPresent(\n                    _baseTokenReserveQty,\n                    _internalBalances\n                )\n            ) {\n                // decay is present and needs to be dealt with by the caller.\n\n                uint256 baseTokenQtyFromDecay;\n                uint256 quoteTokenQtyFromDecay;\n                uint256 liquidityTokenQtyFromDecay;\n\n                if (\n                    _baseTokenReserveQty > _internalBalances.baseTokenReserveQty\n                ) {\n                    // we have more base token than expected (base token decay) due to rebase up\n                    // we first need to handle this situation by requiring this user\n                    // to add quote tokens\n                    (\n                        quoteTokenQtyFromDecay,\n                        liquidityTokenQtyFromDecay\n                    ) = calculateAddQuoteTokenLiquidityQuantities(\n                        _quoteTokenQtyDesired,\n                        _baseTokenReserveQty,\n                        _totalSupplyOfLiquidityTokens,\n                        _internalBalances\n                    );\n                } else {\n                    // we have less base token than expected (quote token decay) due to a rebase down\n                    // we first need to handle this by adding base tokens to offset this.\n                    (\n                        baseTokenQtyFromDecay,\n                        liquidityTokenQtyFromDecay\n                    ) = calculateAddBaseTokenLiquidityQuantities(\n                        _baseTokenQtyDesired,\n                        0, // there is no minimum for this particular call since we may use base tokens later.\n                        _baseTokenReserveQty,\n                        _totalSupplyOfLiquidityTokens,\n                        _internalBalances\n                    );\n                }\n\n                if (\n                    quoteTokenQtyFromDecay < _quoteTokenQtyDesired &&\n                    baseTokenQtyFromDecay < _baseTokenQtyDesired\n                ) {\n                    // the user still has qty that they desire to contribute to the exchange for liquidity\n                    (\n                        tokenQtys.baseTokenQty,\n                        tokenQtys.quoteTokenQty,\n                        tokenQtys.liquidityTokenQty\n                    ) = calculateAddTokenPairLiquidityQuantities(\n                        _baseTokenQtyDesired - baseTokenQtyFromDecay, // safe from underflow quoted on above IF\n                        _quoteTokenQtyDesired - quoteTokenQtyFromDecay, // safe from underflow quoted on above IF\n                        0, // we will check minimums below\n                        0, // we will check minimums below\n                        _totalSupplyOfLiquidityTokens +\n                            liquidityTokenQtyFromDecay,\n                        _internalBalances // NOTE: these balances have already been updated when we did the decay math.\n                    );\n                }\n                tokenQtys.baseTokenQty += baseTokenQtyFromDecay;\n                tokenQtys.quoteTokenQty += quoteTokenQtyFromDecay;\n                tokenQtys.liquidityTokenQty += liquidityTokenQtyFromDecay;\n\n                require(\n                    tokenQtys.baseTokenQty >= _baseTokenQtyMin,\n                    \"MathLib: INSUFFICIENT_BASE_QTY\"\n                );\n\n                require(\n                    tokenQtys.quoteTokenQty >= _quoteTokenQtyMin,\n                    \"MathLib: INSUFFICIENT_QUOTE_QTY\"\n                );\n            } else {\n                // the user is just doing a simple double asset entry / providing both base and quote.\n                (\n                    tokenQtys.baseTokenQty,\n                    tokenQtys.quoteTokenQty,\n                    tokenQtys.liquidityTokenQty\n                ) = calculateAddTokenPairLiquidityQuantities(\n                    _baseTokenQtyDesired,\n                    _quoteTokenQtyDesired,\n                    _baseTokenQtyMin,\n                    _quoteTokenQtyMin,\n                    _totalSupplyOfLiquidityTokens,\n                    _internalBalances\n                );\n            }\n        } else {\n            // this user will set the initial pricing curve\n            require(\n                _baseTokenQtyDesired != 0,\n                \"MathLib: INSUFFICIENT_BASE_QTY_DESIRED\"\n            );\n            require(\n                _quoteTokenQtyDesired != 0,\n                \"MathLib: INSUFFICIENT_QUOTE_QTY_DESIRED\"\n            );\n\n            tokenQtys.baseTokenQty = _baseTokenQtyDesired;\n            tokenQtys.quoteTokenQty = _quoteTokenQtyDesired;\n            tokenQtys.liquidityTokenQty = sqrt(\n                _baseTokenQtyDesired * _quoteTokenQtyDesired\n            );\n\n            _internalBalances.baseTokenReserveQty += tokenQtys.baseTokenQty;\n            _internalBalances.quoteTokenReserveQty += tokenQtys.quoteTokenQty;\n        }\n    }\n\n    /**\n     * @dev calculates the qty of base and quote tokens required and liquidity tokens (deltaRo) to be issued\n     * in order to add liquidity when no decay is present.\n     * @param _baseTokenQtyDesired the amount of base token the user wants to contribute\n     * @param _quoteTokenQtyDesired the amount of quote token the user wants to contribute\n     * @param _baseTokenQtyMin the minimum amount of base token the user wants to contribute (allows for slippage)\n     * @param _quoteTokenQtyMin the minimum amount of quote token the user wants to contribute (allows for slippage)\n     * @param _totalSupplyOfLiquidityTokens the total supply of our exchange's liquidity tokens (aka Ro)\n     * @param _internalBalances internal balances struct from our exchange's internal accounting\n     *\n     * @return baseTokenQty qty of base token the user must supply\n     * @return quoteTokenQty qty of quote token the user must supply\n     * @return liquidityTokenQty qty of liquidity tokens to be issued in exchange\n     */\n    function calculateAddTokenPairLiquidityQuantities(\n        uint256 _baseTokenQtyDesired,\n        uint256 _quoteTokenQtyDesired,\n        uint256 _baseTokenQtyMin,\n        uint256 _quoteTokenQtyMin,\n        uint256 _totalSupplyOfLiquidityTokens,\n        InternalBalances storage _internalBalances\n    )\n        public\n        returns (\n            uint256 baseTokenQty,\n            uint256 quoteTokenQty,\n            uint256 liquidityTokenQty\n        )\n    {\n        uint256 requiredQuoteTokenQty =\n            calculateQty(\n                _baseTokenQtyDesired,\n                _internalBalances.baseTokenReserveQty,\n                _internalBalances.quoteTokenReserveQty\n            );\n\n        if (requiredQuoteTokenQty <= _quoteTokenQtyDesired) {\n            // user has to provide less than their desired amount\n            require(\n                requiredQuoteTokenQty >= _quoteTokenQtyMin,\n                \"MathLib: INSUFFICIENT_QUOTE_QTY\"\n            );\n            baseTokenQty = _baseTokenQtyDesired;\n            quoteTokenQty = requiredQuoteTokenQty;\n        } else {\n            // we need to check the opposite way.\n            uint256 requiredBaseTokenQty =\n                calculateQty(\n                    _quoteTokenQtyDesired,\n                    _internalBalances.quoteTokenReserveQty,\n                    _internalBalances.baseTokenReserveQty\n                );\n\n            require(\n                requiredBaseTokenQty >= _baseTokenQtyMin,\n                \"MathLib: INSUFFICIENT_BASE_QTY\"\n            );\n            baseTokenQty = requiredBaseTokenQty;\n            quoteTokenQty = _quoteTokenQtyDesired;\n        }\n\n        liquidityTokenQty = calculateLiquidityTokenQtyForDoubleAssetEntry(\n            _totalSupplyOfLiquidityTokens,\n            quoteTokenQty,\n            _internalBalances.quoteTokenReserveQty\n        );\n\n        _internalBalances.baseTokenReserveQty += baseTokenQty;\n        _internalBalances.quoteTokenReserveQty += quoteTokenQty;\n    }\n\n    /**\n     * @dev calculates the qty of base tokens a user will receive for swapping their quote tokens (less fees)\n     * @param _quoteTokenQty the amount of quote tokens the user wants to swap\n     * @param _baseTokenQtyMin the minimum about of base tokens they are willing to receive in return (slippage)\n     * @param _baseTokenReserveQty the external base token reserve qty prior to this transaction\n     * @param _liquidityFeeInBasisPoints the current total liquidity fee represented as an integer of basis points\n     * @param _internalBalances internal balances struct from our exchange's internal accounting\n     *\n     * @return baseTokenQty qty of base token the user will receive back\n     */\n    function calculateBaseTokenQty(\n        uint256 _quoteTokenQty,\n        uint256 _baseTokenQtyMin,\n        uint256 _baseTokenReserveQty,\n        uint256 _liquidityFeeInBasisPoints,\n        InternalBalances storage _internalBalances\n    ) public returns (uint256 baseTokenQty) {\n        require(\n            _baseTokenReserveQty != 0 &&\n                _internalBalances.baseTokenReserveQty != 0,\n            \"MathLib: INSUFFICIENT_BASE_TOKEN_QTY\"\n        );\n\n        // check to see if we have experience quote token decay / a rebase down event\n        if (_baseTokenReserveQty < _internalBalances.baseTokenReserveQty) {\n            // we have less reserves than our current price curve will expect, we need to adjust the curve\n            uint256 wPricingRatio =\n                wDiv(\n                    _internalBalances.baseTokenReserveQty,\n                    _internalBalances.quoteTokenReserveQty\n                ); // omega\n\n            uint256 impliedQuoteTokenQty =\n                wDiv(_baseTokenReserveQty, wPricingRatio); // no need to divide by WAD, wPricingRatio is already a WAD.\n\n            baseTokenQty = calculateQtyToReturnAfterFees(\n                _quoteTokenQty,\n                impliedQuoteTokenQty,\n                _baseTokenReserveQty, // use the actual balance here since we adjusted the quote token to match ratio!\n                _liquidityFeeInBasisPoints\n            );\n        } else {\n            // we have the same or more reserves, no need to alter the curve.\n            baseTokenQty = calculateQtyToReturnAfterFees(\n                _quoteTokenQty,\n                _internalBalances.quoteTokenReserveQty,\n                _internalBalances.baseTokenReserveQty,\n                _liquidityFeeInBasisPoints\n            );\n        }\n\n        require(\n            baseTokenQty >= _baseTokenQtyMin,\n            \"MathLib: INSUFFICIENT_BASE_TOKEN_QTY\"\n        );\n\n        _internalBalances.baseTokenReserveQty -= baseTokenQty;\n        _internalBalances.quoteTokenReserveQty += _quoteTokenQty;\n    }\n\n    /**\n     * @dev calculates the qty of quote tokens a user will receive for swapping their base tokens (less fees)\n     * @param _baseTokenQty the amount of bases tokens the user wants to swap\n     * @param _quoteTokenQtyMin the minimum about of quote tokens they are willing to receive in return (slippage)\n     * @param _liquidityFeeInBasisPoints the current total liquidity fee represented as an integer of basis points\n     * @param _internalBalances internal balances struct from our exchange's internal accounting\n     *\n     * @return quoteTokenQty qty of quote token the user will receive back\n     */\n    function calculateQuoteTokenQty(\n        uint256 _baseTokenQty,\n        uint256 _quoteTokenQtyMin,\n        uint256 _liquidityFeeInBasisPoints,\n        InternalBalances storage _internalBalances\n    ) public returns (uint256 quoteTokenQty) {\n        require(\n            _baseTokenQty != 0 && _quoteTokenQtyMin != 0,\n            \"MathLib: INSUFFICIENT_TOKEN_QTY\"\n        );\n\n        quoteTokenQty = calculateQtyToReturnAfterFees(\n            _baseTokenQty,\n            _internalBalances.baseTokenReserveQty,\n            _internalBalances.quoteTokenReserveQty,\n            _liquidityFeeInBasisPoints\n        );\n\n        require(\n            quoteTokenQty >= _quoteTokenQtyMin,\n            \"MathLib: INSUFFICIENT_QUOTE_TOKEN_QTY\"\n        );\n\n        _internalBalances.baseTokenReserveQty += _baseTokenQty;\n        _internalBalances.quoteTokenReserveQty -= quoteTokenQty;\n    }\n\n    /**\n     * @dev calculates the qty of liquidity tokens that should be sent to the DAO due to the growth in K from trading.\n     * 50BPS is the total fee, 25 goes to the LPs, 5 BP to the DAO, and 20 BP to staking rewards and liquidity incentives\n     * @param _totalSupplyOfLiquidityTokens the total supply of our exchange's liquidity tokens (aka Ro)\n     * @param _internalBalances internal balances struct from our exchange's internal accounting\n     *\n     * @return liquidityTokenFeeQty qty of tokens to be minted to the fee address for the growth in K\n     */\n    function calculateLiquidityTokenFees(\n        uint256 _totalSupplyOfLiquidityTokens,\n        InternalBalances memory _internalBalances\n    ) public pure returns (uint256 liquidityTokenFeeQty) {\n        uint256 rootK =\n            sqrt(\n                _internalBalances.baseTokenReserveQty *\n                    _internalBalances.quoteTokenReserveQty\n            );\n        uint256 rootKLast = sqrt(_internalBalances.kLast);\n        if (rootK > rootKLast) {\n            uint256 numerator =\n                _totalSupplyOfLiquidityTokens * (rootK - rootKLast);\n            uint256 denominator = rootK * 2;\n            liquidityTokenFeeQty = numerator / denominator;\n        }\n    }\n}\n"
    }
  }
}}