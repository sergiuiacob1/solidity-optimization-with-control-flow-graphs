{{
  "language": "Solidity",
  "settings": {
    "evmVersion": "istanbul",
    "libraries": {},
    "metadata": {
      "bytecodeHash": "ipfs",
      "useLiteralContent": true
    },
    "optimizer": {
      "details": {
        "constantOptimizer": true,
        "cse": true,
        "deduplicate": true,
        "jumpdestRemover": true,
        "orderLiterals": true,
        "peephole": true,
        "yul": false
      },
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "contracts/persistent/dispatcher/IDispatcher.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title IDispatcher Interface\n/// @author Enzyme Council <security@enzyme.finance>\ninterface IDispatcher {\n    function cancelMigration(address _vaultProxy, bool _bypassFailure) external;\n\n    function claimOwnership() external;\n\n    function deployVaultProxy(\n        address _vaultLib,\n        address _owner,\n        address _vaultAccessor,\n        string calldata _fundName\n    ) external returns (address vaultProxy_);\n\n    function executeMigration(address _vaultProxy, bool _bypassFailure) external;\n\n    function getCurrentFundDeployer() external view returns (address currentFundDeployer_);\n\n    function getFundDeployerForVaultProxy(address _vaultProxy)\n        external\n        view\n        returns (address fundDeployer_);\n\n    function getMigrationRequestDetailsForVaultProxy(address _vaultProxy)\n        external\n        view\n        returns (\n            address nextFundDeployer_,\n            address nextVaultAccessor_,\n            address nextVaultLib_,\n            uint256 executableTimestamp_\n        );\n\n    function getMigrationTimelock() external view returns (uint256 migrationTimelock_);\n\n    function getNominatedOwner() external view returns (address nominatedOwner_);\n\n    function getOwner() external view returns (address owner_);\n\n    function getSharesTokenSymbol() external view returns (string memory sharesTokenSymbol_);\n\n    function getTimelockRemainingForMigrationRequest(address _vaultProxy)\n        external\n        view\n        returns (uint256 secondsRemaining_);\n\n    function hasExecutableMigrationRequest(address _vaultProxy)\n        external\n        view\n        returns (bool hasExecutableRequest_);\n\n    function hasMigrationRequest(address _vaultProxy)\n        external\n        view\n        returns (bool hasMigrationRequest_);\n\n    function removeNominatedOwner() external;\n\n    function setCurrentFundDeployer(address _nextFundDeployer) external;\n\n    function setMigrationTimelock(uint256 _nextTimelock) external;\n\n    function setNominatedOwner(address _nextNominatedOwner) external;\n\n    function setSharesTokenSymbol(string calldata _nextSymbol) external;\n\n    function signalMigration(\n        address _vaultProxy,\n        address _nextVaultAccessor,\n        address _nextVaultLib,\n        bool _bypassFailure\n    ) external;\n}\n"
    },
    "contracts/persistent/global-config/GlobalConfigLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n    (c) Enzyme Council <council@enzyme.finance>\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"./bases/GlobalConfigLibBase1.sol\";\nimport \"./interfaces/IGlobalConfig1.sol\";\nimport \"./interfaces/IGlobalConfigVaultAccessGetter.sol\";\n\n/// @title GlobalConfigLib Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice The proxiable library contract for GlobalConfigProxy\n/// @dev Only supports releases v4 and higher\ncontract GlobalConfigLib is IGlobalConfig1, GlobalConfigLibBase1 {\n    bytes4 private constant REDEEM_IN_KIND_V4 = 0x6af8e7eb;\n    bytes4 private constant REDEEM_SPECIFIC_ASSETS_V4 = 0x3462fcc1;\n\n    address private immutable FUND_DEPLOYER_V4;\n\n    constructor(address _fundDeployerV4) public {\n        FUND_DEPLOYER_V4 = _fundDeployerV4;\n    }\n\n    /// @notice Validates whether a call to redeem shares is valid for the shares version\n    /// @param _vaultProxy The VaultProxy (shares token)\n    /// @param _recipientToValidate The intended recipient of the assets received from the redemption\n    /// @param _sharesAmountToValidate The intended amount of shares to redeem\n    /// @param _redeemContract The contract to call\n    /// @param _redeemSelector The selector to call\n    /// @param _redeemData The encoded params to call\n    /// @return isValid_ True if valid\n    /// @dev Use  NO_VALIDATION_ constants to skip optional validation of recipient and/or amount\n    function isValidRedeemSharesCall(\n        address _vaultProxy,\n        address _recipientToValidate,\n        uint256 _sharesAmountToValidate,\n        address _redeemContract,\n        bytes4 _redeemSelector,\n        bytes calldata _redeemData\n    ) external view override returns (bool isValid_) {\n        // Get release for _vaultProxy\n        address fundDeployer = IDispatcher(getDispatcher()).getFundDeployerForVaultProxy(\n            _vaultProxy\n        );\n\n        // Validate call data based on release\n        if (fundDeployer == FUND_DEPLOYER_V4) {\n            // Validate contract\n            if (_redeemContract != IGlobalConfigVaultAccessGetter(_vaultProxy).getAccessor()) {\n                return false;\n            }\n\n            // Validate selector\n            if (\n                !(_redeemSelector == REDEEM_SPECIFIC_ASSETS_V4 ||\n                    _redeemSelector == REDEEM_IN_KIND_V4)\n            ) {\n                return false;\n            }\n\n            // Both functions have the same first two params so we can ignore the rest of _redeemData\n            (address encodedRecipient, uint256 encodedSharesAmount) = abi.decode(\n                _redeemData,\n                (address, uint256)\n            );\n\n            // Optionally validate recipient\n            if (\n                _recipientToValidate != NO_VALIDATION_DUMMY_ADDRESS &&\n                _recipientToValidate != encodedRecipient\n            ) {\n                return false;\n            }\n\n            // Optionally validate shares amount\n            if (\n                _sharesAmountToValidate != NO_VALIDATION_DUMMY_AMOUNT &&\n                _sharesAmountToValidate != encodedSharesAmount\n            ) {\n                return false;\n            }\n\n            return true;\n        }\n\n        return false;\n    }\n}\n"
    },
    "contracts/persistent/global-config/bases/GlobalConfigLibBase1.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"./GlobalConfigLibBaseCore.sol\";\n\n/// @title GlobalConfigLibBase1 Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice A base implementation for GlobalConfigLib\n/// @dev Each next base implementation inherits the previous base implementation,\n/// e.g., `GlobalConfigLibBase2 is GlobalConfigLibBase1`\n/// DO NOT EDIT CONTRACT.\nabstract contract GlobalConfigLibBase1 is GlobalConfigLibBaseCore {\n    address\n        internal constant NO_VALIDATION_DUMMY_ADDRESS = 0x000000000000000000000000000000000000aaaa;\n    // Don't use max, since a max value can be valid\n    uint256 internal constant NO_VALIDATION_DUMMY_AMOUNT = type(uint256).max - 1;\n}\n"
    },
    "contracts/persistent/global-config/bases/GlobalConfigLibBaseCore.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n    (c) Enzyme Council <council@enzyme.finance>\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"../../../persistent/dispatcher/IDispatcher.sol\";\nimport \"../utils/ProxiableGlobalConfigLib.sol\";\n\n/// @title GlobalConfigLibBaseCore Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice The core implementation of GlobalConfigLib\n/// @dev To be inherited by the first GlobalConfigLibBase implementation only.\n/// DO NOT EDIT CONTRACT.\nabstract contract GlobalConfigLibBaseCore is ProxiableGlobalConfigLib {\n    event GlobalConfigLibSet(address nextGlobalConfigLib);\n\n    address internal dispatcher;\n\n    modifier onlyDispatcherOwner {\n        require(\n            msg.sender == IDispatcher(getDispatcher()).getOwner(),\n            \"Only the Dispatcher owner can call this function\"\n        );\n\n        _;\n    }\n\n    /// @notice Initializes the GlobalConfigProxy with core configuration\n    /// @param _dispatcher The Dispatcher contract\n    /// @dev Serves as a pseudo-constructor\n    function init(address _dispatcher) external {\n        require(getDispatcher() == address(0), \"init: Proxy already initialized\");\n\n        dispatcher = _dispatcher;\n\n        emit GlobalConfigLibSet(getGlobalConfigLib());\n    }\n\n    /// @notice Sets the GlobalConfigLib target for the GlobalConfigProxy\n    /// @param _nextGlobalConfigLib The address to set as the GlobalConfigLib\n    /// @dev This function is absolutely critical. __updateCodeAddress() validates that the\n    /// target is a valid Proxiable contract instance.\n    /// Does not block _nextGlobalConfigLib from being the same as the current GlobalConfigLib\n    function setGlobalConfigLib(address _nextGlobalConfigLib) external onlyDispatcherOwner {\n        __updateCodeAddress(_nextGlobalConfigLib);\n\n        emit GlobalConfigLibSet(_nextGlobalConfigLib);\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Gets the `dispatcher` variable\n    /// @return dispatcher_ The `dispatcher` variable value\n    function getDispatcher() public view returns (address dispatcher_) {\n        return dispatcher;\n    }\n\n    /// @notice Gets the GlobalConfigLib target for the GlobalConfigProxy\n    /// @return globalConfigLib_ The address of the GlobalConfigLib target\n    function getGlobalConfigLib() public view returns (address globalConfigLib_) {\n        assembly {\n            globalConfigLib_ := sload(EIP_1967_SLOT)\n        }\n\n        return globalConfigLib_;\n    }\n}\n"
    },
    "contracts/persistent/global-config/interfaces/IGlobalConfig1.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title IGlobalConfig1 Interface\n/// @author Enzyme Council <security@enzyme.finance>\n/// @dev Each interface should inherit the previous interface,\n/// e.g., `IGlobalConfig2 is IGlobalConfig1`\ninterface IGlobalConfig1 {\n    function isValidRedeemSharesCall(\n        address _vaultProxy,\n        address _recipientToValidate,\n        uint256 _sharesAmountToValidate,\n        address _redeemContract,\n        bytes4 _redeemSelector,\n        bytes calldata _redeemData\n    ) external view returns (bool isValid_);\n}\n"
    },
    "contracts/persistent/global-config/interfaces/IGlobalConfigVaultAccessGetter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title IGlobalConfigVaultAccessGetter Interface\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Vault access getters related to VaultLib from v2 to present\ninterface IGlobalConfigVaultAccessGetter {\n    function getAccessor() external view returns (address);\n}\n"
    },
    "contracts/persistent/global-config/utils/GlobalConfigProxyConstants.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title GlobalConfigProxyConstants Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Constant values used in GlobalConfig proxy-related contracts\nabstract contract GlobalConfigProxyConstants {\n    // `bytes32(keccak256('mln.proxiable.globalConfigLib'))`\n    bytes32\n        internal constant EIP_1822_PROXIABLE_UUID = 0xf25d88d51901d7fabc9924b03f4c2fe4300e6fe1aae4b5134c0a90b68cd8e81c;\n    // `bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)`\n    bytes32\n        internal constant EIP_1967_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n}\n"
    },
    "contracts/persistent/global-config/utils/ProxiableGlobalConfigLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n    (c) Enzyme Council <council@enzyme.finance>\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"./GlobalConfigProxyConstants.sol\";\n\n/// @title ProxiableGlobalConfigLib Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice A contract that defines the upgrade behavior for GlobalConfigLib instances\n/// @dev The recommended implementation of the target of a proxy according to EIP-1822 and EIP-1967\n/// See: https://eips.ethereum.org/EIPS/eip-1822\n/// See: https://eips.ethereum.org/EIPS/eip-1967\nabstract contract ProxiableGlobalConfigLib is GlobalConfigProxyConstants {\n    /// @dev Updates the target of the proxy to be the contract at _nextGlobalConfigLib\n    function __updateCodeAddress(address _nextGlobalConfigLib) internal {\n        require(\n            ProxiableGlobalConfigLib(_nextGlobalConfigLib).proxiableUUID() ==\n                bytes32(EIP_1822_PROXIABLE_UUID),\n            \"__updateCodeAddress: _nextGlobalConfigLib not compatible\"\n        );\n        assembly {\n            sstore(EIP_1967_SLOT, _nextGlobalConfigLib)\n        }\n    }\n\n    /// @notice Returns a unique bytes32 hash for GlobalConfigLib instances\n    /// @return uuid_ The bytes32 hash representing the UUID\n    function proxiableUUID() public pure returns (bytes32 uuid_) {\n        return EIP_1822_PROXIABLE_UUID;\n    }\n}\n"
    }
  }
}}