{{
  "language": "Solidity",
  "settings": {
    "evmVersion": "london",
    "libraries": {},
    "metadata": {
      "bytecodeHash": "ipfs",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "contracts/UnifarmRewardRegistryUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: GNU GPLv3\n\npragma solidity =0.8.9;\n\nimport {OwnableUpgradeable} from './access/OwnableUpgradeable.sol';\nimport {TransferHelpers} from './library/TransferHelpers.sol';\nimport {IWETH} from './interfaces/IWETH.sol';\nimport {Initializable} from './proxy/Initializable.sol';\nimport {UnifarmRewardRegistryUpgradeableStorage} from './storage/UnifarmRewardRegistryUpgradeableStorage.sol';\nimport {IUnifarmRewardRegistryUpgradeable} from './interfaces/IUnifarmRewardRegistryUpgradeable.sol';\n\n/// @title UnifarmRewardRegistryUpgradeable Contract\n/// @author UNIFARM\n/// @notice contract handles rewards mechanism of unifarm cohorts\n\ncontract UnifarmRewardRegistryUpgradeable is\n    IUnifarmRewardRegistryUpgradeable,\n    UnifarmRewardRegistryUpgradeableStorage,\n    Initializable,\n    OwnableUpgradeable\n{\n    /**\n     * @dev not throws if called by owner or multicall\n     */\n\n    modifier onlyMulticallOrOwner() {\n        onlyOwnerOrMulticall();\n        _;\n    }\n\n    /**\n     * @dev verifying valid caller\n     */\n\n    function onlyOwnerOrMulticall() internal view {\n        require(_msgSender() == multiCall || _msgSender() == owner(), 'IS');\n    }\n\n    /**\n     * @notice initialize the reward registry\n     * @param masterAddress master wallet address\n     * @param trustedForwarder trusted forwarder address\n     * @param multiCall_ multicall contract address\n     * @param referralPercentage referral percentage in 3 precised decimals\n     */\n\n    function __UnifarmRewardRegistryUpgradeable_init(\n        address masterAddress,\n        address trustedForwarder,\n        address multiCall_,\n        uint256 referralPercentage\n    ) external initializer {\n        __UnifarmRewardRegistryUpgradeable_init_unchained(multiCall_, referralPercentage);\n        __Ownable_init(masterAddress, trustedForwarder);\n    }\n\n    /**\n     * @dev set default referral and multicall\n     * @param multiCall_ multicall contract address\n     * @param referralPercentage referral percentage in 3 precised decimals\n     */\n\n    function __UnifarmRewardRegistryUpgradeable_init_unchained(address multiCall_, uint256 referralPercentage) internal {\n        multiCall = multiCall_;\n        refPercentage = referralPercentage;\n    }\n\n    /**\n     * @inheritdoc IUnifarmRewardRegistryUpgradeable\n     */\n\n    function updateRefPercentage(uint256 newRefPercentage) external override onlyMulticallOrOwner {\n        refPercentage = newRefPercentage;\n        emit UpdatedRefPercentage(newRefPercentage);\n    }\n\n    /**\n     * @inheritdoc IUnifarmRewardRegistryUpgradeable\n     */\n\n    function addInfluencers(address[] memory userAddresses, uint256[] memory referralPercentages) external override onlyMulticallOrOwner {\n        require(userAddresses.length == referralPercentages.length, 'AIF');\n        uint8 usersLength = uint8(userAddresses.length);\n        uint8 k;\n        while (k < usersLength) {\n            referralConfig[userAddresses[k]] = ReferralConfiguration({userAddress: userAddresses[k], referralPercentage: referralPercentages[k]});\n            k++;\n        }\n    }\n\n    /**\n     * @inheritdoc IUnifarmRewardRegistryUpgradeable\n     */\n\n    function updateMulticall(address newMultiCallAddress) external onlyOwner {\n        require(newMultiCallAddress != multiCall, 'SMA');\n        multiCall = newMultiCallAddress;\n    }\n\n    /**\n     * @inheritdoc IUnifarmRewardRegistryUpgradeable\n     */\n\n    function setRewardCap(\n        address cohortId,\n        address[] memory rewardTokenAddresses,\n        uint256[] memory rewards\n    ) external override onlyMulticallOrOwner returns (bool) {\n        require(cohortId != address(0), 'ICI');\n        require(rewardTokenAddresses.length == rewards.length, 'IL');\n        uint8 rewardTokensLength = uint8(rewardTokenAddresses.length);\n        for (uint8 v = 0; v < rewardTokensLength; v++) {\n            require(rewards[v] > 0, 'IRA');\n            rewardCap[cohortId][rewardTokenAddresses[v]] = rewards[v];\n        }\n        return true;\n    }\n\n    /**\n     * @inheritdoc IUnifarmRewardRegistryUpgradeable\n     */\n\n    function setRewardTokenDetails(address cohortId, bytes calldata rewards) external onlyMulticallOrOwner {\n        require(cohortId != address(0), 'ICI');\n        _rewards[cohortId] = rewards;\n        emit SetRewardTokenDetails(cohortId, rewards);\n    }\n\n    /**\n     * @inheritdoc IUnifarmRewardRegistryUpgradeable\n     */\n\n    function getRewardTokens(address cohortId) public view returns (address[] memory rewardTokens, uint256[] memory pbr) {\n        bytes memory rewardByte = _rewards[cohortId];\n        (rewardTokens, pbr) = abi.decode(rewardByte, (address[], uint256[]));\n    }\n\n    /**\n     * @inheritdoc IUnifarmRewardRegistryUpgradeable\n     */\n\n    function getInfluencerReferralPercentage(address influencerAddress) public view override returns (uint256 referralPercentage) {\n        ReferralConfiguration memory referral = referralConfig[influencerAddress];\n        bool isConfigurationAvailable = referral.userAddress != address(0);\n        if (isConfigurationAvailable) {\n            referralPercentage = referral.referralPercentage;\n        } else {\n            referralPercentage = refPercentage;\n        }\n    }\n\n    /**\n     * @dev performs single token transfer to user\n     * @param cohortId cohort contract address\n     * @param rewardTokenAddress reward token address\n     * @param user user address\n     * @param referralAddress influencer address\n     * @param referralPercentage referral percentage\n     * @param pbr1 per block reward for first reward token\n     * @param rValue Aggregated R Value\n     * @param hasContainWrapToken has reward contain wToken\n     */\n\n    function sendOne(\n        address cohortId,\n        address rewardTokenAddress,\n        address user,\n        address referralAddress,\n        uint256 referralPercentage,\n        uint256 pbr1,\n        uint256 rValue,\n        bool hasContainWrapToken\n    ) internal {\n        uint256 rewardValue = (pbr1 * rValue) / (1e12);\n        require(rewardCap[cohortId][rewardTokenAddress] >= rewardValue, 'RCR');\n        uint256 refEarned = (rewardValue * referralPercentage) / (100000);\n        uint256 userEarned = rewardValue - refEarned;\n        bool zero = referralAddress != address(0);\n        if (hasContainWrapToken) {\n            IWETH(rewardTokenAddress).withdraw(rewardValue);\n            if (zero) TransferHelpers.safeTransferParentChainToken(referralAddress, refEarned);\n            TransferHelpers.safeTransferParentChainToken(user, userEarned);\n        } else {\n            if (zero) TransferHelpers.safeTransfer(rewardTokenAddress, referralAddress, refEarned);\n            TransferHelpers.safeTransfer(rewardTokenAddress, user, userEarned);\n        }\n        rewardCap[cohortId][rewardTokenAddress] = rewardCap[cohortId][rewardTokenAddress] - rewardValue;\n    }\n\n    /**\n     * @dev perform multi token transfers to user\n     * @param cohortId cohort contract address\n     * @param rewardTokens array of reward token addresses\n     * @param pbr array of per block rewards\n     * @param userAddress user address\n     * @param referralAddress influencer address\n     * @param referralPercentage referral percentage\n     * @param rValue Aggregated R Value\n     */\n\n    function sendMulti(\n        address cohortId,\n        address[] memory rewardTokens,\n        uint256[] memory pbr,\n        address userAddress,\n        address referralAddress,\n        uint256 referralPercentage,\n        uint256 rValue\n    ) internal {\n        uint8 rTokensLength = uint8(rewardTokens.length);\n        for (uint8 r = 1; r < rTokensLength; r++) {\n            uint256 exactReward = (pbr[r] * rValue) / 1e12;\n            require(rewardCap[cohortId][rewardTokens[r]] >= exactReward, 'RCR');\n            uint256 refEarned = (exactReward * referralPercentage) / 100000;\n            uint256 userEarned = exactReward - refEarned;\n            if (referralAddress != address(0)) TransferHelpers.safeTransfer(rewardTokens[r], referralAddress, refEarned);\n            TransferHelpers.safeTransfer(rewardTokens[r], userAddress, userEarned);\n            rewardCap[cohortId][rewardTokens[r]] = rewardCap[cohortId][rewardTokens[r]] - exactReward;\n        }\n    }\n\n    /**\n     * @inheritdoc IUnifarmRewardRegistryUpgradeable\n     */\n\n    function distributeRewards(\n        address cohortId,\n        address userAddress,\n        address influcenerAddress,\n        uint256 rValue,\n        bool hasContainsWrappedToken\n    ) external override {\n        require(_msgSender() == cohortId, 'IS');\n        (address[] memory rewardTokens, uint256[] memory pbr) = getRewardTokens(cohortId);\n        uint256 referralPercentage = getInfluencerReferralPercentage(influcenerAddress);\n        sendOne(cohortId, rewardTokens[0], userAddress, influcenerAddress, referralPercentage, pbr[0], rValue, hasContainsWrappedToken);\n        sendMulti(cohortId, rewardTokens, pbr, userAddress, influcenerAddress, referralPercentage, rValue);\n    }\n\n    /**\n     * @inheritdoc IUnifarmRewardRegistryUpgradeable\n     */\n\n    function safeWithdrawEth(address withdrawableAddress, uint256 amount) external onlyOwner returns (bool) {\n        require(withdrawableAddress != address(0), 'IWA');\n        TransferHelpers.safeTransferParentChainToken(withdrawableAddress, amount);\n        return true;\n    }\n\n    /**\n     * @inheritdoc IUnifarmRewardRegistryUpgradeable\n     */\n\n    function safeWithdrawAll(\n        address withdrawableAddress,\n        address[] memory tokens,\n        uint256[] memory amounts\n    ) external onlyOwner {\n        require(withdrawableAddress != address(0), 'IWA');\n        require(tokens.length == amounts.length, 'SF');\n        uint8 i = 0;\n        uint8 tokensLength = uint8(tokens.length);\n        while (i < tokensLength) {\n            TransferHelpers.safeTransfer(tokens[i], withdrawableAddress, amounts[i]);\n            i++;\n        }\n    }\n\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: GNU GPLv3\n\n// OpenZeppelin Contracts v4.3.2 (access/Ownable.sol)\n\npragma solidity =0.8.9;\n\nimport {ERC2771ContextUpgradeable} from '../metatx/ERC2771ContextUpgradeable.sol';\nimport {Initializable} from '../proxy/Initializable.sol';\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner\n */\n\nabstract contract OwnableUpgradeable is Initializable, ERC2771ContextUpgradeable {\n    address private _owner;\n    address private _master;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner\n     */\n    function __Ownable_init(address master, address trustedForwarder) internal initializer {\n        __Ownable_init_unchained(master);\n        __ERC2771ContextUpgradeable_init(trustedForwarder);\n    }\n\n    function __Ownable_init_unchained(address masterAddress) internal initializer {\n        _transferOwnership(_msgSender());\n        _master = masterAddress;\n    }\n\n    /**\n     * @dev Returns the address of the current owner\n     * @return _owner - _owner address\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), 'ONA');\n        _;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the master\n     */\n    modifier onlyMaster() {\n        require(_master == _msgSender(), 'OMA');\n        _;\n    }\n\n    /**\n     * @dev Transfering the owner ship to master role in case of emergency\n     *\n     * NOTE: Renouncing ownership will transfer the contract ownership to master role\n     */\n\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(_master);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`)\n     * Can only be called by the current owner\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), 'INA');\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`)\n     * Internal function without access restriction\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/interfaces/IUnifarmRewardRegistryUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: GNU GPLv3\n\npragma solidity =0.8.9;\n\ninterface IUnifarmRewardRegistryUpgradeable {\n    /**\n     * @notice function is used to distribute cohort rewards\n     * @dev only cohort contract can access this function\n     * @param cohortId cohort contract address\n     * @param userAddress user wallet address\n     * @param influencerAddress influencer wallet address\n     * @param rValue Aggregated R value\n     * @param hasContainsWrappedToken has contain wrap token in rewards\n     */\n\n    function distributeRewards(\n        address cohortId,\n        address userAddress,\n        address influencerAddress,\n        uint256 rValue,\n        bool hasContainsWrappedToken\n    ) external;\n\n    /**\n     * @notice admin can add more influencers with some percentage\n     * @dev can only be called by owner or multicall\n     * @param userAddresses list of influencers wallet addresses\n     * @param referralPercentages list of referral percentages\n     */\n\n    function addInfluencers(address[] memory userAddresses, uint256[] memory referralPercentages) external;\n\n    /**\n     * @notice update multicall contract address\n     * @dev only called by owner access\n     * @param newMultiCallAddress new multicall address\n     */\n\n    function updateMulticall(address newMultiCallAddress) external;\n\n    /**\n     * @notice update default referral percenatge\n     * @dev can only be called by owner or multicall\n     * @param newRefPercentage referral percentage in 3 decimals\n     */\n\n    function updateRefPercentage(uint256 newRefPercentage) external;\n\n    /**\n     * @notice set reward tokens for a particular cohort\n     * @dev function can be called by only owner\n     * @param cohortId cohort contract address\n     * @param rewards per block rewards in bytes\n     */\n\n    function setRewardTokenDetails(address cohortId, bytes calldata rewards) external;\n\n    /**\n     * @notice set reward cap for particular cohort\n     * @dev function can be called by only owner\n     * @param cohortId cohort address\n     * @param rewardTokenAddresses reward token addresses\n     * @param rewards rewards available\n     * @return Transaction Status\n     */\n\n    function setRewardCap(\n        address cohortId,\n        address[] memory rewardTokenAddresses,\n        uint256[] memory rewards\n    ) external returns (bool);\n\n    /**\n     * @notice rescue ethers\n     * @dev can called by only owner in rare sitution\n     * @param withdrawableAddress withdrawable address\n     * @param amount to send\n     * @return Transaction Status\n     */\n\n    function safeWithdrawEth(address withdrawableAddress, uint256 amount) external returns (bool);\n\n    /**\n      @notice withdraw list of erc20 tokens in emergency sitution\n      @dev can called by only owner on worst sitution  \n      @param withdrawableAddress withdrawble wallet address\n      @param tokens list of token address\n      @param amounts list of amount to withdraw\n     */\n\n    function safeWithdrawAll(\n        address withdrawableAddress,\n        address[] memory tokens,\n        uint256[] memory amounts\n    ) external;\n\n    /**\n     * @notice derive reward tokens for a specfic cohort\n     * @param cohortId cohort address\n     * @return rewardTokens array of reward token address\n     * @return pbr array of per block reward\n     */\n\n    function getRewardTokens(address cohortId) external view returns (address[] memory rewardTokens, uint256[] memory pbr);\n\n    /**\n     * @notice get influencer referral percentage\n     * @return referralPercentage the referral percentage\n     */\n\n    function getInfluencerReferralPercentage(address influencerAddress) external view returns (uint256 referralPercentage);\n\n    /**\n     * @notice emit when referral percetage updated\n     * @param newRefPercentage - new referral percentage\n     */\n    event UpdatedRefPercentage(uint256 newRefPercentage);\n\n    /**\n     * @notice set reward token details\n     * @param cohortId - cohort address\n     * @param rewards - list of token address and rewards\n     */\n    event SetRewardTokenDetails(address indexed cohortId, bytes rewards);\n}\n"
    },
    "contracts/interfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: GNU GPLv3\n\npragma solidity =0.8.9;\n\ninterface IWETH {\n    /**\n     * @dev deposit eth to the contract\n     */\n\n    function deposit() external payable;\n\n    /**\n     * @dev transfer allows to transfer to a wallet or contract address\n     * @param to recipient address\n     * @param value amount to be transfered\n     * @return Transfer status.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev allow to withdraw weth from contract\n     */\n\n    function withdraw(uint256) external;\n}\n"
    },
    "contracts/library/TransferHelpers.sol": {
      "content": "// SPDX-License-Identifier: GNU GPLv3\n\npragma solidity =0.8.9;\n\n// solhint-disable  avoid-low-level-calls\n\n/// @title TransferHelpers library\n/// @author UNIFARM\n/// @notice handles token transfers and ethereum transfers for protocol\n/// @dev all the functions are internally used in the protocol\n\nlibrary TransferHelpers {\n    /**\n     * @dev make sure about approval before use this function\n     * @param target A ERC20 token address\n     * @param sender sender wallet address\n     * @param recipient receiver wallet Address\n     * @param amount number of tokens to transfer\n     */\n\n    function safeTransferFrom(\n        address target,\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory data) = target.call(abi.encodeWithSelector(0x23b872dd, sender, recipient, amount));\n        require(success && data.length > 0, 'STFF');\n    }\n\n    /**\n     * @notice transfer any erc20 token\n     * @param target ERC20 token address\n     * @param to receiver wallet address\n     * @param amount number of tokens to transfer\n     */\n\n    function safeTransfer(\n        address target,\n        address to,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory data) = target.call(abi.encodeWithSelector(0xa9059cbb, to, amount));\n        require(success && data.length > 0, 'STF');\n    }\n\n    /**\n     * @notice transfer parent chain token\n     * @param to receiver wallet address\n     * @param value of eth to transfer\n     */\n\n    function safeTransferParentChainToken(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: uint128(value)}(new bytes(0));\n        require(success, 'STPCF');\n    }\n}\n"
    },
    "contracts/metatx/ERC2771ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: GNU GPLv3\n\npragma solidity =0.8.9;\n\nimport {Initializable} from '../proxy/Initializable.sol';\n\n/**\n * @dev Context variant with ERC2771 support\n */\n\n// solhint-disable\nabstract contract ERC2771ContextUpgradeable is Initializable {\n    /**\n     * @dev holds the trust forwarder\n     */\n\n    address public trustedForwarder;\n\n    /**\n     * @dev context upgradeable initializer\n     * @param tForwarder trust forwarder\n     */\n\n    function __ERC2771ContextUpgradeable_init(address tForwarder) internal initializer {\n        __ERC2771ContextUpgradeable_init_unchained(tForwarder);\n    }\n\n    /**\n     * @dev called by initializer to set trust forwarder\n     * @param tForwarder trust forwarder\n     */\n\n    function __ERC2771ContextUpgradeable_init_unchained(address tForwarder) internal {\n        trustedForwarder = tForwarder;\n    }\n\n    /**\n     * @dev check if the given address is trust forwarder\n     * @param forwarder forwarder address\n     * @return isForwarder true/false\n     */\n\n    function isTrustedForwarder(address forwarder) public view virtual returns (bool) {\n        return forwarder == trustedForwarder;\n    }\n\n    /**\n     * @dev if caller is trusted forwarder will return exact sender.\n     * @return sender wallet address\n     */\n\n    function _msgSender() internal view virtual returns (address sender) {\n        if (isTrustedForwarder(msg.sender)) {\n            // The assembly code is more direct than the Solidity version using `abi.decode`.\n            assembly {\n                sender := shr(96, calldataload(sub(calldatasize(), 20)))\n            }\n        } else {\n            return msg.sender;\n        }\n    }\n\n    /**\n     * @dev returns msg data for called function\n     * @return function call data\n     */\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        if (isTrustedForwarder(msg.sender)) {\n            return msg.data[:msg.data.length - 20];\n        } else {\n            return msg.data;\n        }\n    }\n}\n"
    },
    "contracts/proxy/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/utils/Initializable.sol)\n\npragma solidity =0.8.9;\n\nimport '../utils/AddressUpgradeable.sol';\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() initializer {}\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice\n     */\n    modifier initializer() {\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\n        // contract may have been reentered\n        require(_initializing ? _isConstructor() : !_initialized, 'CIAI');\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} modifier, directly or indirectly\n     */\n    modifier onlyInitializing() {\n        require(_initializing, 'CINI');\n        _;\n    }\n\n    function _isConstructor() private view returns (bool) {\n        return !AddressUpgradeable.isContract(address(this));\n    }\n}\n"
    },
    "contracts/storage/UnifarmRewardRegistryUpgradeableStorage.sol": {
      "content": "// SPDX-License-Identifier: GNU GPLv3\n\npragma solidity =0.8.9;\n\nabstract contract UnifarmRewardRegistryUpgradeableStorage {\n    // solhint-disable-next-line\n    receive() external payable {}\n\n    /// @notice referral percentage\n    uint256 public refPercentage;\n\n    /// @notice struct to store referral commision for each unifarm influceners.\n    struct ReferralConfiguration {\n        // influencer wallet address.\n        address userAddress;\n        // decided referral percentage\n        uint256 referralPercentage;\n    }\n\n    /// @notice reward cap\n    mapping(address => mapping(address => uint256)) public rewardCap;\n\n    /// @notice mapping for storing reward per block.\n    mapping(address => bytes) internal _rewards;\n\n    /// @notice Referral Configuration\n    mapping(address => ReferralConfiguration) public referralConfig;\n\n    /// @notice add multicall support\n    address public multiCall;\n}\n"
    },
    "contracts/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity =0.8.9;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, 'Address: insufficient balance');\n\n        (bool success, ) = recipient.call{value: amount}('');\n        require(success, 'Address: unable to send value, recipient may have reverted');\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, 'Address: low-level call failed');\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, 'Address: low-level call with value failed');\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, 'Address: insufficient balance for call');\n        require(isContract(target), 'Address: call to non-contract');\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, 'Address: low-level static call failed');\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), 'Address: static call to non-contract');\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    }
  }
}}