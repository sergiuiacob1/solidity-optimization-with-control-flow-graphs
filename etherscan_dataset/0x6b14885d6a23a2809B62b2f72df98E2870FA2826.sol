{"IERC20.sol":{"content":"//SPDX-License-Identifier: MIT\r\npragma solidity 0.8.4;\r\n\r\ninterface IERC20 {\r\n\r\n    function totalSupply() external view returns (uint256);\r\n    \r\n    function symbol() external view returns(string memory);\r\n    \r\n    function name() external view returns(string memory);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n    \r\n    /**\r\n     * @dev Returns the number of decimal places\r\n     */\r\n    function decimals() external view returns (uint8);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}"},"PromiseUSD.sol":{"content":"//SPDX-License-Identifier: MIT\r\npragma solidity 0.8.4;\r\n\r\nimport \"./IERC20.sol\";\r\nimport \"./SafeMath.sol\";\r\n\r\ninterface IPromiseUSD {\r\n    function setApprovedContract(address Contract, bool _isApproved) external;\r\n    function mint(uint256 amountUnderlyingAsset) external returns (bool);\r\n    function takeLoan(uint256 ID, address desiredStable, uint256 amount) external returns (uint256);\r\n    function takeLoan(address desiredStable, uint256 amount) external returns (uint256);\r\n    function burnCollateral(uint256 ID, uint256 amount) external;\r\n    function makePayment(uint256 ID, uint256 amountUSD) external returns (uint256);\r\n}\r\n\r\ninterface IXUSD {\r\n    function stableAssets(address stable) external view returns (bool,bool,uint8);\r\n    function requestPromiseTokens(address stable, uint256 amount) external returns (uint256);\r\n    function burn(uint256 amount) external;\r\n}\r\n\r\n/**\r\n    XUSD\u0027s Lending Token\r\n\r\n    Over 1:1 Tied With USD\r\n        - Total Supply = USD To Be Repaid\r\n        - Total Locked = XUSD Held As Collateral\r\n\r\n        Total Locked should always be worth more than Total Supply\r\n\r\n    Locks XUSD Inside Of Itself And Redeems Its USD Without Burning Its Supply\r\n    Can Only Release XUSD If USD Debt Is Repaid\r\n\r\n    Intended to be a bare bones contract that does not implement any specific functionality\r\n    But enables approved contracts to utilize itself to benefit XUSD.\r\n\r\n    On its own pUSD is price neutral for XUSD, but if used correctly it can be used to bring\r\n    external profits into the system via lending, leveraged yield farming, and other services\r\n*/\r\ncontract PromiseUSD is IERC20 {\r\n\r\n    using SafeMath for uint256;\r\n    \r\n    // Relevant Tokens\r\n    address public XUSD;\r\n\r\n    // Token Data\r\n    string private constant _name = \"PromiseUSD\";\r\n    string private constant _symbol = \"pUSD\";\r\n    uint8 private constant _decimals = 18;\r\n    \r\n    // 0 Initial\r\n    uint256 private _totalSupply = 0;\r\n\r\n    // total XUSD locked\r\n    uint256 public totalLocked = 0;\r\n\r\n    // Tracks USD lent vs collateral collected\r\n    struct Promise {\r\n        uint256 debt;\r\n        uint256 collateral;\r\n    }\r\n    \r\n    // User -\u003e ID -\u003e Promise\r\n    mapping ( address =\u003e mapping ( uint256 =\u003e Promise ) ) public userPromise;\r\n\r\n    // User -\u003e Current ID ( nonce )\r\n    mapping ( address =\u003e uint256 ) public nonces;\r\n\r\n    /**\r\n        Allows Platforms + Models To Implement Lending And Preserve Upgradability\r\n        Being Forced To Preserve The Truths Enforced In This Smart Contract\r\n        With LeeWay For Adding External Fees And Usability\r\n    */\r\n    mapping ( address =\u003e bool ) public isApproved;\r\n\r\n    // Approved Contracts Only\r\n    modifier onlyApproved(){\r\n        require(isApproved[msg.sender], \u0027Only Approved Miners\u0027);\r\n        _;\r\n    }\r\n\r\n    // Only XUSD Itself\r\n    modifier onlyXUSD(){\r\n        require(msg.sender == XUSD, \u0027Only XUSD\u0027);\r\n        _;\r\n    }\r\n\r\n    // Events\r\n    event CollateralBurned(uint XUSDBurned, uint pUSDBurned);\r\n    event PromisePaymentReceived(uint usdReceived, uint xusdRedeemed);\r\n    event PromiseCreated(address user, uint usdBorrowed, uint xusdCollateral);\r\n    event ContractApproval(address newContract, bool _isApproved);\r\n\r\n    // Necessary Token Data\r\n    function totalSupply() external view override returns (uint256) { return _totalSupply; }\r\n    function balanceOf(address account) public view override returns (uint256) { return account == XUSD ? _totalSupply : 0; }\r\n    function allowance(address holder, address spender) external pure override returns (uint256) { holder; spender; return 0; }\r\n    function name() public pure override returns (string memory) {\r\n        return _name;\r\n    }\r\n    function symbol() public pure override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n    function decimals() public pure override returns (uint8) {\r\n        return _decimals;\r\n    }\r\n    function approve(address spender, uint256 amount) public override returns (bool) {\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n    /** Transfer Function */\r\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\r\n        return _transferFrom(msg.sender, recipient, amount);\r\n    }\r\n    /** Transfer Function */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\r\n        sender;\r\n        return _transferFrom(msg.sender, recipient, amount);\r\n    }\r\n    /** Internal Transfer */\r\n    function _transferFrom(address sender, address recipient, uint256 amount) internal returns (bool) {\r\n        sender; recipient; amount;\r\n        emit Transfer(sender, recipient, 0);\r\n        return false;\r\n    }\r\n\r\n    /**\r\n        Pairs XUSD With Its Current Contract\r\n        Can Only Be Performed Once\r\n     */\r\n    function pairXUSD(address XUSD_) external {\r\n        require(\r\n            XUSD == address(0) \u0026\u0026\r\n            XUSD_ != address(0),\r\n            \u0027Already Paired\u0027\r\n        );\r\n        XUSD = XUSD_;\r\n    }\r\n\r\n    /**\r\n        Approves External Contract To Utilize pUSD\r\n        NOTE: Only XUSD Can Call This Function\r\n    */\r\n    function setApprovedContract(address Contract, bool _isApproved) external onlyXUSD {\r\n        isApproved[Contract] = _isApproved;\r\n        emit ContractApproval(Contract, _isApproved);\r\n    }\r\n\r\n    /**\r\n        Burns XUSD Held As Collateral, Reduces Debt in proportion to burn amount\r\n        Allowing an approved contract to burn their locked XUSD and associated pUSD tokens\r\n\r\n        @param ID - nonce for calling contract to burn from\r\n        @param amount - amount of XUSD to burn\r\n    */\r\n    function burnCollateral(uint256 ID, uint256 amount) external onlyApproved {\r\n        require(\r\n            userPromise[msg.sender][ID].collateral \u003e 0 \u0026\u0026 \r\n            userPromise[msg.sender][ID].collateral \u003e= amount, \r\n            \u0027Insufficient Collateral\u0027\r\n        );\r\n        \r\n        // BE SURE TO BURN APPROPRIATE AMOUNT OF pUSD AFTER SO XUSD DOES NOT OVER-VALUE ITSELF\r\n        uint256 burnAmount = ( amount * userPromise[msg.sender][ID].debt ) / userPromise[msg.sender][ID].collateral;\r\n\r\n        // reduce collateral\r\n        userPromise[msg.sender][ID].collateral = userPromise[msg.sender][ID].collateral.sub(amount, \u0027Underflow\u0027);\r\n        // reduce total locked\r\n        totalLocked -= amount;\r\n\r\n        // reduce debt\r\n        userPromise[msg.sender][ID].debt = userPromise[msg.sender][ID].debt.sub(burnAmount, \u0027Debt Underflow\u0027);\r\n\r\n        // burn XUSD amount\r\n        IXUSD(XUSD).burn(amount);\r\n\r\n        // reduce pUSD amount in relation to XUSD tokens burned to not overinflate pUSD backing in XUSD\r\n        _totalSupply = _totalSupply.sub(burnAmount);\r\n        emit Transfer(XUSD, address(0), burnAmount);\r\n        emit CollateralBurned(amount, burnAmount);\r\n    }\r\n    \r\n    /**\r\n        Repayes the debt tracked by `ID` in `stable`, and releases locked XUSD \r\n        Back to the user who staked the XUSD in the first place, proportional to\r\n        how much debt has been repaid\r\n        Can only be triggered by Approved Contracts\r\n\r\n        @param ID - ID or nonce of calling contract to repay\r\n        @param stable - Stable Coin to make payment in, must be approved stable\r\n        @param amountStable - amount of USD stable coins to make the payment for\r\n     */\r\n    function makePayment(uint256 ID, address stable, uint256 amountStable) external onlyApproved returns (uint256) {\r\n        require(\r\n            canRepayWith(stable),\r\n            \u0027Cannot Repay With This Stable\u0027\r\n        );\r\n        return _makePayment(msg.sender, ID, stable, amountStable);\r\n    }\r\n\r\n    /**\r\n        Takes XUSD As Collateral and releases its underlying USD Without Deleting Tokens\r\n        pUSD is minted to XUSD to sustain its price\r\n\r\n        @param ID - nonce of sender, should be tracked by calling contract\r\n        @param collateral - Amount of XUSD to lock up and borrow from\r\n        @return ID - The ID Utilized For This Loan\r\n    */\r\n    function takeLoan(uint256 ID, address desiredStable, uint256 collateral) external onlyApproved returns (uint256) {\r\n        require(!IDInUse(msg.sender, ID), \u0027ID in Use\u0027);\r\n        _takeLoan(ID, desiredStable, collateral);\r\n        nonces[msg.sender]++;\r\n        return ID;\r\n    }\r\n\r\n    /**\r\n        Takes XUSD As Collateral and releases its underlying USD Without Deleting Tokens\r\n        pUSD is minted to XUSD to sustain its price\r\n        It\u0027s up to the implementing smart contract to add a fee to this system to benefit XUSD\r\n        there is no intrinsic benefit to this contract or function alone, what is built from it\r\n        however has all the potential\r\n\r\n        This uses the calling contract\u0027s current nonce and increments it\r\n        @param collateral - Amount of XUSD to lock up and borrow from\r\n        @return ID - The ID Utilized For This Loan\r\n    */\r\n    function takeLoan(address desiredStable, uint256 collateral) external onlyApproved returns (uint256) {\r\n        uint ID = nonces[msg.sender];\r\n        require(!IDInUse(msg.sender, ID), \u0027ID in Use\u0027);\r\n        _takeLoan(ID, desiredStable, collateral);\r\n        nonces[msg.sender]++;\r\n        return ID;\r\n    }\r\n\r\n    /**\r\n        Sets calling contract\u0027s nonce in the event of a mistake\r\n        NOTE: Calling contracts should implement a way to track nonce\u0027s across multiple users\r\n\r\n        @param nonce - nonce to set for the calling contract\r\n     */\r\n    function setNonce(uint256 nonce) external onlyApproved {\r\n        nonces[msg.sender] = nonce;\r\n    }\r\n\r\n    /**\r\n        Whehter or not the nonce of a calling contract is in use or not\r\n     */\r\n    function IDInUse(address borrower, uint256 ID) public view returns (bool) {\r\n        return userPromise[borrower][ID].collateral \u003e 0 || userPromise[borrower][ID].debt \u003e 0;\r\n    }\r\n\r\n    /**\r\n        Repayes the debt tracked by `ID` in USD, and releases the XUSD \r\n        Back to the user who staked the XUSD in the first place\r\n     */\r\n    function _makePayment(address user, uint256 ID, address stable, uint256 amountUSD) internal returns (uint256 amountCollateral) {\r\n        require(userPromise[user][ID].debt \u003e 0, \u0027Zero Debt\u0027);\r\n        require(amountUSD \u003c= userPromise[user][ID].debt \u0026\u0026 amountUSD \u003e 0, \u0027Invalid Amount\u0027);\r\n        \r\n        // transfer in USD\r\n        uint256 received = _transferIn(stable, amountUSD);\r\n\r\n        // Repay USD Amount To XUSD\r\n        bool s = IERC20(stable).transfer(XUSD, received);\r\n        require(s, \u0027Failure On USD Transfer\u0027);\r\n\r\n        // Burn pUSD Supply\r\n        _totalSupply = _totalSupply.sub(received, \u0027Underflow\u0027);\r\n        emit Transfer(XUSD, address(0), received);\r\n\r\n        // check debt and locked XUSD Amount\r\n        if (userPromise[user][ID].debt \u003c= received) {\r\n\r\n            // clear collateral\r\n            amountCollateral = userPromise[user][ID].collateral;\r\n            _release(ID, user, amountCollateral);\r\n\r\n            // emit event\r\n            emit PromisePaymentReceived(amountUSD, amountCollateral);\r\n\r\n            // free storage\r\n            delete userPromise[user][ID];\r\n\r\n        } else {\r\n\r\n            // get portion of remaining debt\r\n            amountCollateral = ( userPromise[user][ID].collateral * received ) / userPromise[user][ID].debt;\r\n\r\n            // update remaining debt and supply\r\n            userPromise[user][ID].debt = userPromise[user][ID].debt.sub(received, \u0027Underflow\u0027);\r\n\r\n            // clear collateral\r\n            _release(ID, user, amountCollateral);\r\n\r\n            // emit event\r\n            emit PromisePaymentReceived(received, amountCollateral);\r\n        }\r\n    }\r\n\r\n    /**\r\n        Takes XUSD As Collateral and releases its underlying USD Without Deleting Tokens\r\n        pUSD is minted to XUSD to sustain its price\r\n    */\r\n    function _takeLoan(uint256 ID, address desiredStable, uint256 collateral) internal {\r\n\r\n        // transfer in XUSD\r\n        uint256 xReceived = _transferIn(XUSD, collateral);\r\n\r\n        // set collateral\r\n        userPromise[msg.sender][ID].collateral = xReceived;\r\n\r\n        // increment total locked\r\n        totalLocked = totalLocked.add(xReceived);\r\n\r\n        // sells XUSD tax exempt, calls back to mint to create an equal amount of pUSD as USD that is removed\r\n        uint256 received = IXUSD(XUSD).requestPromiseTokens(desiredStable, xReceived);\r\n        require(\r\n            received \u003e 0 \u0026\u0026 \r\n            IERC20(desiredStable).balanceOf(address(this)) \u003e= received,\r\n            \u0027XUSD Promise Request Failed\u0027\r\n        );\r\n\r\n        // set debt\r\n        userPromise[msg.sender][ID].debt = received;\r\n\r\n        // send USD to caller\r\n        require(\r\n            IERC20(desiredStable).transfer(msg.sender, received),\r\n            \u0027Stable Transfer Failure\u0027\r\n        );\r\n\r\n        // emit event\r\n        emit PromiseCreated(msg.sender, received, xReceived);\r\n    }\r\n\r\n    /**\r\n        Function Triggered By XUSD Itself\r\n        After XUSD Calculates It\u0027s USD Amount To Redeem\r\n        It Must Be Minted pUSD So RequireProfit Does Not Fail\r\n        XUSD Will Send USD Into pUSD, assuming it does not ask for too much\r\n        pUSD will Route USD To Desired Source, and Lock the XUSD Received\r\n\r\n        XUSD May Only Be Unlocked From USD Being Repaid\r\n\r\n    */\r\n    function mint(uint256 amount) external onlyXUSD returns (bool) {\r\n        _totalSupply = _totalSupply.add(amount);\r\n        emit Transfer(address(0), XUSD, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n        Transfers in `amount` of `token` from the sender of the message\r\n     */\r\n    function _transferIn(address token, uint256 amount) internal returns (uint256) {\r\n        uint256 before = IERC20(token).balanceOf(address(this));\r\n        bool s = IERC20(token).transferFrom(msg.sender, address(this), amount);\r\n        uint256 received = IERC20(token).balanceOf(address(this)).sub(before, \u0027Underflow\u0027);\r\n        require(s \u0026\u0026 received \u003c= amount \u0026\u0026 received \u003e 0, \u0027Transfer Error\u0027);\r\n        return received;\r\n    }\r\n\r\n    /**\r\n        Unlocks XUSD For User\r\n        Reduces Collateral\r\n    */\r\n    function _release(uint256 ID, address to, uint256 amount) internal {\r\n\r\n        bool s;\r\n        // ensure token transfer success\r\n        if (userPromise[to][ID].collateral \u003c= amount) { // collateral is paid back\r\n            // transfer collateral to owner\r\n            s = IERC20(XUSD).transfer(to, userPromise[to][ID].collateral);\r\n            // decrement total locked\r\n            totalLocked = totalLocked.sub(userPromise[to][ID].collateral, \u0027Total Locked Underflow\u0027);\r\n            // reset storage\r\n            delete userPromise[to][ID];\r\n        } else {                                        // only part of collateral is paid back\r\n            // update collateral\r\n            userPromise[to][ID].collateral = userPromise[to][ID].collateral.sub(amount, \u0027Underflow\u0027);\r\n            // transfer XUSD\r\n            s = IERC20(XUSD).transfer(to, amount); \r\n            // decrement total locked\r\n            totalLocked = totalLocked.sub(amount, \u0027Total Locked Underflow\u0027);\r\n        }\r\n        // require success\r\n        require(s, \u0027XUSD Transfer Failure\u0027);\r\n    }\r\n\r\n    /**\r\n        True If `stable` is Approved and minting is not disabled, False otherwise\r\n     */\r\n    function canRepayWith(address stable) public view returns (bool) {\r\n        (bool approved, bool mintDisabled,) = IXUSD(XUSD).stableAssets(stable);\r\n        return approved \u0026\u0026 !mintDisabled;\r\n    }\r\n\r\n}"},"SafeMath.sol":{"content":"//SPDX-License-Identifier: MIT\r\npragma solidity 0.8.4;\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c \u003e= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\u0027s `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\u0027s `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b \u003c= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\r\n        // benefit is lost if \u0027b\u0027 is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b \u003e 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}"}}