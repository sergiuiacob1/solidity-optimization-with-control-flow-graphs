{{
  "language": "Solidity",
  "settings": {
    "evmVersion": "london",
    "libraries": {},
    "metadata": {
      "bytecodeHash": "ipfs",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "base64-sol/base64.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\n/// @title Base64\n/// @author Brecht Devos - <brecht@loopring.org>\n/// @notice Provides functions for encoding/decoding base64\nlibrary Base64 {\n    string internal constant TABLE_ENCODE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n    bytes  internal constant TABLE_DECODE = hex\"0000000000000000000000000000000000000000000000000000000000000000\"\n                                            hex\"00000000000000000000003e0000003f3435363738393a3b3c3d000000000000\"\n                                            hex\"00000102030405060708090a0b0c0d0e0f101112131415161718190000000000\"\n                                            hex\"001a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132330000000000\";\n\n    function encode(bytes memory data) internal pure returns (string memory) {\n        if (data.length == 0) return '';\n\n        // load the table into memory\n        string memory table = TABLE_ENCODE;\n\n        // multiply by 4/3 rounded up\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\n\n        // add some extra buffer at the end required for the writing\n        string memory result = new string(encodedLen + 32);\n\n        assembly {\n            // set the actual output length\n            mstore(result, encodedLen)\n\n            // prepare the lookup table\n            let tablePtr := add(table, 1)\n\n            // input ptr\n            let dataPtr := data\n            let endPtr := add(dataPtr, mload(data))\n\n            // result ptr, jump over length\n            let resultPtr := add(result, 32)\n\n            // run over the input, 3 bytes at a time\n            for {} lt(dataPtr, endPtr) {}\n            {\n                // read 3 bytes\n                dataPtr := add(dataPtr, 3)\n                let input := mload(dataPtr)\n\n                // write 4 characters\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(shr( 6, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(        input,  0x3F))))\n                resultPtr := add(resultPtr, 1)\n            }\n\n            // padding with '='\n            switch mod(mload(data), 3)\n            case 1 { mstore(sub(resultPtr, 2), shl(240, 0x3d3d)) }\n            case 2 { mstore(sub(resultPtr, 1), shl(248, 0x3d)) }\n        }\n\n        return result;\n    }\n\n    function decode(string memory _data) internal pure returns (bytes memory) {\n        bytes memory data = bytes(_data);\n\n        if (data.length == 0) return new bytes(0);\n        require(data.length % 4 == 0, \"invalid base64 decoder input\");\n\n        // load the table into memory\n        bytes memory table = TABLE_DECODE;\n\n        // every 4 characters represent 3 bytes\n        uint256 decodedLen = (data.length / 4) * 3;\n\n        // add some extra buffer at the end required for the writing\n        bytes memory result = new bytes(decodedLen + 32);\n\n        assembly {\n            // padding with '='\n            let lastBytes := mload(add(data, mload(data)))\n            if eq(and(lastBytes, 0xFF), 0x3d) {\n                decodedLen := sub(decodedLen, 1)\n                if eq(and(lastBytes, 0xFFFF), 0x3d3d) {\n                    decodedLen := sub(decodedLen, 1)\n                }\n            }\n\n            // set the actual output length\n            mstore(result, decodedLen)\n\n            // prepare the lookup table\n            let tablePtr := add(table, 1)\n\n            // input ptr\n            let dataPtr := data\n            let endPtr := add(dataPtr, mload(data))\n\n            // result ptr, jump over length\n            let resultPtr := add(result, 32)\n\n            // run over the input, 4 characters at a time\n            for {} lt(dataPtr, endPtr) {}\n            {\n               // read 4 characters\n               dataPtr := add(dataPtr, 4)\n               let input := mload(dataPtr)\n\n               // write 3 bytes\n               let output := add(\n                   add(\n                       shl(18, and(mload(add(tablePtr, and(shr(24, input), 0xFF))), 0xFF)),\n                       shl(12, and(mload(add(tablePtr, and(shr(16, input), 0xFF))), 0xFF))),\n                   add(\n                       shl( 6, and(mload(add(tablePtr, and(shr( 8, input), 0xFF))), 0xFF)),\n                               and(mload(add(tablePtr, and(        input , 0xFF))), 0xFF)\n                    )\n                )\n                mstore(resultPtr, shl(232, output))\n                resultPtr := add(resultPtr, 3)\n            }\n        }\n\n        return result;\n    }\n}\n"
    },
    "contracts/interfaces/LandERC721Spec.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../lib/LandLib.sol\";\n\n/**\n * @title Land ERC721 Metadata\n *\n * @notice Defines metadata-related capabilities for LandERC721 token.\n *      This interface should be treated as a definition of what metadata is for LandERC721,\n *      and what operations are defined/allowed for it.\n *\n * @author Basil Gorin\n */\ninterface LandERC721Metadata {\n\t/**\n\t * @notice Presents token metadata in a well readable form,\n\t *      with the Internal Land Structure included, as a `PlotView` struct\n\t *\n\t * @notice Reconstructs the internal land structure of the plot based on the stored\n\t *      Tier ID, Plot Size, Generator Version, and Seed\n\t *\n\t * @param _tokenId token ID to query metadata view for\n\t * @return token metadata as a `PlotView` struct\n\t */\n\tfunction viewMetadata(uint256 _tokenId) external view returns (LandLib.PlotView memory);\n\n\t/**\n\t * @notice Presents token metadata \"as is\", without the Internal Land Structure included,\n\t *      as a `PlotStore` struct;\n\t *\n\t * @notice Doesn't reconstruct the internal land structure of the plot, allowing to\n\t *      access Generator Version, and Seed fields \"as is\"\n\t *\n\t * @param _tokenId token ID to query on-chain metadata for\n\t * @return token metadata as a `PlotStore` struct\n\t */\n\tfunction getMetadata(uint256 _tokenId) external view returns (LandLib.PlotStore memory);\n\n\t/**\n\t * @notice Verifies if token has its metadata set on-chain; for the tokens\n\t *      in existence metadata is immutable, it can be set once, and not updated\n\t *\n\t * @dev If `exists(_tokenId) && hasMetadata(_tokenId)` is true, `setMetadata`\n\t *      for such a `_tokenId` will always throw\n\t *\n\t * @param _tokenId token ID to check metadata existence for\n\t * @return true if token ID specified has metadata associated with it\n\t */\n\tfunction hasMetadata(uint256 _tokenId) external view returns (bool);\n\n\t/**\n\t * @dev Sets/updates token metadata on-chain; same metadata struct can be then\n\t *      read back using `getMetadata()` function, or it can be converted to\n\t *      `PlotView` using `viewMetadata()` function\n\t *\n\t * @dev The metadata supplied is validated to satisfy (regionId, x, y) uniqueness;\n\t *      non-intersection of the sites coordinates within a plot is guaranteed by the\n\t *      internal land structure generator algorithm embedded into the `viewMetadata()`\n\t *\n\t * @dev Metadata for non-existing tokens can be set and updated unlimited\n\t *      amount of times without any restrictions (except the constraints above)\n\t * @dev Metadata for an existing token can only be set, it cannot be updated\n\t *      (`setMetadata` will throw if metadata already exists)\n\t *\n\t * @param _tokenId token ID to set/updated the metadata for\n\t * @param _plot token metadata to be set for the token ID\n\t */\n\tfunction setMetadata(uint256 _tokenId, LandLib.PlotStore memory _plot) external;\n\n\t/**\n\t * @dev Removes token metadata\n\t *\n\t * @param _tokenId token ID to remove metadata for\n\t */\n\tfunction removeMetadata(uint256 _tokenId) external;\n\n\t/**\n\t * @dev Mints the token and assigns the metadata supplied\n\t *\n\t * @dev Creates new token with the token ID specified\n\t *      and assigns an ownership `_to` for this token\n\t *\n\t * @dev Unsafe: doesn't execute `onERC721Received` on the receiver.\n\t *      Consider minting with `safeMint` (and setting metadata before),\n\t *      for the \"safe mint\" like behavior\n\t *\n\t * @param _to an address to mint token to\n\t * @param _tokenId token ID to mint and set metadata for\n\t * @param _plot token metadata to be set for the token ID\n\t */\n\tfunction mintWithMetadata(address _to, uint256 _tokenId, LandLib.PlotStore memory _plot) external;\n}\n\n/**\n * @title Land Descriptor\n *\n * @notice Auxiliary module which is dynamically injected into LandERC721 contract\n *      to override the default ERC721.tokenURI behaviour\n *\n * @notice This can be used, for example, to enable on-chain generation of the SVG\n *      image representation of the land plot, encoding it into base64 string, and\n *      using it instead of token URI pointing to some off-chain sotrage location\n *\n * @dev Can be dynamically injected into LandERC721 at any time, can be dynamically detached\n *      from the LandERC721 once attached (injected)\n *\n * @author Pedro Bergamini, Basil Gorin\n */\ninterface LandDescriptor {\n\t/**\n\t * @notice Creates SVG image with the land plot metadata painted on it,\n\t *      encodes the generated SVG into base64 URI string\n\t *\n\t * @param _tokenId token ID of the land plot to generate SVG for\n\t */\n\tfunction tokenURI(uint256 _tokenId) external view returns (string memory);\n}\n"
    },
    "contracts/lib/LandLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title Land Library\n *\n * @notice A library defining data structures related to land plots (used in Land ERC721 token),\n *      and functions transforming these structures between view and internal (packed) representations,\n *      in both directions.\n *\n * @notice Due to some limitations Solidity has (ex.: allocating array of structures in storage),\n *      and due to the specific nature of internal land structure\n *      (landmark and resource sites data is deterministically derived from a pseudo random seed),\n *      it is convenient to separate data structures used to store metadata on-chain (store),\n *      and data structures used to present metadata via smart contract ABI (view)\n *\n * @notice Introduces helper functions to detect and deal with the resource site collisions\n *\n * @author Basil Gorin\n */\nlibrary LandLib {\n\t/**\n\t * @title Resource Site View\n\t *\n\t * @notice Resource Site, bound to a coordinates (x, y) within the land plot\n\t *\n\t * @notice Resources can be of two major types, each type having three subtypes:\n\t *      - Element (Carbon, Silicon, Hydrogen), or\n\t *      - Fuel (Crypton, Hyperion, Solon)\n\t *\n\t * @dev View only structure, used in public API/ABI, not used in on-chain storage\n\t */\n\tstruct Site {\n\t\t/**\n\t\t * @dev Site type:\n\t\t *        1) Carbon (element),\n\t\t *        2) Silicon (element),\n\t\t *        3) Hydrogen (element),\n\t\t *        4) Crypton (fuel),\n\t\t *        5) Hyperion (fuel),\n\t\t *        6) Solon (fuel)\n\t\t */\n\t\tuint8 typeId;\n\n\t\t/**\n\t\t * @dev x-coordinate within a plot\n\t\t */\n\t\tuint16 x;\n\n\t\t/**\n\t\t * @dev y-coordinate within a plot\n\t\t */\n\t\tuint16 y;\n\t}\n\n\t/**\n\t * @title Land Plot View\n\t *\n\t * @notice Land Plot, bound to a coordinates (x, y) within the region,\n\t *      with a rarity defined by the tier ID, sites, and (optionally)\n\t *      a landmark, positioned on the internal coordinate grid of the\n\t *      specified size within a plot.\n\t *\n\t * @notice Land plot coordinates and rarity are predefined (stored off-chain).\n\t *      Number of sites (and landmarks - 0/1) is defined by the land rarity.\n\t *      Positions of sites, types of sites/landmark are randomized and determined\n\t *      upon land plot creation.\n\t *\n\t * @dev View only structure, used in public API/ABI, not used in on-chain storage\n\t */\n\tstruct PlotView {\n\t\t/**\n\t\t * @dev Region ID defines the region on the map in IZ:\n\t\t *        1) Abyssal Basin\n\t\t *        2) Brightland Steppes\n\t\t *        3) Shardbluff Labyrinth\n\t\t *        4) Crimson Waste\n\t\t *        5) Halcyon Sea\n\t\t *        6) Taiga Boreal\n\t\t *        7) Crystal Shores\n\t\t */\n\t\tuint8 regionId;\n\n\t\t/**\n\t\t * @dev x-coordinate within the region\n\t\t */\n\t\tuint16 x;\n\n\t\t/**\n\t\t * @dev y-coordinate within the region\n\t\t */\n\t\tuint16 y;\n\n\t\t/**\n\t\t * @dev Tier ID defines land rarity and number of sites within the plot\n\t\t */\n\t\tuint8 tierId;\n\n\t\t/**\n\t\t * @dev Plot size, limits the (x, y) coordinates for the sites\n\t\t */\n\t\tuint16 size;\n\n\t\t/**\n\t\t * @dev Landmark Type ID:\n\t\t *        0) no Landmark\n\t\t *        1) Carbon Landmark,\n\t\t *        2) Silicon Landmark,\n\t\t *        3) Hydrogen Landmark (Eternal Spring),\n\t\t *        4) Crypton Landmark,\n\t\t *        5) Hyperion Landmark,\n\t\t *        6) Solon Landmark (Fallen Star),\n\t\t *        7) Arena\n\t\t *\n\t\t * @dev Landmark is always positioned in the center of internal grid\n\t\t */\n\t\tuint8 landmarkTypeId;\n\n\t\t/**\n\t\t * @dev Number of Element Sites (Carbon, Silicon, or Hydrogen) this plot contains,\n\t\t *      matches the number of element sites in sites[] array\n\t\t */\n\t\tuint8 elementSites;\n\n\t\t/**\n\t\t * @dev Number of Fuel Sites (Crypton, Hyperion, or Solon) this plot contains,\n\t\t *      matches the number of fuel sites in sites[] array\n\t\t */\n\t\tuint8 fuelSites;\n\n\t\t/**\n\t\t * @dev Element/fuel sites within the plot\n\t\t */\n\t\tSite[] sites;\n\t}\n\n\t/**\n\t * @title Land Plot Store\n\t *\n\t * @notice Land Plot data structure as it is stored on-chain\n\t *\n\t * @notice Contains the data required to generate `PlotView` structure:\n\t *      - regionId, x, y, tierId, size, landmarkTypeId, elementSites, and fuelSites are copied as is\n\t *      - version and seed are used to derive array of sites (together with elementSites, and fuelSites)\n\t *\n\t * @dev On-chain optimized structure, has limited usage in public API/ABI\n\t */\n\tstruct PlotStore {\n\t\t/**\n\t\t * @dev Generator Version, reserved for the future use in order to tweak the\n\t\t *      behavior of the internal land structure algorithm\n\t\t */\n\t\tuint8 version;\n\n\t\t/**\n\t\t * @dev Region ID defines the region on the map in IZ:\n\t\t *        1) Abyssal Basin\n\t\t *        2) Brightland Steppes\n\t\t *        3) Shardbluff Labyrinth\n\t\t *        4) Crimson Waste\n\t\t *        5) Halcyon Sea\n\t\t *        6) Taiga Boreal\n\t\t *        7) Crystal Shores\n\t\t */\n\t\tuint8 regionId;\n\n\t\t/**\n\t\t * @dev x-coordinate within the region\n\t\t */\n\t\tuint16 x;\n\n\t\t/**\n\t\t * @dev y-coordinate within the region\n\t\t */\n\t\tuint16 y;\n\n\t\t/**\n\t\t * @dev Tier ID defines land rarity and number of sites within the plot\n\t\t */\n\t\tuint8 tierId;\n\n\t\t/**\n\t\t * @dev Plot Size, limits the (x, y) coordinates for the sites\n\t\t */\n\t\tuint16 size;\n\n\t\t/**\n\t\t * @dev Landmark Type ID:\n\t\t *        0) no Landmark\n\t\t *        1) Carbon Landmark,\n\t\t *        2) Silicon Landmark,\n\t\t *        3) Hydrogen Landmark (Eternal Spring),\n\t\t *        4) Crypton Landmark,\n\t\t *        5) Hyperion Landmark,\n\t\t *        6) Solon Landmark (Fallen Star),\n\t\t *        7) Arena\n\t\t *\n\t\t * @dev Landmark is always positioned in the center of internal grid\n\t\t */\n\t\tuint8 landmarkTypeId;\n\n\t\t/**\n\t\t * @dev Number of Element Sites (Carbon, Silicon, or Hydrogen) this plot contains\n\t\t */\n\t\tuint8 elementSites;\n\n\t\t/**\n\t\t * @dev Number of Fuel Sites (Crypton, Hyperion, or Solon) this plot contains\n\t\t */\n\t\tuint8 fuelSites;\n\n\t\t/**\n\t\t * @dev Pseudo-random Seed to generate Internal Land Structure,\n\t\t *      should be treated as already used to derive Landmark Type ID\n\t\t */\n\t\tuint160 seed;\n\t}\n\n\t/**\n\t * @dev Tightly packs `PlotStore` data struct into uint256 representation\n\t *\n\t * @param store `PlotStore` data struct to pack\n\t * @return packed `PlotStore` data struct packed into uint256\n\t */\n\tfunction pack(PlotStore memory store) internal pure returns (uint256 packed) {\n\t\treturn uint256(store.version) << 248\n\t\t\t| uint248(store.regionId) << 240\n\t\t\t| uint240(store.x) << 224\n\t\t\t| uint224(store.y) << 208\n\t\t\t| uint208(store.tierId) << 200\n\t\t\t| uint200(store.size) << 184\n\t\t\t| uint184(store.landmarkTypeId) << 176\n\t\t\t| uint176(store.elementSites) << 168\n\t\t\t| uint168(store.fuelSites) << 160\n\t\t\t| uint160(store.seed);\n\t}\n\n\t/**\n\t * @dev Unpacks `PlotStore` data struct from uint256 representation\n\t *\n\t * @param packed uint256 packed `PlotStore` data struct\n\t * @return store unpacked `PlotStore` data struct\n\t */\n\tfunction unpack(uint256 packed) internal pure returns (PlotStore memory store) {\n\t\treturn PlotStore({\n\t\t\tversion:        uint8(packed >> 248),\n\t\t\tregionId:       uint8(packed >> 240),\n\t\t\tx:              uint16(packed >> 224),\n\t\t\ty:              uint16(packed >> 208),\n\t\t\ttierId:         uint8(packed >> 200),\n\t\t\tsize:           uint16(packed >> 184),\n\t\t\tlandmarkTypeId: uint8(packed >> 176),\n\t\t\telementSites:   uint8(packed >> 168),\n\t\t\tfuelSites:      uint8(packed >> 160),\n\t\t\tseed:           uint160(packed)\n\t\t});\n\t}\n\n\t/**\n\t * @dev Expands `PlotStore` data struct into a `PlotView` view struct\n\t *\n\t * @dev Derives internal land structure (resource sites the plot has)\n\t *      from Number of Element/Fuel Sites, Plot Size, and Seed;\n\t *      Generator Version is not currently used\n\t *\n\t * @param store on-chain `PlotStore` data structure to expand\n\t * @return `PlotView` view struct, expanded from the on-chain data\n\t */\n\tfunction plotView(PlotStore memory store) internal pure returns (PlotView memory) {\n\t\t// copy most of the fields as is, derive resource sites array inline\n\t\treturn PlotView({\n\t\t\tregionId:       store.regionId,\n\t\t\tx:              store.x,\n\t\t\ty:              store.y,\n\t\t\ttierId:         store.tierId,\n\t\t\tsize:           store.size,\n\t\t\tlandmarkTypeId: store.landmarkTypeId,\n\t\t\telementSites:   store.elementSites,\n\t\t\tfuelSites:      store.fuelSites,\n\t\t\t// derive the resource sites from Number of Element/Fuel Sites, Plot Size, and Seed\n\t\t\tsites:          getResourceSites(store.seed, store.elementSites, store.fuelSites, store.size, 2)\n\t\t});\n\t}\n\n\t/**\n\t * @dev Based on the random seed, tier ID, and plot size, determines the\n\t *      internal land structure (resource sites the plot has)\n\t *\n\t * @dev Function works in a deterministic way and derives the same data\n\t *      for the same inputs; the term \"random\" in comments means \"pseudo-random\"\n\t *\n\t * @param seed random seed to consume and derive the internal structure\n\t * @param elementSites number of element sites plot has\n\t * @param fuelSites number of fuel sites plot has\n\t * @param gridSize plot size `N` of the land plot to derive internal structure for\n\t * @param siteSize implied size `n` of the resource sites\n\t * @return sites randomized array of resource sites\n\t */\n\tfunction getResourceSites(\n\t\tuint256 seed,\n\t\tuint8 elementSites,\n\t\tuint8 fuelSites,\n\t\tuint16 gridSize,\n\t\tuint8 siteSize\n\t) internal pure returns (Site[] memory sites) {\n\t\t// derive the total number of sites\n\t\tuint8 totalSites = elementSites + fuelSites;\n\n\t\t// denote the grid (plot) size `N`\n\t\t// denote the resource site size `n`\n\n\t\t// transform coordinate system (1): normalization (x, y) => (x / n, y / n)\n\t\t// if `N` is odd this cuts off border coordinates x = N - 1, y = N - 1\n\t\tuint16 normalizedSize = gridSize / siteSize;\n\n\t\t// after normalization (1) is applied, isomorphic grid becomes effectively larger\n\t\t// due to borders capturing effect, for example if N = 4, and n = 2:\n\t\t//      | .. |                                              |....|\n\t\t// grid |....| becomes |..| normalized which is effectively |....|\n\t\t//      |....|         |..|                                 |....|\n\t\t//      | .. |                                              |....|\n\t\t// transform coordinate system (2): cut the borders, and reduce grid size to be multiple of 2\n\t\t// if `N/2` is odd this cuts off border coordinates x = N/2 - 1, y = N/2 - 1\n\t\tnormalizedSize = (normalizedSize - 2) / 2 * 2;\n\n\t\t// define coordinate system: an isomorphic grid on a square of size [size, size]\n\t\t// transform coordinate system (3): pack an isomorphic grid on a rectangle of size [size, 1 + size / 2]\n\t\t// transform coordinate system (4): (x, y) -> y * size + x (two-dimensional Cartesian -> one-dimensional segment)\n\t\t// define temporary array to determine sites' coordinates\n\t\tuint16[] memory coords;\n\t\t// generate site coordinates in a transformed coordinate system (on a one-dimensional segment)\n\t\t// cut off four elements in the end of the segment to reserve space in the center for a landmark\n\t\t(seed, coords) = getCoords(seed, totalSites, normalizedSize * (1 + normalizedSize / 2) - 4);\n\n\t\t// allocate number of sites required\n\t\tsites = new Site[](totalSites);\n\n\t\t// define the variables used inside the loop outside the loop to help compiler optimizations\n\t\t// site type ID is de facto uint8, we're using uint16 for convenience with `nextRndUint16`\n\t\tuint16 typeId;\n\t\t// site coordinates (x, y)\n\t\tuint16 x;\n\t\tuint16 y;\n\n\t\t// determine the element and fuel sites one by one\n\t\tfor(uint8 i = 0; i < totalSites; i++) {\n\t\t\t// determine next random number in the sequence, and random site type from it\n\t\t\t(seed, typeId) = nextRndUint16(seed, i < elementSites? 1: 4, 3);\n\n\t\t\t// determine x and y\n\t\t\t// reverse transform coordinate system (4): x = size % i, y = size / i\n\t\t\t// (back from one-dimensional segment to two-dimensional Cartesian)\n\t\t\tx = coords[i] % normalizedSize;\n\t\t\ty = coords[i] / normalizedSize;\n\n\t\t\t// reverse transform coordinate system (3): unpack isomorphic grid onto a square of size [size, size]\n\t\t\t// fix the \"(0, 0) left-bottom corner\" of the isomorphic grid\n\t\t\tif(2 * (1 + x + y) < normalizedSize) {\n\t\t\t\tx += normalizedSize / 2;\n\t\t\t\ty += 1 + normalizedSize / 2;\n\t\t\t}\n\t\t\t// fix the \"(size, 0) right-bottom corner\" of the isomorphic grid\n\t\t\telse if(2 * x > normalizedSize && 2 * x > 2 * y + normalizedSize) {\n\t\t\t\tx -= normalizedSize / 2;\n\t\t\t\ty += 1 + normalizedSize / 2;\n\t\t\t}\n\n\t\t\t// move the site from the center (four positions near the center) to a free spot\n\t\t\tif(x >= normalizedSize / 2 - 1 && x <= normalizedSize / 2\n\t\t\t&& y >= normalizedSize / 2 - 1 && y <= normalizedSize / 2) {\n\t\t\t\t// `x` is aligned over the free space in the end of the segment\n\t\t\t\t// x += normalizedSize / 2 + 2 * (normalizedSize / 2 - x) + 2 * (normalizedSize / 2 - y) - 4;\n\t\t\t\tx += 5 * normalizedSize / 2 - 2 * (x + y) - 4;\n\t\t\t\t// `y` is fixed over the free space in the end of the segment\n\t\t\t\ty = normalizedSize / 2;\n\t\t\t}\n\n\t\t\t// if `N/2` is odd recover previously cut off border coordinates x = N/2 - 1, y = N/2 - 1\n\t\t\t// if `N` is odd recover previously cut off border coordinates x = N - 1, y = N - 1\n\t\t\tuint16 offset = gridSize / siteSize % 2 + gridSize % siteSize;\n\n\t\t\t// based on the determined site type and coordinates, allocate the site\n\t\t\tsites[i] = Site({\n\t\t\t\ttypeId: uint8(typeId),\n\t\t\t\t// reverse transform coordinate system (2): recover borders (x, y) => (x + 1, y + 1)\n\t\t\t\t// if `N/2` is odd recover previously cut off border coordinates x = N/2 - 1, y = N/2 - 1\n\t\t\t\t// reverse transform coordinate system (1): (x, y) => (n * x, n * y), where n is site size\n\t\t\t\t// if `N` is odd recover previously cut off border coordinates x = N - 1, y = N - 1\n\t\t\t\tx: (1 + x) * siteSize + offset,\n\t\t\t\ty: (1 + y) * siteSize + offset\n\t\t\t});\n\t\t}\n\n\t\t// return the result\n\t\treturn sites;\n\t}\n\n\t/**\n\t * @dev Based on the random seed and tier ID determines the landmark type of the plot.\n\t *      Random seed is consumed for tiers 3 and 4 to randomly determine one of three\n\t *      possible landmark types.\n\t *      Tier 5 has its landmark type predefined (arena), lower tiers don't have a landmark.\n\t *\n\t * @dev Function works in a deterministic way and derives the same data\n\t *      for the same inputs; the term \"random\" in comments means \"pseudo-random\"\n\t *\n\t * @param seed random seed to consume and derive the landmark type based on\n\t * @param tierId tier ID of the land plot\n\t * @return landmarkTypeId landmark type defined by its ID\n\t */\n\tfunction getLandmark(uint256 seed, uint8 tierId) internal pure returns (uint8 landmarkTypeId) {\n\t\t// depending on the tier, land plot can have a landmark\n\t\t// tier 3 has an element landmark (1, 2, 3)\n\t\tif(tierId == 3) {\n\t\t\t// derive random element landmark\n\t\t\treturn uint8(1 + seed % 3);\n\t\t}\n\t\t// tier 4 has a fuel landmark (4, 5, 6)\n\t\tif(tierId == 4) {\n\t\t\t// derive random fuel landmark\n\t\t\treturn uint8(4 + seed % 3);\n\t\t}\n\t\t// tier 5 has an arena landmark\n\t\tif(tierId == 5) {\n\t\t\t// 7 - arena landmark\n\t\t\treturn 7;\n\t\t}\n\n\t\t// lower tiers (0, 1, 2) don't have any landmark\n\t\t// tiers greater than 5 are not defined\n\t\treturn 0;\n\t}\n\n\t/**\n\t * @dev Derives an array of integers with no duplicates from the random seed;\n\t *      each element in the array is within [0, size) bounds and represents\n\t *      a two-dimensional Cartesian coordinate point (x, y) presented as one-dimensional\n\t *\n\t * @dev Function works in a deterministic way and derives the same data\n\t *      for the same inputs; the term \"random\" in comments means \"pseudo-random\"\n\t *\n\t * @dev The input seed is considered to be already used to derive some random value\n\t *      from it, therefore the function derives a new one by hashing the previous one\n\t *      before generating the random value; the output seed is \"used\" - output random\n\t *      value is derived from it\n\t *\n\t * @param seed random seed to consume and derive coordinates from\n\t * @param length number of elements to generate\n\t * @param size defines array element bounds [0, size)\n\t * @return nextSeed next pseudo-random \"used\" seed\n\t * @return coords the resulting array of length `n` with random non-repeating elements\n\t *      in [0, size) range\n\t */\n\tfunction getCoords(\n\t\tuint256 seed,\n\t\tuint8 length,\n\t\tuint16 size\n\t) internal pure returns (uint256 nextSeed, uint16[] memory coords) {\n\t\t// allocate temporary array to store (and determine) sites' coordinates\n\t\tcoords = new uint16[](length);\n\n\t\t// generate site coordinates one by one\n\t\tfor(uint8 i = 0; i < coords.length; i++) {\n\t\t\t// get next number and update the seed\n\t\t\t(seed, coords[i]) = nextRndUint16(seed, 0, size);\n\t\t}\n\n\t\t// sort the coordinates\n\t\tsort(coords);\n\n\t\t// find the if there are any duplicates, and while there are any\n\t\tfor(int256 i = findDup(coords); i >= 0; i = findDup(coords)) {\n\t\t\t// regenerate the element at duplicate position found\n\t\t\t(seed, coords[uint256(i)]) = nextRndUint16(seed, 0, size);\n\t\t\t// sort the coordinates again\n\t\t\t// TODO: check if this doesn't degrade the performance significantly (note the pivot in quick sort)\n\t\t\tsort(coords);\n\t\t}\n\n\t\t// shuffle the array to compensate for the sorting made before\n\t\tseed = shuffle(seed, coords);\n\n\t\t// return the updated used seed, and generated coordinates\n\t\treturn (seed, coords);\n\t}\n\n\t/**\n\t * @dev Based on the random seed, generates next random seed, and a random value\n\t *      not lower than given `offset` value and able to have `options` different\n\t *      possible values\n\t *\n\t * @dev The input seed is considered to be already used to derive some random value\n\t *      from it, therefore the function derives a new one by hashing the previous one\n\t *      before generating the random value; the output seed is \"used\" - output random\n\t *      value is derived from it\n\t *\n\t * @param seed random seed to consume and derive next random value from\n\t * @param offset the minimum possible output\n\t * @param options number of different possible values to output\n\t * @return nextSeed next pseudo-random \"used\" seed\n\t * @return rndVal random value in the [offset, offset + options) range\n\t */\n\tfunction nextRndUint16(\n\t\tuint256 seed,\n\t\tuint16 offset,\n\t\tuint16 options\n\t) internal pure returns (\n\t\tuint256 nextSeed,\n\t\tuint16 rndVal\n\t) {\n\t\t// generate next random seed first\n\t\tnextSeed = uint256(keccak256(abi.encodePacked(seed)));\n\n\t\t// derive random value with the desired properties from\n\t\t// the newly generated seed\n\t\trndVal = offset + uint16(nextSeed % options);\n\n\t\t// return the result as tuple\n\t\treturn (nextSeed, rndVal);\n\t}\n\n\t/**\n\t * @dev Plot location is a combination of (regionId, x, y), it's effectively\n\t *      a 3-dimensional coordinate, unique for each plot\n\t *\n\t * @dev The function extracts plot location from the plot and represents it\n\t *      in a packed form of 3 integers constituting the location: regionId | x | y\n\t *\n\t * @param plot `PlotView` view structure to extract location from\n\t * @return Plot location (regionId, x, y) as a packed integer\n\t */\n/*\n\tfunction loc(PlotView memory plot) internal pure returns (uint40) {\n\t\t// tightly pack the location data and return\n\t\treturn uint40(plot.regionId) << 32 | uint32(plot.y) << 16 | plot.x;\n\t}\n*/\n\n\t/**\n\t * @dev Plot location is a combination of (regionId, x, y), it's effectively\n\t *      a 3-dimensional coordinate, unique for each plot\n\t *\n\t * @dev The function extracts plot location from the plot and represents it\n\t *      in a packed form of 3 integers constituting the location: regionId | x | y\n\t *\n\t * @param plot `PlotStore` data store structure to extract location from\n\t * @return Plot location (regionId, x, y) as a packed integer\n\t */\n\tfunction loc(PlotStore memory plot) internal pure returns (uint40) {\n\t\t// tightly pack the location data and return\n\t\treturn uint40(plot.regionId) << 32 | uint32(plot.y) << 16 | plot.x;\n\t}\n\n\t/**\n\t * @dev Site location is a combination of (x, y), unique for each site within a plot\n\t *\n\t * @dev The function extracts site location from the site and represents it\n\t *      in a packed form of 2 integers constituting the location: x | y\n\t *\n\t * @param site `Site` view structure to extract location from\n\t * @return Site location (x, y) as a packed integer\n\t */\n/*\n\tfunction loc(Site memory site) internal pure returns (uint32) {\n\t\t// tightly pack the location data and return\n\t\treturn uint32(site.y) << 16 | site.x;\n\t}\n*/\n\n\t/**\n\t * @dev Finds first pair of repeating elements in the array\n\t *\n\t * @dev Assumes the array is sorted ascending:\n\t *      returns `-1` if array is strictly monotonically increasing,\n\t *      index of the first duplicate found otherwise\n\t *\n\t * @param arr an array of elements to check\n\t * @return index found duplicate index, or `-1` if there are no repeating elements\n\t */\n\tfunction findDup(uint16[] memory arr) internal pure returns (int256 index) {\n\t\t// iterate over the array [1, n], leaving the space in the beginning for pair comparison\n\t\tfor(uint256 i = 1; i < arr.length; i++) {\n\t\t\t// verify if there is a strict monotonically increase violation\n\t\t\tif(arr[i - 1] >= arr[i]) {\n\t\t\t\t// return its index if yes\n\t\t\t\treturn int256(i - 1);\n\t\t\t}\n\t\t}\n\n\t\t// return `-1` if no violation was found - array is strictly monotonically increasing\n\t\treturn -1;\n\t}\n\n\t/**\n\t * @dev Shuffles an array if integers by making random permutations\n\t *      in the amount equal to the array size\n\t *\n\t * @dev The input seed is considered to be already used to derive some random value\n\t *      from it, therefore the function derives a new one by hashing the previous one\n\t *      before generating the random value; the output seed is \"used\" - output random\n\t *      value is derived from it\n\t *\n\t * @param seed random seed to consume and derive next random value from\n\t * @param arr an array to shuffle\n\t * @return nextSeed next pseudo-random \"used\" seed\n\t */\n\tfunction shuffle(uint256 seed, uint16[] memory arr) internal pure returns(uint256 nextSeed) {\n\t\t// define index `j` to permute with loop index `i` outside the loop to help compiler optimizations\n\t\tuint16 j;\n\n\t\t// iterate over the array one single time\n\t\tfor(uint16 i = 0; i < arr.length; i++) {\n\t\t\t// determine random index `j` to swap with the loop index `i`\n\t\t\t(seed, j) = nextRndUint16(seed, 0, uint16(arr.length));\n\n\t\t\t// do the swap\n\t\t\t(arr[i], arr[j]) = (arr[j], arr[i]);\n\t\t}\n\n\t\t// return the updated used seed\n\t\treturn seed;\n\t}\n\n\t/**\n\t * @dev Sorts an array of integers using quick sort algorithm\n\t *\n\t * @dev Quick sort recursive implementation\n\t *      Source:   https://gist.github.com/subhodi/b3b86cc13ad2636420963e692a4d896f\n\t *      See also: https://www.geeksforgeeks.org/quick-sort/\n\t *\n\t * @param arr an array to sort\n\t */\n\tfunction sort(uint16[] memory arr) internal pure {\n\t\tquickSort(arr, 0, int256(arr.length) - 1);\n\t}\n\n\t/**\n\t * @dev Quick sort recursive implementation\n\t *      Source:     https://gist.github.com/subhodi/b3b86cc13ad2636420963e692a4d896f\n\t *      Discussion: https://blog.cotten.io/thinking-in-solidity-6670c06390a9\n\t *      See also:   https://www.geeksforgeeks.org/quick-sort/\n\t */\n\t// TODO: review the implementation code\n\tfunction quickSort(uint16[] memory arr, int256 left, int256 right) private pure {\n\t\tint256 i = left;\n\t\tint256 j = right;\n\t\tif(i >= j) {\n\t\t\treturn;\n\t\t}\n\t\tuint16 pivot = arr[uint256(left + (right - left) / 2)];\n\t\twhile(i <= j) {\n\t\t\twhile(arr[uint256(i)] < pivot) {\n\t\t\t\ti++;\n\t\t\t}\n\t\t\twhile(pivot < arr[uint256(j)]) {\n\t\t\t\tj--;\n\t\t\t}\n\t\t\tif(i <= j) {\n\t\t\t\t(arr[uint256(i)], arr[uint256(j)]) = (arr[uint256(j)], arr[uint256(i)]);\n\t\t\t\ti++;\n\t\t\t\tj--;\n\t\t\t}\n\t\t}\n\t\tif(left < j) {\n\t\t\tquickSort(arr, left, j);\n\t\t}\n\t\tif(i < right) {\n\t\t\tquickSort(arr, i, right);\n\t\t}\n\t}\n}\n"
    },
    "contracts/lib/LandSvgLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./LandLib.sol\";\nimport \"base64-sol/base64.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"prb-math/contracts/PRBMathUD60x18.sol\";\n\n/**\n * @title Land SVG Library\n *\n * @notice Provide functions to generate SVG image representation of the LandERC721, and other\n *      auxiliary functions to construct token metadata JSON, and encode it into base64 format.\n *\n * @dev The metadata format, returned by `constructTokenURI` function conforms with the official\n *\tERC721 metadata standard.\n *\n * @dev There are basically 3 components of the metadata schema, the name, description and the image itself.\n *\teach of them have it's generating functions, `generateLandName`, `generateLandDescription` and `_generateSVGImage`.\n *\n * @dev The output of `_generateSVGImage` will be encoded as Base64 so that the browser can interpret it, as well as the\n *\tentire output of `constructTokenURI`.\n *\n * @dev LandDescriptor should call `constructTokenURI` in order to get the encoded ERC721 metadata.\n *\n * @author Pedro Bergamini, Yuri Fernandes, Estevan Wisoczynski\n */\nlibrary LandSvgLib {\n\tusing Strings for uint256;\n\tusing PRBMathUD60x18 for uint256;\n\n\t/**\n\t * @dev Generate the Land SVG image.\n\t *\n\t * @param _gridSize The size of the grid\n\t * @param _tierId PlotView.tierId land tier id\n\t * @param _landmarkTypeId landmark type id\n\t * @param _sites array of LandLib.Site\n\t * @return Land SVG image\n\t */\n\tfunction _generateSVGImage(\n\t\tuint16 _gridSize, \n\t\tuint8 _tierId, \n\t\tuint8 _landmarkTypeId,\n\t\tLandLib.Site[] memory _sites\n\t) private pure returns (string memory) {\n\t\t// Multiply by 3 to get number of grid squares = dimension of the isomorphic grid size\n\n\t\treturn string(\n\t\t\tabi.encodePacked(\n\t\t\t\t\"<svg height='\",\n\t\t\t\tuint256(_gridSize * 3 + 6).toString(),\n\t\t\t\t\"' width='\",\n\t\t\t\tuint256(_gridSize * 3).toString(),\n\t\t\t\t\"' stroke-width='2' xmlns='http://www.w3.org/2000/svg'>\",\n\t\t\t\t\"<rect rx='5%' ry='5%' width='100%' height='99%' fill='url(#BOARD_BOTTOM_BORDER_COLOR_TIER_\",\n\t\t\t\tuint256(_tierId).toString(),\n\t\t\t\t\")' stroke='none'/>\",\n\t\t\t\t\"<svg height='97.6%' width='100%' stroke-width='2' xmlns='http://www.w3.org/2000/svg'>\",\n\t\t\t\t_generateLandBoard(_gridSize, _tierId, _landmarkTypeId, _sites), // This line should be replaced in the loop\n\t\t\t\t\"</svg>\"\n\t\t\t)\n\t\t);\n\t}\n\n\t/**\n\t * @dev Returns the site base svg array component, used to represent\n\t *      a site inside the land board.\n\t *\n\t * @param _x Sites.x position\n\t * @param _y Sites.y position\n\t * @param _typeId Sites.typeId\n\t * @return The base SVG element for the sites\n\t */\n\tfunction _siteBaseSvg(uint16 _x, uint16 _y, uint8 _typeId) private pure returns (string memory) {\n\t\treturn string(\n\t\t\tabi.encodePacked(\n\t\t\t\t\"<svg x='\", \n\t\t\t\tuint256(_x).toString(), \n\t\t\t\t\"' y='\", \n\t\t\t\tuint256(_y).toString(),\n\t\t\t\t\"' width='6' height='6' xmlns='http://www.w3.org/2000/svg'><use href='#SITE_TYPE_\",\n\t\t\t\tuint256(_typeId).toString(),\n\t\t\t\t\"' /></svg>\"\n\t\t\t)\n\t\t);\n\t}\n\n\t/**\n\t * @dev Returns the site base svg array component, used to represent\n\t *      a landmark inside the land board.\n\t *\n\t * @param _gridSize The size of the grid\n\t * @param _landmarkTypeId landmark type defined by its ID\n\t * @return Concatenation of the landmark SVG component to be added the board SVG\n\t */\n\tfunction _generateLandmarkSvg(uint16 _gridSize, uint8 _landmarkTypeId) private pure returns (string memory) {\n\t\tuint256 landmarkPos = uint256(_gridSize - 2).fromUint().div(uint256(2).fromUint()).mul(uint256(3).fromUint());\n\n\t\tstring memory landmarkFloatX;\n\t\tstring memory landmarkFloatY;\n\t\tif (_gridSize % 2 == 0) {\n\t\t\tlandmarkFloatX = landmarkPos.toUint().toString();\n\t\t\tlandmarkFloatY = (landmarkPos.toUint() - 3).toString();\n\t\t} else {\n\t\t\tlandmarkFloatX = (landmarkPos.ceil().toUint() + 1).toString();\n\t\t\tlandmarkFloatY = (landmarkPos.floor().toUint() - 1).toString();\n\t\t}\n\n\t\treturn string(\n\t\t\tabi.encodePacked(\n\t\t\t\t\"<svg x='\",\n\t\t\t\tlandmarkFloatX,\n\t\t\t\t\"' y='\",\n\t\t\t\tlandmarkFloatY,\n\t\t\t\t\"' width='12' height='12' xmlns='http://www.w3.org/2000/svg'><use href='#LANDMARK_TYPE_\",\n\t\t\t\tuint256(_landmarkTypeId).toString(),\n\t\t\t\t\"'/></svg>\"\n\t\t\t)\n\t\t);\n\t}\n\n\t/**\n\t * @dev Returns the land board base svg array component, which has its color changed\n\t *      later in other functions.\n\t *\n\t * @param _gridSize The size of the grid\n\t * @param _tierId PlotView.tierId land tier id\n\t * @param _landmarkTypeId landmark type id\n\t * @param _sites array of LandLib.Site\n\t * @return Array of board SVG component parts\n\t */\n\tfunction _landBoardArray(\n\t\tuint16 _gridSize, \n\t\tuint8 _tierId, \n\t\tuint8 _landmarkTypeId, \n\t\tLandLib.Site[] memory _sites\n\t) private pure returns (string[170] memory) {\n\t\tuint256 scaledGridSize = uint256(_gridSize).fromUint().div(uint256(2).fromUint()).mul(uint256(3).fromUint());\n\t\tstring memory scaledGridSizeString = string(\n\t\t\tabi.encodePacked(\n\t\t\t\tscaledGridSize.toUint().toString(),\n\t\t\t\t\".\",\n\t\t\t\t(scaledGridSize.frac()/1e16).toString()\n\t\t\t)\n\t\t);\n\t\treturn [\n\t\t\t\"<defs><symbol id='SITE_TYPE_1' width='6' height='6'>\", // Site Carbon\n\t\t\t\"<svg width='6' height='6' viewBox='0 0 14 14' fill='none' xmlns='http://www.w3.org/2000/svg'>\",\n\t\t\t\"<rect x='1.12' y='1' width='12' height='12' fill='url(#site-type-1)' stroke='white' stroke-opacity='0.5'/>\",\n\t\t\t\"<defs><linearGradient id='site-type-1' x1='13.12' y1='1' x2='1.12' y2='13' gradientUnits='userSpaceOnUse'>\",\n\t\t\t\"<stop stop-color='#565656'/><stop offset='1'/></linearGradient></defs></svg></symbol>\",\n\t\t\t\"<symbol id='SITE_TYPE_2' width='6' height='6'>\", // Site Silicon\n\t\t\t\"<svg width='6' height='6' viewBox='0 0 12 12' fill='none' xmlns='http://www.w3.org/2000/svg'>\",\n\t\t\t\"<rect x='1.12' y='1' width='10' height='10' fill='url(#paint0_linear_1321_129011)' stroke='white' stroke-opacity='0.5'/>\",\n\t\t\t\"<defs><linearGradient id='paint0_linear_1321_129011' x1='11.12' y1='1' x2='1.12' y2='11' gradientUnits='userSpaceOnUse'>\",\n\t\t\t\"<stop stop-color='#CBE2FF'/><stop offset='1' stop-color='#EFEFEF'/></linearGradient></defs></svg></symbol>\",\n\t\t\t\"<symbol id='SITE_TYPE_3' width='6' height='6'>\", // Site Hydrogen\n\t\t\t\"<svg width='6' height='6' viewBox='0 0 12 12' fill='none' xmlns='http://www.w3.org/2000/svg'>\",\n\t\t\t\"<rect x='1.12' y='1' width='10' height='10' fill='url(#paint0_linear_1320_145814)' stroke='white' stroke-opacity='0.5'/>\",\n\t\t\t\"<defs><linearGradient id='paint0_linear_1320_145814' x1='11.12' y1='1' x2='-0.862058' y2='7.11845' gradientUnits='userSpaceOnUse'>\",\n\t\t\t\"<stop stop-color='#8CD4D9'/><stop offset='1' stop-color='#598FA6'/></linearGradient></defs></svg></symbol>\",\n\t\t\t\"<symbol id='SITE_TYPE_4' width='6' height='6'>\", // Site Crypton\n\t\t\t\"<svg width='6' height='6' viewBox='0 0 12 12' fill='none' xmlns='http://www.w3.org/2000/svg'>\",\n\t\t\t\"<rect x='1.12' y='1' width='10' height='10' fill='url(#paint0_linear_1321_129013)' stroke='white' stroke-opacity='0.5'/>\",\n\t\t\t\"<defs><linearGradient id='paint0_linear_1321_129013' x1='11.12' y1='1' x2='1.12' y2='11' gradientUnits='userSpaceOnUse'>\",\n\t\t\t\"<stop offset='1' stop-color='#52FF00'/></linearGradient></defs></svg></symbol>\",\n\t\t\t\"<symbol id='SITE_TYPE_5' width='6' height='6'>\", // Site Hyperion\n\t\t\t\"<svg width='6' height='6' viewBox='0 0 12 12' fill='none' xmlns='http://www.w3.org/2000/svg'>\",\n\t\t\t\"<rect x='1.12' y='1' width='10' height='10' fill='url(#paint0_linear_1321_129017)' stroke='white' stroke-opacity='0.5'/>\",\n\t\t\t\"<defs><linearGradient id='paint0_linear_1321_129017' x1='11.12' y1='1' x2='1.12' y2='11' gradientUnits='userSpaceOnUse'>\",\n\t\t\t\"<stop stop-color='#31F27F'/><stop offset='0.296875' stop-color='#F4BE86'/><stop offset='0.578125' stop-color='#B26FD2'/>\",\n\t\t\t\"<stop offset='0.734375' stop-color='#7F70D2'/><stop offset='1' stop-color='#8278F2'/></linearGradient></defs></svg></symbol>\",\n\t\t\t\"<symbol id='SITE_TYPE_6' width='6' height='6'>\",\n\t\t\t\"<svg width='6' height='6' viewBox='0 0 12 12' fill='none' xmlns='http://www.w3.org/2000/svg'>\", // Site Solon\n\t\t\t\"<rect x='1.12' y='1' width='10' height='10' fill='url(#paint0_linear_1321_129015)' stroke='white' stroke-opacity='0.5'/>\",\n\t\t\t\"<defs><linearGradient id='paint0_linear_1321_129015' x1='11.12' y1='1' x2='1.11999' y2='11' gradientUnits='userSpaceOnUse'>\",\n\t\t\t\"<stop stop-color='white'/><stop offset='0.544585' stop-color='#FFD600'/><stop offset='1' stop-color='#FF9900'/>\",\n\t\t\t\"</linearGradient></defs></svg></symbol>\",\n\t\t\t\"<linearGradient id='BOARD_BOTTOM_BORDER_COLOR_TIER_5' xmlns='http://www.w3.org/2000/svg'>\",\n\t\t\t\"<stop stop-color='#BE13AE'/></linearGradient><linearGradient\",\n\t\t\t\" id='BOARD_BOTTOM_BORDER_COLOR_TIER_4' xmlns='http://www.w3.org/2000/svg'>\",\n\t\t\t\"<stop stop-color='#1F7460'/></linearGradient><linearGradient\",\n\t\t\t\" id='BOARD_BOTTOM_BORDER_COLOR_TIER_3' xmlns='http://www.w3.org/2000/svg'>\",\n\t\t\t\"<stop stop-color='#6124AE'/></linearGradient><linearGradient\",\n\t\t\t\" id='BOARD_BOTTOM_BORDER_COLOR_TIER_2' xmlns='http://www.w3.org/2000/svg'>\",\n\t\t\t\"<stop stop-color='#5350AA'/></linearGradient><linearGradient\",\n\t\t\t\" id='BOARD_BOTTOM_BORDER_COLOR_TIER_1' xmlns='http://www.w3.org/2000/svg'>\",\n\t\t\t\"<stop stop-color='#2C2B67'/></linearGradient>\",\n\t\t\t\"<linearGradient id='GRADIENT_BOARD_TIER_5' x1='100%' y1='0' x2='100%' y2='100%'\", \n\t\t\t\" gradientUnits='userSpaceOnUse' xmlns='http://www.w3.org/2000/svg'>\",\n\t\t\t\"<stop offset='0.130208' stop-color='#EFD700'/>\",\n\t\t\t\"<stop offset='0.6875' stop-color='#FF57EE'/><stop offset='1' stop-color='#9A24EC'/>\",\n\t\t\t\"</linearGradient><linearGradient id='GRADIENT_BOARD_TIER_4' x1='50%' y1='100%' x2='50%' y2='0'\",\n\t\t\t\" gradientUnits='userSpaceOnUse' xmlns='http://www.w3.org/2000/svg'>\",\n\t\t\t\"<stop stop-color='#239378'/><stop offset='1' stop-color='#41E23E'/></linearGradient>\",\n\t\t\t\"<linearGradient id='GRADIENT_BOARD_TIER_3' x1='50%' y1='100%' x2='50%' y2='0'\",\n\t\t\t\" gradientUnits='userSpaceOnUse' xmlns='http://www.w3.org/2000/svg'>\",\n\t\t\t\"<stop stop-color='#812DED'/><stop offset='1' stop-color='#F100D9'/></linearGradient>\",\n\t\t\t\"<linearGradient id='GRADIENT_BOARD_TIER_2' x1='50%' y1='0' x2='50%' y2='100%'\",\n\t\t\t\" gradientUnits='userSpaceOnUse' xmlns='http://www.w3.org/2000/svg'>\",\n\t\t\t\"<stop stop-color='#7DD6F2'/><stop offset='1' stop-color='#625EDC'/></linearGradient>\",\n\t\t\t\"<linearGradient id='GRADIENT_BOARD_TIER_1' x1='50%' y1='0' x2='50%' y2='100%'\",\n\t\t\t\" gradientUnits='userSpaceOnUse' xmlns='http://www.w3.org/2000/svg'>\",\n\t\t\t\"<stop stop-color='#4C44A0'/><stop offset='1' stop-color='#2F2C83'/></linearGradient>\",\n\t\t\t\"<linearGradient id='ROUNDED_BORDER_TIER_5' x1='100%' y1='16.6%' x2='100%' y2='100%'\",\n\t\t\t\" gradientUnits='userSpaceOnUse' xmlns='http://www.w3.org/2000/svg'>\",\n\t\t\t\"<stop stop-color='#D2FFD9'/><stop offset='1' stop-color='#F32BE1'/></linearGradient>\",\n\t\t\t\"<linearGradient id='ROUNDED_BORDER_TIER_4' x1='100%' y1='16.6%' x2='100%' y2='100%'\",\n\t\t\t\" gradientUnits='userSpaceOnUse' xmlns='http://www.w3.org/2000/svg'>\",\n\t\t\t\"<stop stop-color='#fff' stop-opacity='0.38'/><stop offset='1' stop-color='#fff'\",\n\t\t\t\" stop-opacity='0.08'/></linearGradient>\",\n\t\t\t\"<linearGradient id='ROUNDED_BORDER_TIER_3' x1='100%' y1='16.6%' x2='100%' y2='100%'\",\n\t\t\t\" gradientUnits='userSpaceOnUse' xmlns='http://www.w3.org/2000/svg'>\",\n\t\t\t\"<stop stop-color='#fff' stop-opacity='0.38'/><stop offset='1' stop-color='#fff'\",\n\t\t\t\" stop-opacity='0.08'/></linearGradient>\",\n\t\t\t\"<linearGradient id='ROUNDED_BORDER_TIER_2' x1='100%' y1='16.6%' x2='100%' y2='100%'\",\n\t\t\t\" gradientUnits='userSpaceOnUse' xmlns='http://www.w3.org/2000/svg'>\",\n\t\t\t\"<stop stop-color='#fff' stop-opacity='0.38'/><stop offset='1' stop-color='#fff'\",\n\t\t\t\" stop-opacity='0.08'/></linearGradient>\",\n\t\t\t\"<linearGradient id='ROUNDED_BORDER_TIER_1' x1='100%' y1='16.6%' x2='100%' y2='100%'\",\n\t\t\t\" gradientUnits='userSpaceOnUse' xmlns='http://www.w3.org/2000/svg'>\",\n\t\t\t\"<stop stop-color='#fff' stop-opacity='0.38'/><stop offset='1' stop-color='#fff'\",\n\t\t\t\" stop-opacity='0.08'/></linearGradient>\",\n\t\t\t\"<pattern id='smallGrid' width='3' height='3' patternUnits='userSpaceOnUse' patternTransform='rotate(45 \",\n\t\t\tstring(abi.encodePacked(scaledGridSizeString, \" \", scaledGridSizeString)),\n\t\t\t\")'><path d='M 3 0 L 0 0 0 3' fill='none' stroke-width='0.3%' stroke='#130A2A' stroke-opacity='0.2' />\",\n\t\t\t\"</pattern><symbol id='LANDMARK_TYPE_1' width='12' height='12'>\",\n\t\t\t\"<svg width='12' height='12' viewBox='0 0 14 14' fill='none' xmlns='http://www.w3.org/2000/svg'>\",\n\t\t\t\"<rect x='1.12' y='1' width='12' height='12' fill='url(#paint0_linear_2371_558677)' stroke='white' stroke-opacity='0.5'/>\",\n\t\t\t\"<rect x='4.72' y='4.59998' width='4.8' height='4.8' fill='url(#paint1_linear_2371_558677)'/>\",\n\t\t\t\"<rect x='4.72' y='4.59998' width='4.8' height='4.8' fill='white'/>\",\n\t\t\t\"<defs><linearGradient id='paint0_linear_2371_558677' x1='13.12' y1='1' x2='1.12' y2='13' gradientUnits='userSpaceOnUse'>\",\n\t\t\t\"<stop stop-color='#565656'/><stop offset='1'/></linearGradient>\",\n\t\t\t\"<linearGradient id='paint1_linear_2371_558677' x1='9.52' y1='4.59998' x2='4.72' y2='9.39998' gradientUnits='userSpaceOnUse'>\",\n\t\t\t\"<stop stop-color='#565656'/><stop offset='1'/></linearGradient></defs></svg></symbol>\",\n\t\t\t\"<symbol id='LANDMARK_TYPE_2' width='12' height='12'><svg width='12' height='12'\",\n\t\t\t\" viewBox='0 0 12 12' fill='none' xmlns='http://www.w3.org/2000/svg'>\",\n\t\t\t\"<rect x='1.12' y='1' width='10' height='10' fill='url(#paint0_linear_2371_558683)' stroke='white' stroke-opacity='0.5'/>\",\n\t\t\t\"<rect x='4.12' y='4' width='4' height='4' fill='url(#paint1_linear_2371_558683)'/>\",\n\t\t\t\"<rect x='4.12' y='4' width='4' height='4' fill='white'/>\",\n\t\t\t\"<rect x='3.62' y='3.5' width='5' height='5' stroke='black' stroke-opacity='0.1'/>\",\n\t\t\t\"<defs><linearGradient id='paint0_linear_2371_558683' x1='11.12' y1='1' x2='-0.862058' y2='7.11845'\",\n\t\t\t\" gradientUnits='userSpaceOnUse'>\",\n\t\t\t\"<stop stop-color='#8CD4D9'/><stop offset='1' stop-color='#598FA6'/></linearGradient>\",\n\t\t\t\"<linearGradient id='paint1_linear_2371_558683' x1='8.12' y1='4' x2='4.12' y2='8' gradientUnits='userSpaceOnUse'>\",\n\t\t\t\"<stop stop-color='#565656'/><stop offset='1'/></linearGradient></defs></svg></symbol>\",\n\t\t\t\"<symbol id='LANDMARK_TYPE_3' width='12' height='12'>\",\n\t\t\t\"<svg width='12' height='12' viewBox='0 0 12 12' fill='none' xmlns='http://www.w3.org/2000/svg'>\",\n\t\t\t\"<rect x='1.12' y='1' width='10' height='10' fill='url(#paint0_linear_2371_558686)' stroke='white' stroke-opacity='0.5'/>\",\n\t\t\t\"<rect x='4.12' y='4' width='4' height='4' fill='url(#paint1_linear_2371_558686)'/>\",\n\t\t\t\"<rect x='4.12' y='4' width='4' height='4' fill='white'/>\",\n\t\t\t\"<rect x='3.62' y='3.5' width='5' height='5' stroke='black' stroke-opacity='0.1'/>\",\n\t\t\t\"<defs><linearGradient id='paint0_linear_2371_558686' x1='11.12' y1='1' x2='1.12' y2='11' gradientUnits='userSpaceOnUse'>\",\n\t\t\t\"<stop stop-color='#CBE2FF'/><stop offset='1' stop-color='#EFEFEF'/></linearGradient>\",\n\t\t\t\"<linearGradient id='paint1_linear_2371_558686' x1='8.12' y1='4' x2='4.12' y2='8' gradientUnits='userSpaceOnUse'>\",\n\t\t\t\"<stop stop-color='#565656'/><stop offset='1'/></linearGradient></defs></svg></symbol>\",\n\t\t\t\"<symbol id='LANDMARK_TYPE_4' width='12' height='12'>\",\n\t\t\t\"<svg width='12' height='12' viewBox='0 0 12 12' fill='none' xmlns='http://www.w3.org/2000/svg'>\",\n\t\t\t\"<rect x='1.12' y='1' width='10' height='10' fill='url(#paint0_linear_2371_558689)' stroke='white' stroke-opacity='0.5'/>\",\n\t\t\t\"<rect x='4.12' y='4' width='4' height='4' fill='url(#paint1_linear_2371_558689)'/>\",\n\t\t\t\"<rect x='4.12' y='4' width='4' height='4' fill='white'/>\",\n\t\t\t\"<rect x='3.62' y='3.5' width='5' height='5' stroke='black' stroke-opacity='0.1'/>\",\n\t\t\t\"<defs><linearGradient id='paint0_linear_2371_558689' x1='11.12' y1='1' x2='1.12' y2='11' gradientUnits='userSpaceOnUse'>\",\n\t\t\t\"<stop stop-color='#184B00'/><stop offset='1' stop-color='#52FF00'/></linearGradient>\",\n\t\t\t\"<linearGradient id='paint1_linear_2371_558689' x1='8.12' y1='4' x2='4.12' y2='8' gradientUnits='userSpaceOnUse'>\",\n\t\t\t\"<stop stop-color='#565656'/><stop offset='1'/></linearGradient></defs></svg></symbol>\",\n\t\t\t\"<symbol id='LANDMARK_TYPE_5' width='12' height='12'>\",\n\t\t\t\"<svg width='12' height='12' viewBox='0 0 12 12' fill='none' xmlns='http://www.w3.org/2000/svg'>\",\n\t\t\t\"<rect x='1.12' y='1' width='10' height='10' fill='url(#paint0_linear_2371_558695)' stroke='white' stroke-opacity='0.5'/>\",\n\t\t\t\"<rect x='4.12' y='4' width='4' height='4' fill='url(#paint1_linear_2371_558695)'/>\",\n\t\t\t\"<rect x='4.12' y='4' width='4' height='4' fill='white'/>\",\n\t\t\t\"<rect x='3.62' y='3.5' width='5' height='5' stroke='black' stroke-opacity='0.1'/>\",\n\t\t\t\"<defs><linearGradient id='paint0_linear_2371_558695' x1='11.12' y1='1' x2='1.12' y2='11' gradientUnits='userSpaceOnUse'>\",\n\t\t\t\"<stop stop-color='#31F27F'/><stop offset='0.296875' stop-color='#F4BE86'/><stop offset='0.578125' stop-color='#B26FD2'/>\",\n\t\t\t\"<stop offset='0.734375' stop-color='#7F70D2'/><stop offset='1' stop-color='#8278F2'/></linearGradient>\",\n\t\t\t\"<linearGradient id='paint1_linear_2371_558695' x1='8.12' y1='4' x2='4.12' y2='8' gradientUnits='userSpaceOnUse'>\",\n\t\t\t\"<stop stop-color='#565656'/><stop offset='1'/></linearGradient></defs></svg></symbol>\",\n\t\t\t\"<symbol id='LANDMARK_TYPE_6' width='12' height='12'>\",\n\t\t\t\"<svg width='12' height='12' viewBox='0 0 12 12' fill='none' xmlns='http://www.w3.org/2000/svg'>\",\n\t\t\t\"<rect x='1.12' y='1' width='10' height='10' fill='url(#paint0_linear_2371_558692)' stroke='white' stroke-opacity='0.5'/>\",\n\t\t\t\"<rect x='4.12' y='4' width='4' height='4' fill='url(#paint1_linear_2371_558692)'/>\",\n\t\t\t\"<rect x='4.12' y='4' width='4' height='4' fill='white'/>\",\n\t\t\t\"<rect x='3.62' y='3.5' width='5' height='5' stroke='black' stroke-opacity='0.1'/>\",\n\t\t\t\"<defs><linearGradient id='paint0_linear_2371_558692' x1='11.12' y1='1' x2='1.11999' y2='11' gradientUnits='userSpaceOnUse'>\",\n\t\t\t\"<stop stop-color='white'/><stop offset='0.544585' stop-color='#FFD600'/><stop offset='1' stop-color='#FF9900'/></linearGradient>\",\n\t\t\t\"<linearGradient id='paint1_linear_2371_558692' x1='8.12' y1='4' x2='4.12' y2='8' gradientUnits='userSpaceOnUse'>\",\n\t\t\t\"<stop stop-color='#565656'/><stop offset='1'/></linearGradient></defs></svg></symbol>\",\n\t\t\t\"<symbol id='LANDMARK_TYPE_7' width='12' height='12'>\",\n\t\t\t\"<svg width='12' height='12' viewBox='0 0 12 12' fill='none' xmlns='http://www.w3.org/2000/svg'>\",\n\t\t\t\"<rect x='1.12' y='1' width='10' height='10' fill='url(#paint0_linear_2373_559424)' stroke='white' stroke-opacity='0.5'/>\",\n\t\t\t\"<rect x='3.12' y='3' width='6' height='6' fill='url(#paint1_linear_2373_559424)'/>\",\n\t\t\t\"<rect x='3.12' y='3' width='6' height='6' fill='white'/>\",\n\t\t\t\"<rect x='2.62' y='2.5' width='7' height='7' stroke='black' stroke-opacity='0.1'/>\",\n\t\t\t\"<defs><linearGradient id='paint0_linear_2373_559424' x1='11.12' y1='1' x2='1.11999' y2='11' gradientUnits='userSpaceOnUse'>\",\n\t\t\t\"<stop stop-color='#08CE01'/><stop offset='0.171875' stop-color='#CEEF00'/><stop offset='0.34375' stop-color='#51F980'/>\",\n\t\t\t\"<stop offset='0.5' stop-color='#2D51ED'/><stop offset='0.671875' stop-color='#0060F1'/>\",\n\t\t\t\"<stop offset='0.833333' stop-color='#F100D9'/>\",\n\t\t\t\"<stop offset='1' stop-color='#9A24EC'/></linearGradient>\",\n\t\t\t\"<linearGradient id='paint1_linear_2373_559424' x1='9.12' y1='3' x2='3.12' y2='9' gradientUnits='userSpaceOnUse'>\",\n\t\t\t\"<stop stop-color='#565656'/><stop offset='1'/></linearGradient></defs></svg></symbol>\",\n\t\t\t\"</defs><rect width='100%' height='100%' fill='url(#GRADIENT_BOARD_TIER_\",\n\t\t\tuint256(_tierId).toString(), // This line should be replaced in the loop\n\t\t\t\")' stroke='none' rx='5%' ry='5%'/><svg x='\",\n\t\t\t_gridSize % 2 == 0 \n\t\t\t\t? \"-17%' y='-17%' width='117%' height='116.4%' ><g transform='scale(1.34)'\"\n\t\t\t\t\t\" rx='5%' ry='5%' ><rect x='11%' y='11.2%' width='63.6%' height='63.8%\"\n\t\t\t\t: \"-18%' y='-18%' width='117.8%' height='117.8%' ><g transform='scale(1.34)'\"\n\t\t\t\t\t\" rx='5%' ry='5%' ><rect x='11.6%' y='11.6%' width='63.0%' height='63.2%\",\n\t\t\t\"' fill='url(#smallGrid)' stroke='none'  rx='3%' ry='3%' /><g transform='rotate(45 \",\n\t\t\tscaledGridSizeString,\n\t\t\t\" \",\n\t\t\tscaledGridSizeString,\n\t\t\t\")'>\",\n\t\t\t_generateLandmarkSvg(_gridSize, _landmarkTypeId), // Generate LandMark SVG\n\t\t\t_generateSites(_sites), // Generate Sites SVG\n\t\t\t\"</g></g></svg>\",\n\t\t\t\"<rect xmlns='http://www.w3.org/2000/svg' x='0.3' y='0.3'\", \n\t\t\t\" width='99.7%' height='99.7%' fill='none' stroke='url(#ROUNDED_BORDER_TIER_\",\n\t\t\tuint256(_tierId).toString(),\n\t\t\t\")' stroke-width='1' rx='4.5%' ry='4.5%'/></svg>\"\n\t\t];\n\t}\n\n\t/**\n\t* @dev Return the concatenated Land Board SVG string\n\t*\n\t* @param _gridSize The size of the grid\n\t* @param _tierId PlotView.tierId land tier id\n\t* @param _landmarkTypeId landmark type id\n\t* @param _sites array of LandLib.Site\n\t* @return Land Board SVG string\n\t*/\n\tfunction _generateLandBoard(\n\t\tuint16 _gridSize, \n\t\tuint8 _tierId, \n\t\tuint8 _landmarkTypeId, \n\t\tLandLib.Site[] memory _sites\n\t) private pure returns(string memory) {\n\t\tstring[170] memory landBoardArray_ = _landBoardArray(\n\t\t\t_gridSize, \n\t\t\t_tierId, \n\t\t\t_landmarkTypeId, \n\t\t\t_sites\n\t\t);\n\t\tbytes memory landBoardBytes;\n\t\tfor (uint8 i = 0; i < landBoardArray_.length; i++) {\n\t\t\tlandBoardBytes = abi.encodePacked(landBoardBytes, landBoardArray_[i]);\n\t\t}\n\n\t\treturn string(landBoardBytes);\n\t}\n\n\t/**\n\t * @dev Calculates string for the land name based on plot data.\n\t *\n\t * @param _regionId PlotView.regionId\n\t * @param _x PlotView.x coordinate\n\t * @param _y PlotView.y coordinate\n\t * @return SVG name attribute\n\t */\n\tfunction generateLandName(uint8 _regionId, uint16 _x, uint16 _y) internal pure returns (string memory) {\n\t\tstring memory region;\n\t\tif (_regionId == 1) {\n\t\t\tregion = \"Taiga Boreal\";\n\t\t} else if (_regionId == 2) {\n\t\t\tregion = \"Crystal Shores\";\n\t\t} else if (_regionId == 3) {\n\t\t\tregion = \"Shardbluff Labyrinth\";\n\t\t} else if (_regionId == 4) {\n\t\t\tregion = \"Abyssal Basin\";\n\t\t} else if (_regionId == 5) {\n\t\t\tregion = \"Crimson Waste\";\n\t\t} else if (_regionId == 6) {\n\t\t\tregion = \"Brightland Steppes\";\n\t\t} else if (_regionId == 7) {\n\t\t\tregion = \"Halcyon Sea\";\n\t\t} else {\n\t\t\trevert(\"Invalid region ID\");\n\t\t}\n\t\treturn string(\n\t\t\tabi.encodePacked(\n\t\t\t\tregion,\n\t\t\t\t\" (\",\n\t\t\t\tuint256(_x).toString(),\n\t\t\t\t\", \",\n\t\t\t\tuint256(_y).toString(),\n\t\t\t\t\")\"\n\t\t\t)\n\t\t);\n\t}\n\n\t/**\n\t * @dev Returns the string for the land metadata description.\n\t */\n\tfunction generateLandDescription() internal pure returns (string memory) {\n\t\treturn \"Illuvium Land is a digital piece of real estate in the Illuvium universe that players can mine for fuels through Illuvium Zero. \"\n\t\t\t\"Fuels are ERC-20 tokens that are used in Illuvium games and can be traded on the marketplace. Higher-tiered lands produce more fuel.\"\n\t\t\t\"\\\\n\\\\nLearn more about Illuvium Land at illuvidex.illuvium.io/land.\";\n\t}\n\n\t/**\n\t * @dev Generates each site inside the land svg board with is position and color.\n\t *\n\t * @param _sites Array of plot sites coming from PlotView struct\n\t * @return The sites components for the land SVG\n\t */\n\tfunction _generateSites(LandLib.Site[] memory _sites) private pure returns (string memory) {\n\t\tbytes memory _siteSvgBytes;\n\t\tfor (uint256 i = 0; i < _sites.length; i++) {\n\t\t\t_siteSvgBytes = abi.encodePacked(\n\t\t\t\t_siteSvgBytes,\n\t\t\t\t_siteBaseSvg(\n\t\t\t\t\tconvertToSvgPositionX(_sites[i].x),\n\t\t\t\t\tconvertToSvgPositionY(_sites[i].y),\n\t\t\t\t\t_sites[i].typeId\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\treturn string(_siteSvgBytes);\n\t}\n\n\t/**\n\t * @dev Main function, entry point to generate the complete land svg with all\n\t *      populated sites, correct color, and attach to the JSON metadata file\n\t *      created using Base64 lib.\n\t * @dev Returns the JSON metadata formatted file used by NFT platforms to display\n\t *      the land data.\n\t * @dev Can be updated in the future to change the way land name, description, image\n\t *      and other traits are displayed.\n\t *\n\t * @param _regionId PlotView.regionId\n\t * @param _x PlotView.x coordinate\n\t * @param _y PlotView.y coordinate\n\t * @param _tierId PlotView.tierId land tier id\n\t * @param _gridSize The size of the grid\n\t * @param _landmarkTypeId landmark type defined by its ID\n\t * @param _sites Array of plot sites coming from PlotView struct\n\t */\n\tfunction constructTokenURI(\n\t\tuint8 _regionId,\n\t\tuint16 _x,\n\t\tuint16 _y,\n\t\tuint8 _tierId,\n\t\tuint16 _gridSize,\n\t\tuint8 _landmarkTypeId,\n\t\tLandLib.Site[] memory _sites\n\t) internal pure returns (string memory) {\n\t\tstring memory name = generateLandName(_regionId, _x, _y);\n\t\tstring memory description = generateLandDescription();\n\t\tstring memory image = Base64.encode(\n\t\t\tbytes(\n\t\t\t\t_generateSVGImage(\n\t\t\t\t\t_gridSize, \n\t\t\t\t\t_tierId,\n\t\t\t\t\t_landmarkTypeId,\n\t\t\t\t\t_sites\n\t\t\t\t)\n\t\t\t)\n\t\t);\n\n\t\treturn string(\n\t\t\tabi.encodePacked(\"data:application/json;base64, \", Base64.encode(\n\t\t\t\tbytes(\n\t\t\t\t\tabi.encodePacked('{\"name\":\"',\n\t\t\t\t\tname,\n\t\t\t\t\t'\", \"description\":\"',\n\t\t\t\t\tdescription,\n\t\t\t\t\t'\", \"image\": \"',\n\t\t\t\t\t'data:image/svg+xml;base64,',\n\t\t\t\t\timage,\n\t\t\t\t\t'\"}')\n\t\t\t\t)\n\t\t\t)\n\t\t\t)\n\t\t);\n\t}\n\n\t/**\n\t * @dev Convert site X position to fit into the board.\n\t *\n\t * @param _positionX X coordinate of the site\n\t * @return Transformed X coordinate\n\t */\n\tfunction convertToSvgPositionX(uint16 _positionX) private pure returns (uint16) {\n\t\treturn _positionX * 3;\n\t}\n\n\t/**\n\t * @dev Convert site Y position to fit into the board.\n\t *\n\t * @param _positionY Y coordinate of the site\n\t * @return Transformed Y coordinate\n\t */\n\tfunction convertToSvgPositionY(uint16 _positionY) private pure returns (uint16) {\n\t\treturn _positionY * 3;\n\t}\n}\n"
    },
    "contracts/token/LandDescriptorImpl.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/LandERC721Spec.sol\";\nimport \"../lib/LandSvgLib.sol\";\n\n/**\n * @title Land Descriptor Implementation\n *\n * @notice Basic implementation of the LandDescriptor interface\n *\n * @author Pedro Bergamini, Basil Gorin\n */\ncontract LandDescriptorImpl is LandDescriptor {\n\t/**\n\t * @inheritdoc LandDescriptor\n\t */\n\tfunction tokenURI(uint256 _tokenId) public view virtual override returns (string memory) {\n\t\t// assuming the function was called by the LandERC721 contract itself,\n\t\t// fetch the token metadata from it\n\t\tLandLib.PlotView memory _plot = LandERC721Metadata(msg.sender).viewMetadata(_tokenId);\n\n\t\t// unpack the `_plot` structure and delegate generation into the lib\n\t\treturn LandSvgLib.constructTokenURI(\n\t\t\t_plot.regionId,\n\t\t\t_plot.x,\n\t\t\t_plot.y,\n\t\t\t_plot.tierId,\n\t\t\t_plot.size,\n\t\t\t_plot.landmarkTypeId,\n\t\t\t_plot.sites\n\t\t);\n\t}\n}\n"
    },
    "prb-math/contracts/PRBMath.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.4;\n\n/// @notice Emitted when the result overflows uint256.\nerror PRBMath__MulDivFixedPointOverflow(uint256 prod1);\n\n/// @notice Emitted when the result overflows uint256.\nerror PRBMath__MulDivOverflow(uint256 prod1, uint256 denominator);\n\n/// @notice Emitted when one of the inputs is type(int256).min.\nerror PRBMath__MulDivSignedInputTooSmall();\n\n/// @notice Emitted when the intermediary absolute result overflows int256.\nerror PRBMath__MulDivSignedOverflow(uint256 rAbs);\n\n/// @notice Emitted when the input is MIN_SD59x18.\nerror PRBMathSD59x18__AbsInputTooSmall();\n\n/// @notice Emitted when ceiling a number overflows SD59x18.\nerror PRBMathSD59x18__CeilOverflow(int256 x);\n\n/// @notice Emitted when one of the inputs is MIN_SD59x18.\nerror PRBMathSD59x18__DivInputTooSmall();\n\n/// @notice Emitted when one of the intermediary unsigned results overflows SD59x18.\nerror PRBMathSD59x18__DivOverflow(uint256 rAbs);\n\n/// @notice Emitted when the input is greater than 133.084258667509499441.\nerror PRBMathSD59x18__ExpInputTooBig(int256 x);\n\n/// @notice Emitted when the input is greater than 192.\nerror PRBMathSD59x18__Exp2InputTooBig(int256 x);\n\n/// @notice Emitted when flooring a number underflows SD59x18.\nerror PRBMathSD59x18__FloorUnderflow(int256 x);\n\n/// @notice Emitted when converting a basic integer to the fixed-point format overflows SD59x18.\nerror PRBMathSD59x18__FromIntOverflow(int256 x);\n\n/// @notice Emitted when converting a basic integer to the fixed-point format underflows SD59x18.\nerror PRBMathSD59x18__FromIntUnderflow(int256 x);\n\n/// @notice Emitted when the product of the inputs is negative.\nerror PRBMathSD59x18__GmNegativeProduct(int256 x, int256 y);\n\n/// @notice Emitted when multiplying the inputs overflows SD59x18.\nerror PRBMathSD59x18__GmOverflow(int256 x, int256 y);\n\n/// @notice Emitted when the input is less than or equal to zero.\nerror PRBMathSD59x18__LogInputTooSmall(int256 x);\n\n/// @notice Emitted when one of the inputs is MIN_SD59x18.\nerror PRBMathSD59x18__MulInputTooSmall();\n\n/// @notice Emitted when the intermediary absolute result overflows SD59x18.\nerror PRBMathSD59x18__MulOverflow(uint256 rAbs);\n\n/// @notice Emitted when the intermediary absolute result overflows SD59x18.\nerror PRBMathSD59x18__PowuOverflow(uint256 rAbs);\n\n/// @notice Emitted when the input is negative.\nerror PRBMathSD59x18__SqrtNegativeInput(int256 x);\n\n/// @notice Emitted when the calculating the square root overflows SD59x18.\nerror PRBMathSD59x18__SqrtOverflow(int256 x);\n\n/// @notice Emitted when addition overflows UD60x18.\nerror PRBMathUD60x18__AddOverflow(uint256 x, uint256 y);\n\n/// @notice Emitted when ceiling a number overflows UD60x18.\nerror PRBMathUD60x18__CeilOverflow(uint256 x);\n\n/// @notice Emitted when the input is greater than 133.084258667509499441.\nerror PRBMathUD60x18__ExpInputTooBig(uint256 x);\n\n/// @notice Emitted when the input is greater than 192.\nerror PRBMathUD60x18__Exp2InputTooBig(uint256 x);\n\n/// @notice Emitted when converting a basic integer to the fixed-point format format overflows UD60x18.\nerror PRBMathUD60x18__FromUintOverflow(uint256 x);\n\n/// @notice Emitted when multiplying the inputs overflows UD60x18.\nerror PRBMathUD60x18__GmOverflow(uint256 x, uint256 y);\n\n/// @notice Emitted when the input is less than 1.\nerror PRBMathUD60x18__LogInputTooSmall(uint256 x);\n\n/// @notice Emitted when the calculating the square root overflows UD60x18.\nerror PRBMathUD60x18__SqrtOverflow(uint256 x);\n\n/// @notice Emitted when subtraction underflows UD60x18.\nerror PRBMathUD60x18__SubUnderflow(uint256 x, uint256 y);\n\n/// @dev Common mathematical functions used in both PRBMathSD59x18 and PRBMathUD60x18. Note that this shared library\n/// does not always assume the signed 59.18-decimal fixed-point or the unsigned 60.18-decimal fixed-point\n/// representation. When it does not, it is explicitly mentioned in the NatSpec documentation.\nlibrary PRBMath {\n    /// STRUCTS ///\n\n    struct SD59x18 {\n        int256 value;\n    }\n\n    struct UD60x18 {\n        uint256 value;\n    }\n\n    /// STORAGE ///\n\n    /// @dev How many trailing decimals can be represented.\n    uint256 internal constant SCALE = 1e18;\n\n    /// @dev Largest power of two divisor of SCALE.\n    uint256 internal constant SCALE_LPOTD = 262144;\n\n    /// @dev SCALE inverted mod 2^256.\n    uint256 internal constant SCALE_INVERSE =\n        78156646155174841979727994598816262306175212592076161876661_508869554232690281;\n\n    /// FUNCTIONS ///\n\n    /// @notice Calculates the binary exponent of x using the binary fraction method.\n    /// @dev Has to use 192.64-bit fixed-point numbers.\n    /// See https://ethereum.stackexchange.com/a/96594/24693.\n    /// @param x The exponent as an unsigned 192.64-bit fixed-point number.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function exp2(uint256 x) internal pure returns (uint256 result) {\n        unchecked {\n            // Start from 0.5 in the 192.64-bit fixed-point format.\n            result = 0x800000000000000000000000000000000000000000000000;\n\n            // Multiply the result by root(2, 2^-i) when the bit at position i is 1. None of the intermediary results overflows\n            // because the initial result is 2^191 and all magic factors are less than 2^65.\n            if (x & 0x8000000000000000 > 0) {\n                result = (result * 0x16A09E667F3BCC909) >> 64;\n            }\n            if (x & 0x4000000000000000 > 0) {\n                result = (result * 0x1306FE0A31B7152DF) >> 64;\n            }\n            if (x & 0x2000000000000000 > 0) {\n                result = (result * 0x1172B83C7D517ADCE) >> 64;\n            }\n            if (x & 0x1000000000000000 > 0) {\n                result = (result * 0x10B5586CF9890F62A) >> 64;\n            }\n            if (x & 0x800000000000000 > 0) {\n                result = (result * 0x1059B0D31585743AE) >> 64;\n            }\n            if (x & 0x400000000000000 > 0) {\n                result = (result * 0x102C9A3E778060EE7) >> 64;\n            }\n            if (x & 0x200000000000000 > 0) {\n                result = (result * 0x10163DA9FB33356D8) >> 64;\n            }\n            if (x & 0x100000000000000 > 0) {\n                result = (result * 0x100B1AFA5ABCBED61) >> 64;\n            }\n            if (x & 0x80000000000000 > 0) {\n                result = (result * 0x10058C86DA1C09EA2) >> 64;\n            }\n            if (x & 0x40000000000000 > 0) {\n                result = (result * 0x1002C605E2E8CEC50) >> 64;\n            }\n            if (x & 0x20000000000000 > 0) {\n                result = (result * 0x100162F3904051FA1) >> 64;\n            }\n            if (x & 0x10000000000000 > 0) {\n                result = (result * 0x1000B175EFFDC76BA) >> 64;\n            }\n            if (x & 0x8000000000000 > 0) {\n                result = (result * 0x100058BA01FB9F96D) >> 64;\n            }\n            if (x & 0x4000000000000 > 0) {\n                result = (result * 0x10002C5CC37DA9492) >> 64;\n            }\n            if (x & 0x2000000000000 > 0) {\n                result = (result * 0x1000162E525EE0547) >> 64;\n            }\n            if (x & 0x1000000000000 > 0) {\n                result = (result * 0x10000B17255775C04) >> 64;\n            }\n            if (x & 0x800000000000 > 0) {\n                result = (result * 0x1000058B91B5BC9AE) >> 64;\n            }\n            if (x & 0x400000000000 > 0) {\n                result = (result * 0x100002C5C89D5EC6D) >> 64;\n            }\n            if (x & 0x200000000000 > 0) {\n                result = (result * 0x10000162E43F4F831) >> 64;\n            }\n            if (x & 0x100000000000 > 0) {\n                result = (result * 0x100000B1721BCFC9A) >> 64;\n            }\n            if (x & 0x80000000000 > 0) {\n                result = (result * 0x10000058B90CF1E6E) >> 64;\n            }\n            if (x & 0x40000000000 > 0) {\n                result = (result * 0x1000002C5C863B73F) >> 64;\n            }\n            if (x & 0x20000000000 > 0) {\n                result = (result * 0x100000162E430E5A2) >> 64;\n            }\n            if (x & 0x10000000000 > 0) {\n                result = (result * 0x1000000B172183551) >> 64;\n            }\n            if (x & 0x8000000000 > 0) {\n                result = (result * 0x100000058B90C0B49) >> 64;\n            }\n            if (x & 0x4000000000 > 0) {\n                result = (result * 0x10000002C5C8601CC) >> 64;\n            }\n            if (x & 0x2000000000 > 0) {\n                result = (result * 0x1000000162E42FFF0) >> 64;\n            }\n            if (x & 0x1000000000 > 0) {\n                result = (result * 0x10000000B17217FBB) >> 64;\n            }\n            if (x & 0x800000000 > 0) {\n                result = (result * 0x1000000058B90BFCE) >> 64;\n            }\n            if (x & 0x400000000 > 0) {\n                result = (result * 0x100000002C5C85FE3) >> 64;\n            }\n            if (x & 0x200000000 > 0) {\n                result = (result * 0x10000000162E42FF1) >> 64;\n            }\n            if (x & 0x100000000 > 0) {\n                result = (result * 0x100000000B17217F8) >> 64;\n            }\n            if (x & 0x80000000 > 0) {\n                result = (result * 0x10000000058B90BFC) >> 64;\n            }\n            if (x & 0x40000000 > 0) {\n                result = (result * 0x1000000002C5C85FE) >> 64;\n            }\n            if (x & 0x20000000 > 0) {\n                result = (result * 0x100000000162E42FF) >> 64;\n            }\n            if (x & 0x10000000 > 0) {\n                result = (result * 0x1000000000B17217F) >> 64;\n            }\n            if (x & 0x8000000 > 0) {\n                result = (result * 0x100000000058B90C0) >> 64;\n            }\n            if (x & 0x4000000 > 0) {\n                result = (result * 0x10000000002C5C860) >> 64;\n            }\n            if (x & 0x2000000 > 0) {\n                result = (result * 0x1000000000162E430) >> 64;\n            }\n            if (x & 0x1000000 > 0) {\n                result = (result * 0x10000000000B17218) >> 64;\n            }\n            if (x & 0x800000 > 0) {\n                result = (result * 0x1000000000058B90C) >> 64;\n            }\n            if (x & 0x400000 > 0) {\n                result = (result * 0x100000000002C5C86) >> 64;\n            }\n            if (x & 0x200000 > 0) {\n                result = (result * 0x10000000000162E43) >> 64;\n            }\n            if (x & 0x100000 > 0) {\n                result = (result * 0x100000000000B1721) >> 64;\n            }\n            if (x & 0x80000 > 0) {\n                result = (result * 0x10000000000058B91) >> 64;\n            }\n            if (x & 0x40000 > 0) {\n                result = (result * 0x1000000000002C5C8) >> 64;\n            }\n            if (x & 0x20000 > 0) {\n                result = (result * 0x100000000000162E4) >> 64;\n            }\n            if (x & 0x10000 > 0) {\n                result = (result * 0x1000000000000B172) >> 64;\n            }\n            if (x & 0x8000 > 0) {\n                result = (result * 0x100000000000058B9) >> 64;\n            }\n            if (x & 0x4000 > 0) {\n                result = (result * 0x10000000000002C5D) >> 64;\n            }\n            if (x & 0x2000 > 0) {\n                result = (result * 0x1000000000000162E) >> 64;\n            }\n            if (x & 0x1000 > 0) {\n                result = (result * 0x10000000000000B17) >> 64;\n            }\n            if (x & 0x800 > 0) {\n                result = (result * 0x1000000000000058C) >> 64;\n            }\n            if (x & 0x400 > 0) {\n                result = (result * 0x100000000000002C6) >> 64;\n            }\n            if (x & 0x200 > 0) {\n                result = (result * 0x10000000000000163) >> 64;\n            }\n            if (x & 0x100 > 0) {\n                result = (result * 0x100000000000000B1) >> 64;\n            }\n            if (x & 0x80 > 0) {\n                result = (result * 0x10000000000000059) >> 64;\n            }\n            if (x & 0x40 > 0) {\n                result = (result * 0x1000000000000002C) >> 64;\n            }\n            if (x & 0x20 > 0) {\n                result = (result * 0x10000000000000016) >> 64;\n            }\n            if (x & 0x10 > 0) {\n                result = (result * 0x1000000000000000B) >> 64;\n            }\n            if (x & 0x8 > 0) {\n                result = (result * 0x10000000000000006) >> 64;\n            }\n            if (x & 0x4 > 0) {\n                result = (result * 0x10000000000000003) >> 64;\n            }\n            if (x & 0x2 > 0) {\n                result = (result * 0x10000000000000001) >> 64;\n            }\n            if (x & 0x1 > 0) {\n                result = (result * 0x10000000000000001) >> 64;\n            }\n\n            // We're doing two things at the same time:\n            //\n            //   1. Multiply the result by 2^n + 1, where \"2^n\" is the integer part and the one is added to account for\n            //      the fact that we initially set the result to 0.5. This is accomplished by subtracting from 191\n            //      rather than 192.\n            //   2. Convert the result to the unsigned 60.18-decimal fixed-point format.\n            //\n            // This works because 2^(191-ip) = 2^ip / 2^191, where \"ip\" is the integer part \"2^n\".\n            result *= SCALE;\n            result >>= (191 - (x >> 64));\n        }\n    }\n\n    /// @notice Finds the zero-based index of the first one in the binary representation of x.\n    /// @dev See the note on msb in the \"Find First Set\" Wikipedia article https://en.wikipedia.org/wiki/Find_first_set\n    /// @param x The uint256 number for which to find the index of the most significant bit.\n    /// @return msb The index of the most significant bit as an uint256.\n    function mostSignificantBit(uint256 x) internal pure returns (uint256 msb) {\n        if (x >= 2**128) {\n            x >>= 128;\n            msb += 128;\n        }\n        if (x >= 2**64) {\n            x >>= 64;\n            msb += 64;\n        }\n        if (x >= 2**32) {\n            x >>= 32;\n            msb += 32;\n        }\n        if (x >= 2**16) {\n            x >>= 16;\n            msb += 16;\n        }\n        if (x >= 2**8) {\n            x >>= 8;\n            msb += 8;\n        }\n        if (x >= 2**4) {\n            x >>= 4;\n            msb += 4;\n        }\n        if (x >= 2**2) {\n            x >>= 2;\n            msb += 2;\n        }\n        if (x >= 2**1) {\n            // No need to shift x any more.\n            msb += 1;\n        }\n    }\n\n    /// @notice Calculates floor(x*ydenominator) with full precision.\n    ///\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv.\n    ///\n    /// Requirements:\n    /// - The denominator cannot be zero.\n    /// - The result must fit within uint256.\n    ///\n    /// Caveats:\n    /// - This function does not work with fixed-point numbers.\n    ///\n    /// @param x The multiplicand as an uint256.\n    /// @param y The multiplier as an uint256.\n    /// @param denominator The divisor as an uint256.\n    /// @return result The result as an uint256.\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n        // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n        // variables such that product = prod1 * 2^256 + prod0.\n        uint256 prod0; // Least significant 256 bits of the product\n        uint256 prod1; // Most significant 256 bits of the product\n        assembly {\n            let mm := mulmod(x, y, not(0))\n            prod0 := mul(x, y)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n\n        // Handle non-overflow cases, 256 by 256 division.\n        if (prod1 == 0) {\n            unchecked {\n                result = prod0 / denominator;\n            }\n            return result;\n        }\n\n        // Make sure the result is less than 2^256. Also prevents denominator == 0.\n        if (prod1 >= denominator) {\n            revert PRBMath__MulDivOverflow(prod1, denominator);\n        }\n\n        ///////////////////////////////////////////////\n        // 512 by 256 division.\n        ///////////////////////////////////////////////\n\n        // Make division exact by subtracting the remainder from [prod1 prod0].\n        uint256 remainder;\n        assembly {\n            // Compute remainder using mulmod.\n            remainder := mulmod(x, y, denominator)\n\n            // Subtract 256 bit number from 512 bit number.\n            prod1 := sub(prod1, gt(remainder, prod0))\n            prod0 := sub(prod0, remainder)\n        }\n\n        // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n        // See https://cs.stackexchange.com/q/138556/92363.\n        unchecked {\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 lpotdod = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by lpotdod.\n                denominator := div(denominator, lpotdod)\n\n                // Divide [prod1 prod0] by lpotdod.\n                prod0 := div(prod0, lpotdod)\n\n                // Flip lpotdod such that it is 2^256 / lpotdod. If lpotdod is zero, then it becomes one.\n                lpotdod := add(div(sub(0, lpotdod), lpotdod), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * lpotdod;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /// @notice Calculates floor(x*y1e18) with full precision.\n    ///\n    /// @dev Variant of \"mulDiv\" with constant folding, i.e. in which the denominator is always 1e18. Before returning the\n    /// final result, we add 1 if (x * y) % SCALE >= HALF_SCALE. Without this, 6.6e-19 would be truncated to 0 instead of\n    /// being rounded to 1e-18.  See \"Listing 6\" and text above it at https://accu.org/index.php/journals/1717.\n    ///\n    /// Requirements:\n    /// - The result must fit within uint256.\n    ///\n    /// Caveats:\n    /// - The body is purposely left uncommented; see the NatSpec comments in \"PRBMath.mulDiv\" to understand how this works.\n    /// - It is assumed that the result can never be type(uint256).max when x and y solve the following two equations:\n    ///     1. x * y = type(uint256).max * SCALE\n    ///     2. (x * y) % SCALE >= SCALE / 2\n    ///\n    /// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function mulDivFixedPoint(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        uint256 prod0;\n        uint256 prod1;\n        assembly {\n            let mm := mulmod(x, y, not(0))\n            prod0 := mul(x, y)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n\n        if (prod1 >= SCALE) {\n            revert PRBMath__MulDivFixedPointOverflow(prod1);\n        }\n\n        uint256 remainder;\n        uint256 roundUpUnit;\n        assembly {\n            remainder := mulmod(x, y, SCALE)\n            roundUpUnit := gt(remainder, 499999999999999999)\n        }\n\n        if (prod1 == 0) {\n            unchecked {\n                result = (prod0 / SCALE) + roundUpUnit;\n                return result;\n            }\n        }\n\n        assembly {\n            result := add(\n                mul(\n                    or(\n                        div(sub(prod0, remainder), SCALE_LPOTD),\n                        mul(sub(prod1, gt(remainder, prod0)), add(div(sub(0, SCALE_LPOTD), SCALE_LPOTD), 1))\n                    ),\n                    SCALE_INVERSE\n                ),\n                roundUpUnit\n            )\n        }\n    }\n\n    /// @notice Calculates floor(x*ydenominator) with full precision.\n    ///\n    /// @dev An extension of \"mulDiv\" for signed numbers. Works by computing the signs and the absolute values separately.\n    ///\n    /// Requirements:\n    /// - None of the inputs can be type(int256).min.\n    /// - The result must fit within int256.\n    ///\n    /// @param x The multiplicand as an int256.\n    /// @param y The multiplier as an int256.\n    /// @param denominator The divisor as an int256.\n    /// @return result The result as an int256.\n    function mulDivSigned(\n        int256 x,\n        int256 y,\n        int256 denominator\n    ) internal pure returns (int256 result) {\n        if (x == type(int256).min || y == type(int256).min || denominator == type(int256).min) {\n            revert PRBMath__MulDivSignedInputTooSmall();\n        }\n\n        // Get hold of the absolute values of x, y and the denominator.\n        uint256 ax;\n        uint256 ay;\n        uint256 ad;\n        unchecked {\n            ax = x < 0 ? uint256(-x) : uint256(x);\n            ay = y < 0 ? uint256(-y) : uint256(y);\n            ad = denominator < 0 ? uint256(-denominator) : uint256(denominator);\n        }\n\n        // Compute the absolute value of (x*y)denominator. The result must fit within int256.\n        uint256 rAbs = mulDiv(ax, ay, ad);\n        if (rAbs > uint256(type(int256).max)) {\n            revert PRBMath__MulDivSignedOverflow(rAbs);\n        }\n\n        // Get the signs of x, y and the denominator.\n        uint256 sx;\n        uint256 sy;\n        uint256 sd;\n        assembly {\n            sx := sgt(x, sub(0, 1))\n            sy := sgt(y, sub(0, 1))\n            sd := sgt(denominator, sub(0, 1))\n        }\n\n        // XOR over sx, sy and sd. This is checking whether there are one or three negative signs in the inputs.\n        // If yes, the result should be negative.\n        result = sx ^ sy ^ sd == 0 ? -int256(rAbs) : int256(rAbs);\n    }\n\n    /// @notice Calculates the square root of x, rounding down.\n    /// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\n    ///\n    /// Caveats:\n    /// - This function does not work with fixed-point numbers.\n    ///\n    /// @param x The uint256 number for which to calculate the square root.\n    /// @return result The result as an uint256.\n    function sqrt(uint256 x) internal pure returns (uint256 result) {\n        if (x == 0) {\n            return 0;\n        }\n\n        // Set the initial guess to the least power of two that is greater than or equal to sqrt(x).\n        uint256 xAux = uint256(x);\n        result = 1;\n        if (xAux >= 0x100000000000000000000000000000000) {\n            xAux >>= 128;\n            result <<= 64;\n        }\n        if (xAux >= 0x10000000000000000) {\n            xAux >>= 64;\n            result <<= 32;\n        }\n        if (xAux >= 0x100000000) {\n            xAux >>= 32;\n            result <<= 16;\n        }\n        if (xAux >= 0x10000) {\n            xAux >>= 16;\n            result <<= 8;\n        }\n        if (xAux >= 0x100) {\n            xAux >>= 8;\n            result <<= 4;\n        }\n        if (xAux >= 0x10) {\n            xAux >>= 4;\n            result <<= 2;\n        }\n        if (xAux >= 0x8) {\n            result <<= 1;\n        }\n\n        // The operations can never overflow because the result is max 2^127 when it enters this block.\n        unchecked {\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1; // Seven iterations should be enough\n            uint256 roundedDownResult = x / result;\n            return result >= roundedDownResult ? roundedDownResult : result;\n        }\n    }\n}\n"
    },
    "prb-math/contracts/PRBMathUD60x18.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.4;\n\nimport \"./PRBMath.sol\";\n\n/// @title PRBMathUD60x18\n/// @author Paul Razvan Berg\n/// @notice Smart contract library for advanced fixed-point math that works with uint256 numbers considered to have 18\n/// trailing decimals. We call this number representation unsigned 60.18-decimal fixed-point, since there can be up to 60\n/// digits in the integer part and up to 18 decimals in the fractional part. The numbers are bound by the minimum and the\n/// maximum values permitted by the Solidity type uint256.\nlibrary PRBMathUD60x18 {\n    /// @dev Half the SCALE number.\n    uint256 internal constant HALF_SCALE = 5e17;\n\n    /// @dev log2(e) as an unsigned 60.18-decimal fixed-point number.\n    uint256 internal constant LOG2_E = 1_442695040888963407;\n\n    /// @dev The maximum value an unsigned 60.18-decimal fixed-point number can have.\n    uint256 internal constant MAX_UD60x18 =\n        115792089237316195423570985008687907853269984665640564039457_584007913129639935;\n\n    /// @dev The maximum whole value an unsigned 60.18-decimal fixed-point number can have.\n    uint256 internal constant MAX_WHOLE_UD60x18 =\n        115792089237316195423570985008687907853269984665640564039457_000000000000000000;\n\n    /// @dev How many trailing decimals can be represented.\n    uint256 internal constant SCALE = 1e18;\n\n    /// @notice Calculates the arithmetic average of x and y, rounding down.\n    /// @param x The first operand as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The second operand as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The arithmetic average as an unsigned 60.18-decimal fixed-point number.\n    function avg(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        // The operations can never overflow.\n        unchecked {\n            // The last operand checks if both x and y are odd and if that is the case, we add 1 to the result. We need\n            // to do this because if both numbers are odd, the 0.5 remainder gets truncated twice.\n            result = (x >> 1) + (y >> 1) + (x & y & 1);\n        }\n    }\n\n    /// @notice Yields the least unsigned 60.18 decimal fixed-point number greater than or equal to x.\n    ///\n    /// @dev Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.\n    /// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\n    ///\n    /// Requirements:\n    /// - x must be less than or equal to MAX_WHOLE_UD60x18.\n    ///\n    /// @param x The unsigned 60.18-decimal fixed-point number to ceil.\n    /// @param result The least integer greater than or equal to x, as an unsigned 60.18-decimal fixed-point number.\n    function ceil(uint256 x) internal pure returns (uint256 result) {\n        if (x > MAX_WHOLE_UD60x18) {\n            revert PRBMathUD60x18__CeilOverflow(x);\n        }\n        assembly {\n            // Equivalent to \"x % SCALE\" but faster.\n            let remainder := mod(x, SCALE)\n\n            // Equivalent to \"SCALE - remainder\" but faster.\n            let delta := sub(SCALE, remainder)\n\n            // Equivalent to \"x + delta * (remainder > 0 ? 1 : 0)\" but faster.\n            result := add(x, mul(delta, gt(remainder, 0)))\n        }\n    }\n\n    /// @notice Divides two unsigned 60.18-decimal fixed-point numbers, returning a new unsigned 60.18-decimal fixed-point number.\n    ///\n    /// @dev Uses mulDiv to enable overflow-safe multiplication and division.\n    ///\n    /// Requirements:\n    /// - The denominator cannot be zero.\n    ///\n    /// @param x The numerator as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The denominator as an unsigned 60.18-decimal fixed-point number.\n    /// @param result The quotient as an unsigned 60.18-decimal fixed-point number.\n    function div(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        result = PRBMath.mulDiv(x, SCALE, y);\n    }\n\n    /// @notice Returns Euler's number as an unsigned 60.18-decimal fixed-point number.\n    /// @dev See https://en.wikipedia.org/wiki/E_(mathematical_constant).\n    function e() internal pure returns (uint256 result) {\n        result = 2_718281828459045235;\n    }\n\n    /// @notice Calculates the natural exponent of x.\n    ///\n    /// @dev Based on the insight that e^x = 2^(x * log2(e)).\n    ///\n    /// Requirements:\n    /// - All from \"log2\".\n    /// - x must be less than 133.084258667509499441.\n    ///\n    /// @param x The exponent as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function exp(uint256 x) internal pure returns (uint256 result) {\n        // Without this check, the value passed to \"exp2\" would be greater than 192.\n        if (x >= 133_084258667509499441) {\n            revert PRBMathUD60x18__ExpInputTooBig(x);\n        }\n\n        // Do the fixed-point multiplication inline to save gas.\n        unchecked {\n            uint256 doubleScaleProduct = x * LOG2_E;\n            result = exp2((doubleScaleProduct + HALF_SCALE) / SCALE);\n        }\n    }\n\n    /// @notice Calculates the binary exponent of x using the binary fraction method.\n    ///\n    /// @dev See https://ethereum.stackexchange.com/q/79903/24693.\n    ///\n    /// Requirements:\n    /// - x must be 192 or less.\n    /// - The result must fit within MAX_UD60x18.\n    ///\n    /// @param x The exponent as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function exp2(uint256 x) internal pure returns (uint256 result) {\n        // 2^192 doesn't fit within the 192.64-bit format used internally in this function.\n        if (x >= 192e18) {\n            revert PRBMathUD60x18__Exp2InputTooBig(x);\n        }\n\n        unchecked {\n            // Convert x to the 192.64-bit fixed-point format.\n            uint256 x192x64 = (x << 64) / SCALE;\n\n            // Pass x to the PRBMath.exp2 function, which uses the 192.64-bit fixed-point number representation.\n            result = PRBMath.exp2(x192x64);\n        }\n    }\n\n    /// @notice Yields the greatest unsigned 60.18 decimal fixed-point number less than or equal to x.\n    /// @dev Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.\n    /// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\n    /// @param x The unsigned 60.18-decimal fixed-point number to floor.\n    /// @param result The greatest integer less than or equal to x, as an unsigned 60.18-decimal fixed-point number.\n    function floor(uint256 x) internal pure returns (uint256 result) {\n        assembly {\n            // Equivalent to \"x % SCALE\" but faster.\n            let remainder := mod(x, SCALE)\n\n            // Equivalent to \"x - remainder * (remainder > 0 ? 1 : 0)\" but faster.\n            result := sub(x, mul(remainder, gt(remainder, 0)))\n        }\n    }\n\n    /// @notice Yields the excess beyond the floor of x.\n    /// @dev Based on the odd function definition https://en.wikipedia.org/wiki/Fractional_part.\n    /// @param x The unsigned 60.18-decimal fixed-point number to get the fractional part of.\n    /// @param result The fractional part of x as an unsigned 60.18-decimal fixed-point number.\n    function frac(uint256 x) internal pure returns (uint256 result) {\n        assembly {\n            result := mod(x, SCALE)\n        }\n    }\n\n    /// @notice Converts a number from basic integer form to unsigned 60.18-decimal fixed-point representation.\n    ///\n    /// @dev Requirements:\n    /// - x must be less than or equal to MAX_UD60x18 divided by SCALE.\n    ///\n    /// @param x The basic integer to convert.\n    /// @param result The same number in unsigned 60.18-decimal fixed-point representation.\n    function fromUint(uint256 x) internal pure returns (uint256 result) {\n        unchecked {\n            if (x > MAX_UD60x18 / SCALE) {\n                revert PRBMathUD60x18__FromUintOverflow(x);\n            }\n            result = x * SCALE;\n        }\n    }\n\n    /// @notice Calculates geometric mean of x and y, i.e. sqrt(x * y), rounding down.\n    ///\n    /// @dev Requirements:\n    /// - x * y must fit within MAX_UD60x18, lest it overflows.\n    ///\n    /// @param x The first operand as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The second operand as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function gm(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        if (x == 0) {\n            return 0;\n        }\n\n        unchecked {\n            // Checking for overflow this way is faster than letting Solidity do it.\n            uint256 xy = x * y;\n            if (xy / x != y) {\n                revert PRBMathUD60x18__GmOverflow(x, y);\n            }\n\n            // We don't need to multiply by the SCALE here because the x*y product had already picked up a factor of SCALE\n            // during multiplication. See the comments within the \"sqrt\" function.\n            result = PRBMath.sqrt(xy);\n        }\n    }\n\n    /// @notice Calculates 1 / x, rounding toward zero.\n    ///\n    /// @dev Requirements:\n    /// - x cannot be zero.\n    ///\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the inverse.\n    /// @return result The inverse as an unsigned 60.18-decimal fixed-point number.\n    function inv(uint256 x) internal pure returns (uint256 result) {\n        unchecked {\n            // 1e36 is SCALE * SCALE.\n            result = 1e36 / x;\n        }\n    }\n\n    /// @notice Calculates the natural logarithm of x.\n    ///\n    /// @dev Based on the insight that ln(x) = log2(x) / log2(e).\n    ///\n    /// Requirements:\n    /// - All from \"log2\".\n    ///\n    /// Caveats:\n    /// - All from \"log2\".\n    /// - This doesn't return exactly 1 for 2.718281828459045235, for that we would need more fine-grained precision.\n    ///\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the natural logarithm.\n    /// @return result The natural logarithm as an unsigned 60.18-decimal fixed-point number.\n    function ln(uint256 x) internal pure returns (uint256 result) {\n        // Do the fixed-point multiplication inline to save gas. This is overflow-safe because the maximum value that log2(x)\n        // can return is 196205294292027477728.\n        unchecked {\n            result = (log2(x) * SCALE) / LOG2_E;\n        }\n    }\n\n    /// @notice Calculates the common logarithm of x.\n    ///\n    /// @dev First checks if x is an exact power of ten and it stops if yes. If it's not, calculates the common\n    /// logarithm based on the insight that log10(x) = log2(x) / log2(10).\n    ///\n    /// Requirements:\n    /// - All from \"log2\".\n    ///\n    /// Caveats:\n    /// - All from \"log2\".\n    ///\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the common logarithm.\n    /// @return result The common logarithm as an unsigned 60.18-decimal fixed-point number.\n    function log10(uint256 x) internal pure returns (uint256 result) {\n        if (x < SCALE) {\n            revert PRBMathUD60x18__LogInputTooSmall(x);\n        }\n\n        // Note that the \"mul\" in this block is the assembly multiplication operation, not the \"mul\" function defined\n        // in this contract.\n        // prettier-ignore\n        assembly {\n            switch x\n            case 1 { result := mul(SCALE, sub(0, 18)) }\n            case 10 { result := mul(SCALE, sub(1, 18)) }\n            case 100 { result := mul(SCALE, sub(2, 18)) }\n            case 1000 { result := mul(SCALE, sub(3, 18)) }\n            case 10000 { result := mul(SCALE, sub(4, 18)) }\n            case 100000 { result := mul(SCALE, sub(5, 18)) }\n            case 1000000 { result := mul(SCALE, sub(6, 18)) }\n            case 10000000 { result := mul(SCALE, sub(7, 18)) }\n            case 100000000 { result := mul(SCALE, sub(8, 18)) }\n            case 1000000000 { result := mul(SCALE, sub(9, 18)) }\n            case 10000000000 { result := mul(SCALE, sub(10, 18)) }\n            case 100000000000 { result := mul(SCALE, sub(11, 18)) }\n            case 1000000000000 { result := mul(SCALE, sub(12, 18)) }\n            case 10000000000000 { result := mul(SCALE, sub(13, 18)) }\n            case 100000000000000 { result := mul(SCALE, sub(14, 18)) }\n            case 1000000000000000 { result := mul(SCALE, sub(15, 18)) }\n            case 10000000000000000 { result := mul(SCALE, sub(16, 18)) }\n            case 100000000000000000 { result := mul(SCALE, sub(17, 18)) }\n            case 1000000000000000000 { result := 0 }\n            case 10000000000000000000 { result := SCALE }\n            case 100000000000000000000 { result := mul(SCALE, 2) }\n            case 1000000000000000000000 { result := mul(SCALE, 3) }\n            case 10000000000000000000000 { result := mul(SCALE, 4) }\n            case 100000000000000000000000 { result := mul(SCALE, 5) }\n            case 1000000000000000000000000 { result := mul(SCALE, 6) }\n            case 10000000000000000000000000 { result := mul(SCALE, 7) }\n            case 100000000000000000000000000 { result := mul(SCALE, 8) }\n            case 1000000000000000000000000000 { result := mul(SCALE, 9) }\n            case 10000000000000000000000000000 { result := mul(SCALE, 10) }\n            case 100000000000000000000000000000 { result := mul(SCALE, 11) }\n            case 1000000000000000000000000000000 { result := mul(SCALE, 12) }\n            case 10000000000000000000000000000000 { result := mul(SCALE, 13) }\n            case 100000000000000000000000000000000 { result := mul(SCALE, 14) }\n            case 1000000000000000000000000000000000 { result := mul(SCALE, 15) }\n            case 10000000000000000000000000000000000 { result := mul(SCALE, 16) }\n            case 100000000000000000000000000000000000 { result := mul(SCALE, 17) }\n            case 1000000000000000000000000000000000000 { result := mul(SCALE, 18) }\n            case 10000000000000000000000000000000000000 { result := mul(SCALE, 19) }\n            case 100000000000000000000000000000000000000 { result := mul(SCALE, 20) }\n            case 1000000000000000000000000000000000000000 { result := mul(SCALE, 21) }\n            case 10000000000000000000000000000000000000000 { result := mul(SCALE, 22) }\n            case 100000000000000000000000000000000000000000 { result := mul(SCALE, 23) }\n            case 1000000000000000000000000000000000000000000 { result := mul(SCALE, 24) }\n            case 10000000000000000000000000000000000000000000 { result := mul(SCALE, 25) }\n            case 100000000000000000000000000000000000000000000 { result := mul(SCALE, 26) }\n            case 1000000000000000000000000000000000000000000000 { result := mul(SCALE, 27) }\n            case 10000000000000000000000000000000000000000000000 { result := mul(SCALE, 28) }\n            case 100000000000000000000000000000000000000000000000 { result := mul(SCALE, 29) }\n            case 1000000000000000000000000000000000000000000000000 { result := mul(SCALE, 30) }\n            case 10000000000000000000000000000000000000000000000000 { result := mul(SCALE, 31) }\n            case 100000000000000000000000000000000000000000000000000 { result := mul(SCALE, 32) }\n            case 1000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 33) }\n            case 10000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 34) }\n            case 100000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 35) }\n            case 1000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 36) }\n            case 10000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 37) }\n            case 100000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 38) }\n            case 1000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 39) }\n            case 10000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 40) }\n            case 100000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 41) }\n            case 1000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 42) }\n            case 10000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 43) }\n            case 100000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 44) }\n            case 1000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 45) }\n            case 10000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 46) }\n            case 100000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 47) }\n            case 1000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 48) }\n            case 10000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 49) }\n            case 100000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 50) }\n            case 1000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 51) }\n            case 10000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 52) }\n            case 100000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 53) }\n            case 1000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 54) }\n            case 10000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 55) }\n            case 100000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 56) }\n            case 1000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 57) }\n            case 10000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 58) }\n            case 100000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 59) }\n            default {\n                result := MAX_UD60x18\n            }\n        }\n\n        if (result == MAX_UD60x18) {\n            // Do the fixed-point division inline to save gas. The denominator is log2(10).\n            unchecked {\n                result = (log2(x) * SCALE) / 3_321928094887362347;\n            }\n        }\n    }\n\n    /// @notice Calculates the binary logarithm of x.\n    ///\n    /// @dev Based on the iterative approximation algorithm.\n    /// https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation\n    ///\n    /// Requirements:\n    /// - x must be greater than or equal to SCALE, otherwise the result would be negative.\n    ///\n    /// Caveats:\n    /// - The results are nor perfectly accurate to the last decimal, due to the lossy precision of the iterative approximation.\n    ///\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the binary logarithm.\n    /// @return result The binary logarithm as an unsigned 60.18-decimal fixed-point number.\n    function log2(uint256 x) internal pure returns (uint256 result) {\n        if (x < SCALE) {\n            revert PRBMathUD60x18__LogInputTooSmall(x);\n        }\n        unchecked {\n            // Calculate the integer part of the logarithm and add it to the result and finally calculate y = x * 2^(-n).\n            uint256 n = PRBMath.mostSignificantBit(x / SCALE);\n\n            // The integer part of the logarithm as an unsigned 60.18-decimal fixed-point number. The operation can't overflow\n            // because n is maximum 255 and SCALE is 1e18.\n            result = n * SCALE;\n\n            // This is y = x * 2^(-n).\n            uint256 y = x >> n;\n\n            // If y = 1, the fractional part is zero.\n            if (y == SCALE) {\n                return result;\n            }\n\n            // Calculate the fractional part via the iterative approximation.\n            // The \"delta >>= 1\" part is equivalent to \"delta /= 2\", but shifting bits is faster.\n            for (uint256 delta = HALF_SCALE; delta > 0; delta >>= 1) {\n                y = (y * y) / SCALE;\n\n                // Is y^2 > 2 and so in the range [2,4)?\n                if (y >= 2 * SCALE) {\n                    // Add the 2^(-m) factor to the logarithm.\n                    result += delta;\n\n                    // Corresponds to z/2 on Wikipedia.\n                    y >>= 1;\n                }\n            }\n        }\n    }\n\n    /// @notice Multiplies two unsigned 60.18-decimal fixed-point numbers together, returning a new unsigned 60.18-decimal\n    /// fixed-point number.\n    /// @dev See the documentation for the \"PRBMath.mulDivFixedPoint\" function.\n    /// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The product as an unsigned 60.18-decimal fixed-point number.\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        result = PRBMath.mulDivFixedPoint(x, y);\n    }\n\n    /// @notice Returns PI as an unsigned 60.18-decimal fixed-point number.\n    function pi() internal pure returns (uint256 result) {\n        result = 3_141592653589793238;\n    }\n\n    /// @notice Raises x to the power of y.\n    ///\n    /// @dev Based on the insight that x^y = 2^(log2(x) * y).\n    ///\n    /// Requirements:\n    /// - All from \"exp2\", \"log2\" and \"mul\".\n    ///\n    /// Caveats:\n    /// - All from \"exp2\", \"log2\" and \"mul\".\n    /// - Assumes 0^0 is 1.\n    ///\n    /// @param x Number to raise to given power y, as an unsigned 60.18-decimal fixed-point number.\n    /// @param y Exponent to raise x to, as an unsigned 60.18-decimal fixed-point number.\n    /// @return result x raised to power y, as an unsigned 60.18-decimal fixed-point number.\n    function pow(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        if (x == 0) {\n            result = y == 0 ? SCALE : uint256(0);\n        } else {\n            result = exp2(mul(log2(x), y));\n        }\n    }\n\n    /// @notice Raises x (unsigned 60.18-decimal fixed-point number) to the power of y (basic unsigned integer) using the\n    /// famous algorithm \"exponentiation by squaring\".\n    ///\n    /// @dev See https://en.wikipedia.org/wiki/Exponentiation_by_squaring\n    ///\n    /// Requirements:\n    /// - The result must fit within MAX_UD60x18.\n    ///\n    /// Caveats:\n    /// - All from \"mul\".\n    /// - Assumes 0^0 is 1.\n    ///\n    /// @param x The base as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The exponent as an uint256.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function powu(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        // Calculate the first iteration of the loop in advance.\n        result = y & 1 > 0 ? x : SCALE;\n\n        // Equivalent to \"for(y /= 2; y > 0; y /= 2)\" but faster.\n        for (y >>= 1; y > 0; y >>= 1) {\n            x = PRBMath.mulDivFixedPoint(x, x);\n\n            // Equivalent to \"y % 2 == 1\" but faster.\n            if (y & 1 > 0) {\n                result = PRBMath.mulDivFixedPoint(result, x);\n            }\n        }\n    }\n\n    /// @notice Returns 1 as an unsigned 60.18-decimal fixed-point number.\n    function scale() internal pure returns (uint256 result) {\n        result = SCALE;\n    }\n\n    /// @notice Calculates the square root of x, rounding down.\n    /// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\n    ///\n    /// Requirements:\n    /// - x must be less than MAX_UD60x18 / SCALE.\n    ///\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the square root.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point .\n    function sqrt(uint256 x) internal pure returns (uint256 result) {\n        unchecked {\n            if (x > MAX_UD60x18 / SCALE) {\n                revert PRBMathUD60x18__SqrtOverflow(x);\n            }\n            // Multiply x by the SCALE to account for the factor of SCALE that is picked up when multiplying two unsigned\n            // 60.18-decimal fixed-point numbers together (in this case, those two numbers are both the square root).\n            result = PRBMath.sqrt(x * SCALE);\n        }\n    }\n\n    /// @notice Converts a unsigned 60.18-decimal fixed-point number to basic integer form, rounding down in the process.\n    /// @param x The unsigned 60.18-decimal fixed-point number to convert.\n    /// @return result The same number in basic integer form.\n    function toUint(uint256 x) internal pure returns (uint256 result) {\n        unchecked {\n            result = x / SCALE;\n        }\n    }\n}\n"
    }
  }
}}