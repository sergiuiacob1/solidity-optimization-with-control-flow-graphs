\chapter{Contributions}

\section{A way to contribute}
\paragraph*{}
The most challenging part was building smart contracts that were not fully optimized by Solidity's compiler. This mostly meant finding situations, edge cases in which the compiler was "fooled" by the high level code, making it impossible for various optimizations to be applied or simply ignored.

\paragraph*{}
The first approach here was to experiment with Solidity and compile smart contracts until such an edge case was found. The challenge here is that it is very difficult and time consuming to analyze the generated bytecode and try to find an optimization opportunity, since assembly instructions are not "human readable".

\paragraph*{}
The second approach was to reverse engineer Solidity's open-source codebase, get familiar with the internal optimizer structure and try constructing edge cases not treated by the optimizer. While this is definitely a good approach, it requires a bit of experience with optimizers and some time to get familiar with Solidity's codebase.

\paragraph*{}
What helped by a great margin was the usage of \textbf{YUL Intermediate Representation}, which can be analyzed in its optimized form, since it is the intermediate code used to generate the final bytecode. This way, it was much faster to analyse wether the generated bytecode would be optimal or not.

\section{Enhancement of optimization steps}
\paragraph*{}
Solidity's optimizer has \href{https://docs.soliditylang.org/en/v0.8.14/internals/optimizer.html#optimizer-steps}{32 documented optimization steps}. One of the most straightforward way to speed up code computation is to run less code, which comes from generating the proper bytecode and from pruning ``dead code'', i.e. high level code that the user wrote but is unreachable. Enhancements were brought to \textbf{UnusedAssignEliminator} and \textbf{StructuralSimplifier} that ultimately improved gas consumption for specific scenarios in smart contracts.

\paragraph*{}
In this thesis, several edge cases are presented that tricked the optimizer, and by handling those, the functionality of the whole optimization suite was improved thanks to the cascading optimization aspect \footnote{Improvements to a single optimization step enable other optimization steps (or the same one) to improve bytecode. An example is given in for StructuralSimplifier \ref{structural-simplifier-cascading-example}.}. A few other observations are made throughout the thesis, which can easily transform into external contributions to ultimately generate a more efficient smart contract.

\section{Reducing gas usage of smart contracts}
\paragraph*{}
The quality of Solidity's compiler and optimizer is evaluated by the \textbf{gas usage} of the smart contract, both deployment on the network and the cost of running a function within the deployed contract. With the optimizations mentioned above, the optimizer \textbf{generated code that requires less gas}, which means less ethereum, which means smaller costs for the user. Particularly for a test suite that captures the edge cases found, contract deployment saw an average saving of $2300$ gas ($\approx 2\%$), while execution of an isolated function taking advantage of the implemented improvements saw savings of up to $60$ gas ($\approx 0.2\%$).

\paragraph*{}
Multiply any small, seemly insignificant gas improvement by the millions of smart contracts on the Ethereum blockchain and you end up with an overall significant cost reduction in code execution. Therefore, external contributions as these will sum up to bring a real difference in code quality\footnote{We will dive deeper into which smart contracts will benefit from these optimizations and how optimization steps give more opportunities to other optimization steps in the latter chapters.}.
