{{
  "language": "Solidity",
  "sources": {
    "src/v0.8/Chainlink.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {CBORChainlink} from \"./vendor/CBORChainlink.sol\";\nimport {BufferChainlink} from \"./vendor/BufferChainlink.sol\";\n\n/**\n * @title Library for common Chainlink functions\n * @dev Uses imported CBOR library for encoding to buffer\n */\nlibrary Chainlink {\n  uint256 internal constant defaultBufferSize = 256; // solhint-disable-line const-name-snakecase\n\n  using CBORChainlink for BufferChainlink.buffer;\n\n  struct Request {\n    bytes32 id;\n    address callbackAddress;\n    bytes4 callbackFunctionId;\n    uint256 nonce;\n    BufferChainlink.buffer buf;\n  }\n\n  /**\n   * @notice Initializes a Chainlink request\n   * @dev Sets the ID, callback address, and callback function signature on the request\n   * @param self The uninitialized request\n   * @param jobId The Job Specification ID\n   * @param callbackAddr The callback address\n   * @param callbackFunc The callback function signature\n   * @return The initialized request\n   */\n  function initialize(\n    Request memory self,\n    bytes32 jobId,\n    address callbackAddr,\n    bytes4 callbackFunc\n  ) internal pure returns (Chainlink.Request memory) {\n    BufferChainlink.init(self.buf, defaultBufferSize);\n    self.id = jobId;\n    self.callbackAddress = callbackAddr;\n    self.callbackFunctionId = callbackFunc;\n    return self;\n  }\n\n  /**\n   * @notice Sets the data for the buffer without encoding CBOR on-chain\n   * @dev CBOR can be closed with curly-brackets {} or they can be left off\n   * @param self The initialized request\n   * @param data The CBOR data\n   */\n  function setBuffer(Request memory self, bytes memory data) internal pure {\n    BufferChainlink.init(self.buf, data.length);\n    BufferChainlink.append(self.buf, data);\n  }\n\n  /**\n   * @notice Adds a string value to the request with a given key name\n   * @param self The initialized request\n   * @param key The name of the key\n   * @param value The string value to add\n   */\n  function add(\n    Request memory self,\n    string memory key,\n    string memory value\n  ) internal pure {\n    self.buf.encodeString(key);\n    self.buf.encodeString(value);\n  }\n\n  /**\n   * @notice Adds a bytes value to the request with a given key name\n   * @param self The initialized request\n   * @param key The name of the key\n   * @param value The bytes value to add\n   */\n  function addBytes(\n    Request memory self,\n    string memory key,\n    bytes memory value\n  ) internal pure {\n    self.buf.encodeString(key);\n    self.buf.encodeBytes(value);\n  }\n\n  /**\n   * @notice Adds a int256 value to the request with a given key name\n   * @param self The initialized request\n   * @param key The name of the key\n   * @param value The int256 value to add\n   */\n  function addInt(\n    Request memory self,\n    string memory key,\n    int256 value\n  ) internal pure {\n    self.buf.encodeString(key);\n    self.buf.encodeInt(value);\n  }\n\n  /**\n   * @notice Adds a uint256 value to the request with a given key name\n   * @param self The initialized request\n   * @param key The name of the key\n   * @param value The uint256 value to add\n   */\n  function addUint(\n    Request memory self,\n    string memory key,\n    uint256 value\n  ) internal pure {\n    self.buf.encodeString(key);\n    self.buf.encodeUInt(value);\n  }\n\n  /**\n   * @notice Adds an array of strings to the request with a given key name\n   * @param self The initialized request\n   * @param key The name of the key\n   * @param values The array of string values to add\n   */\n  function addStringArray(\n    Request memory self,\n    string memory key,\n    string[] memory values\n  ) internal pure {\n    self.buf.encodeString(key);\n    self.buf.startArray();\n    for (uint256 i = 0; i < values.length; i++) {\n      self.buf.encodeString(values[i]);\n    }\n    self.buf.endSequence();\n  }\n}\n"
    },
    "src/v0.8/vendor/CBORChainlink.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.19;\n\nimport {BufferChainlink} from \"./BufferChainlink.sol\";\n\nlibrary CBORChainlink {\n  using BufferChainlink for BufferChainlink.buffer;\n\n  uint8 private constant MAJOR_TYPE_INT = 0;\n  uint8 private constant MAJOR_TYPE_NEGATIVE_INT = 1;\n  uint8 private constant MAJOR_TYPE_BYTES = 2;\n  uint8 private constant MAJOR_TYPE_STRING = 3;\n  uint8 private constant MAJOR_TYPE_ARRAY = 4;\n  uint8 private constant MAJOR_TYPE_MAP = 5;\n  uint8 private constant MAJOR_TYPE_TAG = 6;\n  uint8 private constant MAJOR_TYPE_CONTENT_FREE = 7;\n\n  uint8 private constant TAG_TYPE_BIGNUM = 2;\n  uint8 private constant TAG_TYPE_NEGATIVE_BIGNUM = 3;\n\n  function encodeFixedNumeric(BufferChainlink.buffer memory buf, uint8 major, uint64 value) private pure {\n    if(value <= 23) {\n      buf.appendUint8(uint8((major << 5) | value));\n    } else if (value <= 0xFF) {\n      buf.appendUint8(uint8((major << 5) | 24));\n      buf.appendInt(value, 1);\n    } else if (value <= 0xFFFF) {\n      buf.appendUint8(uint8((major << 5) | 25));\n      buf.appendInt(value, 2);\n    } else if (value <= 0xFFFFFFFF) {\n      buf.appendUint8(uint8((major << 5) | 26));\n      buf.appendInt(value, 4);\n    } else {\n      buf.appendUint8(uint8((major << 5) | 27));\n      buf.appendInt(value, 8);\n    }\n  }\n\n  function encodeIndefiniteLengthType(BufferChainlink.buffer memory buf, uint8 major) private pure {\n    buf.appendUint8(uint8((major << 5) | 31));\n  }\n\n  function encodeUInt(BufferChainlink.buffer memory buf, uint value) internal pure {\n    if(value > 0xFFFFFFFFFFFFFFFF) {\n      encodeBigNum(buf, value);\n    } else {\n      encodeFixedNumeric(buf, MAJOR_TYPE_INT, uint64(value));\n    }\n  }\n\n  function encodeInt(BufferChainlink.buffer memory buf, int value) internal pure {\n    if(value < -0x10000000000000000) {\n      encodeSignedBigNum(buf, value);\n    } else if(value > 0xFFFFFFFFFFFFFFFF) {\n      encodeBigNum(buf, uint(value));\n    } else if(value >= 0) {\n      encodeFixedNumeric(buf, MAJOR_TYPE_INT, uint64(uint256(value)));\n    } else {\n      encodeFixedNumeric(buf, MAJOR_TYPE_NEGATIVE_INT, uint64(uint256(-1 - value)));\n    }\n  }\n\n  function encodeBytes(BufferChainlink.buffer memory buf, bytes memory value) internal pure {\n    encodeFixedNumeric(buf, MAJOR_TYPE_BYTES, uint64(value.length));\n    buf.append(value);\n  }\n\n  function encodeBigNum(BufferChainlink.buffer memory buf, uint value) internal pure {\n    buf.appendUint8(uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_BIGNUM));\n    encodeBytes(buf, abi.encode(value));\n  }\n\n  function encodeSignedBigNum(BufferChainlink.buffer memory buf, int input) internal pure {\n    buf.appendUint8(uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_NEGATIVE_BIGNUM));\n    encodeBytes(buf, abi.encode(uint256(-1 - input)));\n  }\n\n  function encodeString(BufferChainlink.buffer memory buf, string memory value) internal pure {\n    encodeFixedNumeric(buf, MAJOR_TYPE_STRING, uint64(bytes(value).length));\n    buf.append(bytes(value));\n  }\n\n  function startArray(BufferChainlink.buffer memory buf) internal pure {\n    encodeIndefiniteLengthType(buf, MAJOR_TYPE_ARRAY);\n  }\n\n  function startMap(BufferChainlink.buffer memory buf) internal pure {\n    encodeIndefiniteLengthType(buf, MAJOR_TYPE_MAP);\n  }\n\n  function endSequence(BufferChainlink.buffer memory buf) internal pure {\n    encodeIndefiniteLengthType(buf, MAJOR_TYPE_CONTENT_FREE);\n  }\n}\n"
    },
    "src/v0.8/vendor/BufferChainlink.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @dev A library for working with mutable byte buffers in Solidity.\n *\n * Byte buffers are mutable and expandable, and provide a variety of primitives\n * for writing to them. At any time you can fetch a bytes object containing the\n * current contents of the buffer. The bytes object should not be stored between\n * operations, as it may change due to resizing of the buffer.\n */\nlibrary BufferChainlink {\n  /**\n   * @dev Represents a mutable buffer. Buffers have a current value (buf) and\n   *      a capacity. The capacity may be longer than the current value, in\n   *      which case it can be extended without the need to allocate more memory.\n   */\n  struct buffer {\n    bytes buf;\n    uint256 capacity;\n  }\n\n  /**\n   * @dev Initializes a buffer with an initial capacity.\n   * @param buf The buffer to initialize.\n   * @param capacity The number of bytes of space to allocate the buffer.\n   * @return The buffer, for chaining.\n   */\n  function init(buffer memory buf, uint256 capacity) internal pure returns (buffer memory) {\n    if (capacity % 32 != 0) {\n      capacity += 32 - (capacity % 32);\n    }\n    // Allocate space for the buffer data\n    buf.capacity = capacity;\n    assembly {\n      let ptr := mload(0x40)\n      mstore(buf, ptr)\n      mstore(ptr, 0)\n      mstore(0x40, add(32, add(ptr, capacity)))\n    }\n    return buf;\n  }\n\n  /**\n   * @dev Initializes a new buffer from an existing bytes object.\n   *      Changes to the buffer may mutate the original value.\n   * @param b The bytes object to initialize the buffer with.\n   * @return A new buffer.\n   */\n  function fromBytes(bytes memory b) internal pure returns (buffer memory) {\n    buffer memory buf;\n    buf.buf = b;\n    buf.capacity = b.length;\n    return buf;\n  }\n\n  function resize(buffer memory buf, uint256 capacity) private pure {\n    bytes memory oldbuf = buf.buf;\n    init(buf, capacity);\n    append(buf, oldbuf);\n  }\n\n  function max(uint256 a, uint256 b) private pure returns (uint256) {\n    if (a > b) {\n      return a;\n    }\n    return b;\n  }\n\n  /**\n   * @dev Sets buffer length to 0.\n   * @param buf The buffer to truncate.\n   * @return The original buffer, for chaining..\n   */\n  function truncate(buffer memory buf) internal pure returns (buffer memory) {\n    assembly {\n      let bufptr := mload(buf)\n      mstore(bufptr, 0)\n    }\n    return buf;\n  }\n\n  /**\n   * @dev Writes a byte string to a buffer. Resizes if doing so would exceed\n   *      the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param off The start offset to write to.\n   * @param data The data to append.\n   * @param len The number of bytes to copy.\n   * @return The original buffer, for chaining.\n   */\n  function write(\n    buffer memory buf,\n    uint256 off,\n    bytes memory data,\n    uint256 len\n  ) internal pure returns (buffer memory) {\n    require(len <= data.length);\n\n    if (off + len > buf.capacity) {\n      resize(buf, max(buf.capacity, len + off) * 2);\n    }\n\n    uint256 dest;\n    uint256 src;\n    assembly {\n      // Memory address of the buffer data\n      let bufptr := mload(buf)\n      // Length of existing buffer data\n      let buflen := mload(bufptr)\n      // Start address = buffer address + offset + sizeof(buffer length)\n      dest := add(add(bufptr, 32), off)\n      // Update buffer length if we're extending it\n      if gt(add(len, off), buflen) {\n        mstore(bufptr, add(len, off))\n      }\n      src := add(data, 32)\n    }\n\n    // Copy word-length chunks while possible\n    for (; len >= 32; len -= 32) {\n      assembly {\n        mstore(dest, mload(src))\n      }\n      dest += 32;\n      src += 32;\n    }\n\n    // Copy remaining bytes\n    unchecked {\n      uint256 mask = (256**(32 - len)) - 1;\n      assembly {\n        let srcpart := and(mload(src), not(mask))\n        let destpart := and(mload(dest), mask)\n        mstore(dest, or(destpart, srcpart))\n      }\n    }\n\n    return buf;\n  }\n\n  /**\n   * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\n   *      the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param data The data to append.\n   * @param len The number of bytes to copy.\n   * @return The original buffer, for chaining.\n   */\n  function append(\n    buffer memory buf,\n    bytes memory data,\n    uint256 len\n  ) internal pure returns (buffer memory) {\n    return write(buf, buf.buf.length, data, len);\n  }\n\n  /**\n   * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\n   *      the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param data The data to append.\n   * @return The original buffer, for chaining.\n   */\n  function append(buffer memory buf, bytes memory data) internal pure returns (buffer memory) {\n    return write(buf, buf.buf.length, data, data.length);\n  }\n\n  /**\n   * @dev Writes a byte to the buffer. Resizes if doing so would exceed the\n   *      capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param off The offset to write the byte at.\n   * @param data The data to append.\n   * @return The original buffer, for chaining.\n   */\n  function writeUint8(\n    buffer memory buf,\n    uint256 off,\n    uint8 data\n  ) internal pure returns (buffer memory) {\n    if (off >= buf.capacity) {\n      resize(buf, buf.capacity * 2);\n    }\n\n    assembly {\n      // Memory address of the buffer data\n      let bufptr := mload(buf)\n      // Length of existing buffer data\n      let buflen := mload(bufptr)\n      // Address = buffer address + sizeof(buffer length) + off\n      let dest := add(add(bufptr, off), 32)\n      mstore8(dest, data)\n      // Update buffer length if we extended it\n      if eq(off, buflen) {\n        mstore(bufptr, add(buflen, 1))\n      }\n    }\n    return buf;\n  }\n\n  /**\n   * @dev Appends a byte to the buffer. Resizes if doing so would exceed the\n   *      capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param data The data to append.\n   * @return The original buffer, for chaining.\n   */\n  function appendUint8(buffer memory buf, uint8 data) internal pure returns (buffer memory) {\n    return writeUint8(buf, buf.buf.length, data);\n  }\n\n  /**\n   * @dev Writes up to 32 bytes to the buffer. Resizes if doing so would\n   *      exceed the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param off The offset to write at.\n   * @param data The data to append.\n   * @param len The number of bytes to write (left-aligned).\n   * @return The original buffer, for chaining.\n   */\n  function write(\n    buffer memory buf,\n    uint256 off,\n    bytes32 data,\n    uint256 len\n  ) private pure returns (buffer memory) {\n    if (len + off > buf.capacity) {\n      resize(buf, (len + off) * 2);\n    }\n\n    unchecked {\n      uint256 mask = (256**len) - 1;\n      // Right-align data\n      data = data >> (8 * (32 - len));\n      assembly {\n        // Memory address of the buffer data\n        let bufptr := mload(buf)\n        // Address = buffer address + sizeof(buffer length) + off + len\n        let dest := add(add(bufptr, off), len)\n        mstore(dest, or(and(mload(dest), not(mask)), data))\n        // Update buffer length if we extended it\n        if gt(add(off, len), mload(bufptr)) {\n          mstore(bufptr, add(off, len))\n        }\n      }\n    }\n    return buf;\n  }\n\n  /**\n   * @dev Writes a bytes20 to the buffer. Resizes if doing so would exceed the\n   *      capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param off The offset to write at.\n   * @param data The data to append.\n   * @return The original buffer, for chaining.\n   */\n  function writeBytes20(\n    buffer memory buf,\n    uint256 off,\n    bytes20 data\n  ) internal pure returns (buffer memory) {\n    return write(buf, off, bytes32(data), 20);\n  }\n\n  /**\n   * @dev Appends a bytes20 to the buffer. Resizes if doing so would exceed\n   *      the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param data The data to append.\n   * @return The original buffer, for chhaining.\n   */\n  function appendBytes20(buffer memory buf, bytes20 data) internal pure returns (buffer memory) {\n    return write(buf, buf.buf.length, bytes32(data), 20);\n  }\n\n  /**\n   * @dev Appends a bytes32 to the buffer. Resizes if doing so would exceed\n   *      the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param data The data to append.\n   * @return The original buffer, for chaining.\n   */\n  function appendBytes32(buffer memory buf, bytes32 data) internal pure returns (buffer memory) {\n    return write(buf, buf.buf.length, data, 32);\n  }\n\n  /**\n   * @dev Writes an integer to the buffer. Resizes if doing so would exceed\n   *      the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param off The offset to write at.\n   * @param data The data to append.\n   * @param len The number of bytes to write (right-aligned).\n   * @return The original buffer, for chaining.\n   */\n  function writeInt(\n    buffer memory buf,\n    uint256 off,\n    uint256 data,\n    uint256 len\n  ) private pure returns (buffer memory) {\n    if (len + off > buf.capacity) {\n      resize(buf, (len + off) * 2);\n    }\n\n    uint256 mask = (256**len) - 1;\n    assembly {\n      // Memory address of the buffer data\n      let bufptr := mload(buf)\n      // Address = buffer address + off + sizeof(buffer length) + len\n      let dest := add(add(bufptr, off), len)\n      mstore(dest, or(and(mload(dest), not(mask)), data))\n      // Update buffer length if we extended it\n      if gt(add(off, len), mload(bufptr)) {\n        mstore(bufptr, add(off, len))\n      }\n    }\n    return buf;\n  }\n\n  /**\n   * @dev Appends a byte to the end of the buffer. Resizes if doing so would\n   * exceed the capacity of the buffer.\n   * @param buf The buffer to append to.\n   * @param data The data to append.\n   * @return The original buffer.\n   */\n  function appendInt(\n    buffer memory buf,\n    uint256 data,\n    uint256 len\n  ) internal pure returns (buffer memory) {\n    return writeInt(buf, buf.buf.length, data, len);\n  }\n}\n"
    },
    "src/v0.8/tests/ChainlinkTestHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../Chainlink.sol\";\nimport \"../vendor/CBORChainlink.sol\";\nimport \"../vendor/BufferChainlink.sol\";\n\ncontract ChainlinkTestHelper {\n  using Chainlink for Chainlink.Request;\n  using CBORChainlink for BufferChainlink.buffer;\n\n  Chainlink.Request private req;\n\n  event RequestData(bytes payload);\n\n  function closeEvent() public {\n    emit RequestData(req.buf.buf);\n  }\n\n  function setBuffer(bytes memory data) public {\n    Chainlink.Request memory r2 = req;\n    r2.setBuffer(data);\n    req = r2;\n  }\n\n  function add(string memory _key, string memory _value) public {\n    Chainlink.Request memory r2 = req;\n    r2.add(_key, _value);\n    req = r2;\n  }\n\n  function addBytes(string memory _key, bytes memory _value) public {\n    Chainlink.Request memory r2 = req;\n    r2.addBytes(_key, _value);\n    req = r2;\n  }\n\n  function addInt(string memory _key, int256 _value) public {\n    Chainlink.Request memory r2 = req;\n    r2.addInt(_key, _value);\n    req = r2;\n  }\n\n  function addUint(string memory _key, uint256 _value) public {\n    Chainlink.Request memory r2 = req;\n    r2.addUint(_key, _value);\n    req = r2;\n  }\n\n  // Temporarily have method receive bytes32[] memory until experimental\n  // string[] memory can be invoked from truffle tests.\n  function addStringArray(string memory _key, string[] memory _values) public {\n    Chainlink.Request memory r2 = req;\n    r2.addStringArray(_key, _values);\n    req = r2;\n  }\n}\n"
    },
    "src/v0.8/ChainlinkClient.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./Chainlink.sol\";\nimport \"./interfaces/ENSInterface.sol\";\nimport \"./interfaces/LinkTokenInterface.sol\";\nimport \"./interfaces/ChainlinkRequestInterface.sol\";\nimport \"./interfaces/OperatorInterface.sol\";\nimport \"./interfaces/PointerInterface.sol\";\nimport {ENSResolver as ENSResolver_Chainlink} from \"./vendor/ENSResolver.sol\";\n\n/**\n * @title The ChainlinkClient contract\n * @notice Contract writers can inherit this contract in order to create requests for the\n * Chainlink network\n */\nabstract contract ChainlinkClient {\n  using Chainlink for Chainlink.Request;\n\n  uint256 internal constant LINK_DIVISIBILITY = 10**18;\n  uint256 private constant AMOUNT_OVERRIDE = 0;\n  address private constant SENDER_OVERRIDE = address(0);\n  uint256 private constant ORACLE_ARGS_VERSION = 1;\n  uint256 private constant OPERATOR_ARGS_VERSION = 2;\n  bytes32 private constant ENS_TOKEN_SUBNAME = keccak256(\"link\");\n  bytes32 private constant ENS_ORACLE_SUBNAME = keccak256(\"oracle\");\n  address private constant LINK_TOKEN_POINTER = 0xC89bD4E1632D3A43CB03AAAd5262cbe4038Bc571;\n\n  ENSInterface private s_ens;\n  bytes32 private s_ensNode;\n  LinkTokenInterface private s_link;\n  OperatorInterface private s_oracle;\n  uint256 private s_requestCount = 1;\n  mapping(bytes32 => address) private s_pendingRequests;\n\n  event ChainlinkRequested(bytes32 indexed id);\n  event ChainlinkFulfilled(bytes32 indexed id);\n  event ChainlinkCancelled(bytes32 indexed id);\n\n  /**\n   * @notice Creates a request that can hold additional parameters\n   * @param specId The Job Specification ID that the request will be created for\n   * @param callbackAddr address to operate the callback on\n   * @param callbackFunctionSignature function signature to use for the callback\n   * @return A Chainlink Request struct in memory\n   */\n  function buildChainlinkRequest(\n    bytes32 specId,\n    address callbackAddr,\n    bytes4 callbackFunctionSignature\n  ) internal pure returns (Chainlink.Request memory) {\n    Chainlink.Request memory req;\n    return req.initialize(specId, callbackAddr, callbackFunctionSignature);\n  }\n\n  /**\n   * @notice Creates a request that can hold additional parameters\n   * @param specId The Job Specification ID that the request will be created for\n   * @param callbackFunctionSignature function signature to use for the callback\n   * @return A Chainlink Request struct in memory\n   */\n  function buildOperatorRequest(bytes32 specId, bytes4 callbackFunctionSignature)\n    internal\n    view\n    returns (Chainlink.Request memory)\n  {\n    Chainlink.Request memory req;\n    return req.initialize(specId, address(this), callbackFunctionSignature);\n  }\n\n  /**\n   * @notice Creates a Chainlink request to the stored oracle address\n   * @dev Calls `chainlinkRequestTo` with the stored oracle address\n   * @param req The initialized Chainlink Request\n   * @param payment The amount of LINK to send for the request\n   * @return requestId The request ID\n   */\n  function sendChainlinkRequest(Chainlink.Request memory req, uint256 payment) internal returns (bytes32) {\n    return sendChainlinkRequestTo(address(s_oracle), req, payment);\n  }\n\n  /**\n   * @notice Creates a Chainlink request to the specified oracle address\n   * @dev Generates and stores a request ID, increments the local nonce, and uses `transferAndCall` to\n   * send LINK which creates a request on the target oracle contract.\n   * Emits ChainlinkRequested event.\n   * @param oracleAddress The address of the oracle for the request\n   * @param req The initialized Chainlink Request\n   * @param payment The amount of LINK to send for the request\n   * @return requestId The request ID\n   */\n  function sendChainlinkRequestTo(\n    address oracleAddress,\n    Chainlink.Request memory req,\n    uint256 payment\n  ) internal returns (bytes32 requestId) {\n    uint256 nonce = s_requestCount;\n    s_requestCount = nonce + 1;\n    bytes memory encodedRequest = abi.encodeWithSelector(\n      ChainlinkRequestInterface.oracleRequest.selector,\n      SENDER_OVERRIDE, // Sender value - overridden by onTokenTransfer by the requesting contract's address\n      AMOUNT_OVERRIDE, // Amount value - overridden by onTokenTransfer by the actual amount of LINK sent\n      req.id,\n      address(this),\n      req.callbackFunctionId,\n      nonce,\n      ORACLE_ARGS_VERSION,\n      req.buf.buf\n    );\n    return _rawRequest(oracleAddress, nonce, payment, encodedRequest);\n  }\n\n  /**\n   * @notice Creates a Chainlink request to the stored oracle address\n   * @dev This function supports multi-word response\n   * @dev Calls `sendOperatorRequestTo` with the stored oracle address\n   * @param req The initialized Chainlink Request\n   * @param payment The amount of LINK to send for the request\n   * @return requestId The request ID\n   */\n  function sendOperatorRequest(Chainlink.Request memory req, uint256 payment) internal returns (bytes32) {\n    return sendOperatorRequestTo(address(s_oracle), req, payment);\n  }\n\n  /**\n   * @notice Creates a Chainlink request to the specified oracle address\n   * @dev This function supports multi-word response\n   * @dev Generates and stores a request ID, increments the local nonce, and uses `transferAndCall` to\n   * send LINK which creates a request on the target oracle contract.\n   * Emits ChainlinkRequested event.\n   * @param oracleAddress The address of the oracle for the request\n   * @param req The initialized Chainlink Request\n   * @param payment The amount of LINK to send for the request\n   * @return requestId The request ID\n   */\n  function sendOperatorRequestTo(\n    address oracleAddress,\n    Chainlink.Request memory req,\n    uint256 payment\n  ) internal returns (bytes32 requestId) {\n    uint256 nonce = s_requestCount;\n    s_requestCount = nonce + 1;\n    bytes memory encodedRequest = abi.encodeWithSelector(\n      OperatorInterface.operatorRequest.selector,\n      SENDER_OVERRIDE, // Sender value - overridden by onTokenTransfer by the requesting contract's address\n      AMOUNT_OVERRIDE, // Amount value - overridden by onTokenTransfer by the actual amount of LINK sent\n      req.id,\n      req.callbackFunctionId,\n      nonce,\n      OPERATOR_ARGS_VERSION,\n      req.buf.buf\n    );\n    return _rawRequest(oracleAddress, nonce, payment, encodedRequest);\n  }\n\n  /**\n   * @notice Make a request to an oracle\n   * @param oracleAddress The address of the oracle for the request\n   * @param nonce used to generate the request ID\n   * @param payment The amount of LINK to send for the request\n   * @param encodedRequest data encoded for request type specific format\n   * @return requestId The request ID\n   */\n  function _rawRequest(\n    address oracleAddress,\n    uint256 nonce,\n    uint256 payment,\n    bytes memory encodedRequest\n  ) private returns (bytes32 requestId) {\n    requestId = keccak256(abi.encodePacked(this, nonce));\n    s_pendingRequests[requestId] = oracleAddress;\n    emit ChainlinkRequested(requestId);\n    require(s_link.transferAndCall(oracleAddress, payment, encodedRequest), \"unable to transferAndCall to oracle\");\n  }\n\n  /**\n   * @notice Allows a request to be cancelled if it has not been fulfilled\n   * @dev Requires keeping track of the expiration value emitted from the oracle contract.\n   * Deletes the request from the `pendingRequests` mapping.\n   * Emits ChainlinkCancelled event.\n   * @param requestId The request ID\n   * @param payment The amount of LINK sent for the request\n   * @param callbackFunc The callback function specified for the request\n   * @param expiration The time of the expiration for the request\n   */\n  function cancelChainlinkRequest(\n    bytes32 requestId,\n    uint256 payment,\n    bytes4 callbackFunc,\n    uint256 expiration\n  ) internal {\n    OperatorInterface requested = OperatorInterface(s_pendingRequests[requestId]);\n    delete s_pendingRequests[requestId];\n    emit ChainlinkCancelled(requestId);\n    requested.cancelOracleRequest(requestId, payment, callbackFunc, expiration);\n  }\n\n  /**\n   * @notice the next request count to be used in generating a nonce\n   * @dev starts at 1 in order to ensure consistent gas cost\n   * @return returns the next request count to be used in a nonce\n   */\n  function getNextRequestCount() internal view returns (uint256) {\n    return s_requestCount;\n  }\n\n  /**\n   * @notice Sets the stored oracle address\n   * @param oracleAddress The address of the oracle contract\n   */\n  function setChainlinkOracle(address oracleAddress) internal {\n    s_oracle = OperatorInterface(oracleAddress);\n  }\n\n  /**\n   * @notice Sets the LINK token address\n   * @param linkAddress The address of the LINK token contract\n   */\n  function setChainlinkToken(address linkAddress) internal {\n    s_link = LinkTokenInterface(linkAddress);\n  }\n\n  /**\n   * @notice Sets the Chainlink token address for the public\n   * network as given by the Pointer contract\n   */\n  function setPublicChainlinkToken() internal {\n    setChainlinkToken(PointerInterface(LINK_TOKEN_POINTER).getAddress());\n  }\n\n  /**\n   * @notice Retrieves the stored address of the LINK token\n   * @return The address of the LINK token\n   */\n  function chainlinkTokenAddress() internal view returns (address) {\n    return address(s_link);\n  }\n\n  /**\n   * @notice Retrieves the stored address of the oracle contract\n   * @return The address of the oracle contract\n   */\n  function chainlinkOracleAddress() internal view returns (address) {\n    return address(s_oracle);\n  }\n\n  /**\n   * @notice Allows for a request which was created on another contract to be fulfilled\n   * on this contract\n   * @param oracleAddress The address of the oracle contract that will fulfill the request\n   * @param requestId The request ID used for the response\n   */\n  function addChainlinkExternalRequest(address oracleAddress, bytes32 requestId) internal notPendingRequest(requestId) {\n    s_pendingRequests[requestId] = oracleAddress;\n  }\n\n  /**\n   * @notice Sets the stored oracle and LINK token contracts with the addresses resolved by ENS\n   * @dev Accounts for subnodes having different resolvers\n   * @param ensAddress The address of the ENS contract\n   * @param node The ENS node hash\n   */\n  function useChainlinkWithENS(address ensAddress, bytes32 node) internal {\n    s_ens = ENSInterface(ensAddress);\n    s_ensNode = node;\n    bytes32 linkSubnode = keccak256(abi.encodePacked(s_ensNode, ENS_TOKEN_SUBNAME));\n    ENSResolver_Chainlink resolver = ENSResolver_Chainlink(s_ens.resolver(linkSubnode));\n    setChainlinkToken(resolver.addr(linkSubnode));\n    updateChainlinkOracleWithENS();\n  }\n\n  /**\n   * @notice Sets the stored oracle contract with the address resolved by ENS\n   * @dev This may be called on its own as long as `useChainlinkWithENS` has been called previously\n   */\n  function updateChainlinkOracleWithENS() internal {\n    bytes32 oracleSubnode = keccak256(abi.encodePacked(s_ensNode, ENS_ORACLE_SUBNAME));\n    ENSResolver_Chainlink resolver = ENSResolver_Chainlink(s_ens.resolver(oracleSubnode));\n    setChainlinkOracle(resolver.addr(oracleSubnode));\n  }\n\n  /**\n   * @notice Ensures that the fulfillment is valid for this contract\n   * @dev Use if the contract developer prefers methods instead of modifiers for validation\n   * @param requestId The request ID for fulfillment\n   */\n  function validateChainlinkCallback(bytes32 requestId)\n    internal\n    recordChainlinkFulfillment(requestId)\n  // solhint-disable-next-line no-empty-blocks\n  {\n\n  }\n\n  /**\n   * @dev Reverts if the sender is not the oracle of the request.\n   * Emits ChainlinkFulfilled event.\n   * @param requestId The request ID for fulfillment\n   */\n  modifier recordChainlinkFulfillment(bytes32 requestId) {\n    require(msg.sender == s_pendingRequests[requestId], \"Source must be the oracle of the request\");\n    delete s_pendingRequests[requestId];\n    emit ChainlinkFulfilled(requestId);\n    _;\n  }\n\n  /**\n   * @dev Reverts if the request is already pending\n   * @param requestId The request ID for fulfillment\n   */\n  modifier notPendingRequest(bytes32 requestId) {\n    require(s_pendingRequests[requestId] == address(0), \"Request is already pending\");\n    _;\n  }\n}\n"
    },
    "src/v0.8/interfaces/ENSInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ENSInterface {\n  // Logged when the owner of a node assigns a new owner to a subnode.\n  event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\n\n  // Logged when the owner of a node transfers ownership to a new account.\n  event Transfer(bytes32 indexed node, address owner);\n\n  // Logged when the resolver for a node changes.\n  event NewResolver(bytes32 indexed node, address resolver);\n\n  // Logged when the TTL of a node changes\n  event NewTTL(bytes32 indexed node, uint64 ttl);\n\n  function setSubnodeOwner(\n    bytes32 node,\n    bytes32 label,\n    address owner\n  ) external;\n\n  function setResolver(bytes32 node, address resolver) external;\n\n  function setOwner(bytes32 node, address owner) external;\n\n  function setTTL(bytes32 node, uint64 ttl) external;\n\n  function owner(bytes32 node) external view returns (address);\n\n  function resolver(bytes32 node) external view returns (address);\n\n  function ttl(bytes32 node) external view returns (uint64);\n}\n"
    },
    "src/v0.8/interfaces/LinkTokenInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface LinkTokenInterface {\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n  function approve(address spender, uint256 value) external returns (bool success);\n\n  function balanceOf(address owner) external view returns (uint256 balance);\n\n  function decimals() external view returns (uint8 decimalPlaces);\n\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\n\n  function increaseApproval(address spender, uint256 subtractedValue) external;\n\n  function name() external view returns (string memory tokenName);\n\n  function symbol() external view returns (string memory tokenSymbol);\n\n  function totalSupply() external view returns (uint256 totalTokensIssued);\n\n  function transfer(address to, uint256 value) external returns (bool success);\n\n  function transferAndCall(\n    address to,\n    uint256 value,\n    bytes calldata data\n  ) external returns (bool success);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external returns (bool success);\n}\n"
    },
    "src/v0.8/interfaces/ChainlinkRequestInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ChainlinkRequestInterface {\n  function oracleRequest(\n    address sender,\n    uint256 requestPrice,\n    bytes32 serviceAgreementID,\n    address callbackAddress,\n    bytes4 callbackFunctionId,\n    uint256 nonce,\n    uint256 dataVersion,\n    bytes calldata data\n  ) external;\n\n  function cancelOracleRequest(\n    bytes32 requestId,\n    uint256 payment,\n    bytes4 callbackFunctionId,\n    uint256 expiration\n  ) external;\n}\n"
    },
    "src/v0.8/interfaces/OperatorInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./OracleInterface.sol\";\nimport \"./ChainlinkRequestInterface.sol\";\n\ninterface OperatorInterface is OracleInterface, ChainlinkRequestInterface {\n  function operatorRequest(\n    address sender,\n    uint256 payment,\n    bytes32 specId,\n    bytes4 callbackFunctionId,\n    uint256 nonce,\n    uint256 dataVersion,\n    bytes calldata data\n  ) external;\n\n  function fulfillOracleRequest2(\n    bytes32 requestId,\n    uint256 payment,\n    address callbackAddress,\n    bytes4 callbackFunctionId,\n    uint256 expiration,\n    bytes calldata data\n  ) external returns (bool);\n\n  function ownerTransferAndCall(\n    address to,\n    uint256 value,\n    bytes calldata data\n  ) external returns (bool success);\n\n  function distributeFunds(address payable[] calldata receivers, uint256[] calldata amounts) external payable;\n\n  function getAuthorizedSenders() external returns (address[] memory);\n\n  function setAuthorizedSenders(address[] calldata senders) external;\n\n  function getForwarder() external returns (address);\n}\n"
    },
    "src/v0.8/interfaces/PointerInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface PointerInterface {\n  function getAddress() external view returns (address);\n}\n"
    },
    "src/v0.8/vendor/ENSResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nabstract contract ENSResolver {\n  function addr(bytes32 node) public view virtual returns (address);\n}\n"
    },
    "src/v0.8/interfaces/OracleInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface OracleInterface {\n  function fulfillOracleRequest(\n    bytes32 requestId,\n    uint256 payment,\n    address callbackAddress,\n    bytes4 callbackFunctionId,\n    uint256 expiration,\n    bytes32 data\n  ) external returns (bool);\n\n  function isAuthorizedSender(address node) external view returns (bool);\n\n  function withdraw(address recipient, uint256 amount) external;\n\n  function withdrawable() external view returns (uint256);\n}\n"
    },
    "src/v0.8/tests/ChainlinkClientTestHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../ChainlinkClient.sol\";\n\ncontract ChainlinkClientTestHelper is ChainlinkClient {\n  constructor(address _link, address _oracle) {\n    setChainlinkToken(_link);\n    setChainlinkOracle(_oracle);\n  }\n\n  event Request(bytes32 id, address callbackAddress, bytes4 callbackfunctionSelector, bytes data);\n  event LinkAmount(uint256 amount);\n\n  function publicNewRequest(\n    bytes32 _id,\n    address _address,\n    bytes memory _fulfillmentSignature\n  ) public {\n    Chainlink.Request memory req = buildChainlinkRequest(_id, _address, bytes4(keccak256(_fulfillmentSignature)));\n    emit Request(req.id, req.callbackAddress, req.callbackFunctionId, req.buf.buf);\n  }\n\n  function publicRequest(\n    bytes32 _id,\n    address _address,\n    bytes memory _fulfillmentSignature,\n    uint256 _wei\n  ) public {\n    Chainlink.Request memory req = buildChainlinkRequest(_id, _address, bytes4(keccak256(_fulfillmentSignature)));\n    sendChainlinkRequest(req, _wei);\n  }\n\n  function publicRequestRunTo(\n    address _oracle,\n    bytes32 _id,\n    address _address,\n    bytes memory _fulfillmentSignature,\n    uint256 _wei\n  ) public {\n    Chainlink.Request memory run = buildChainlinkRequest(_id, _address, bytes4(keccak256(_fulfillmentSignature)));\n    sendChainlinkRequestTo(_oracle, run, _wei);\n  }\n\n  function publicRequestOracleData(\n    bytes32 _id,\n    bytes memory _fulfillmentSignature,\n    uint256 _wei\n  ) public {\n    Chainlink.Request memory req = buildOperatorRequest(_id, bytes4(keccak256(_fulfillmentSignature)));\n    sendOperatorRequest(req, _wei);\n  }\n\n  function publicRequestOracleDataFrom(\n    address _oracle,\n    bytes32 _id,\n    bytes memory _fulfillmentSignature,\n    uint256 _wei\n  ) public {\n    Chainlink.Request memory run = buildOperatorRequest(_id, bytes4(keccak256(_fulfillmentSignature)));\n    sendOperatorRequestTo(_oracle, run, _wei);\n  }\n\n  function publicCancelRequest(\n    bytes32 _requestId,\n    uint256 _payment,\n    bytes4 _callbackFunctionId,\n    uint256 _expiration\n  ) public {\n    cancelChainlinkRequest(_requestId, _payment, _callbackFunctionId, _expiration);\n  }\n\n  function publicChainlinkToken() public view returns (address) {\n    return chainlinkTokenAddress();\n  }\n\n  function publicFulfillChainlinkRequest(bytes32 _requestId, bytes32) public {\n    fulfillRequest(_requestId, bytes32(0));\n  }\n\n  function fulfillRequest(bytes32 _requestId, bytes32) public {\n    validateChainlinkCallback(_requestId);\n  }\n\n  function publicLINK(uint256 _amount) public {\n    emit LinkAmount(LINK_DIVISIBILITY * _amount);\n  }\n\n  function publicOracleAddress() public view returns (address) {\n    return chainlinkOracleAddress();\n  }\n\n  function publicAddExternalRequest(address _oracle, bytes32 _requestId) public {\n    addChainlinkExternalRequest(_oracle, _requestId);\n  }\n}\n"
    },
    "src/v0.8/tests/VRFV2RevertingExample.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../interfaces/LinkTokenInterface.sol\";\nimport \"../interfaces/VRFCoordinatorV2Interface.sol\";\nimport \"../VRFConsumerBaseV2.sol\";\n\n// VRFV2RevertingExample will always revert. Used for testing only, useless in prod.\ncontract VRFV2RevertingExample is VRFConsumerBaseV2 {\n  uint256[] public s_randomWords;\n  uint256 public s_requestId;\n  VRFCoordinatorV2Interface COORDINATOR;\n  LinkTokenInterface LINKTOKEN;\n  uint64 public s_subId;\n  uint256 public s_gasAvailable;\n\n  constructor(address vrfCoordinator, address link) VRFConsumerBaseV2(vrfCoordinator) {\n    COORDINATOR = VRFCoordinatorV2Interface(vrfCoordinator);\n    LINKTOKEN = LinkTokenInterface(link);\n  }\n\n  function fulfillRandomWords(uint256, uint256[] memory) internal override {\n    revert();\n  }\n\n  function testCreateSubscriptionAndFund(uint96 amount) external {\n    if (s_subId == 0) {\n      s_subId = COORDINATOR.createSubscription();\n      COORDINATOR.addConsumer(s_subId, address(this));\n    }\n    // Approve the link transfer.\n    LINKTOKEN.transferAndCall(address(COORDINATOR), amount, abi.encode(s_subId));\n  }\n\n  function topUpSubscription(uint96 amount) external {\n    require(s_subId != 0, \"sub not set\");\n    // Approve the link transfer.\n    LINKTOKEN.transferAndCall(address(COORDINATOR), amount, abi.encode(s_subId));\n  }\n\n  function updateSubscription(address[] memory consumers) external {\n    require(s_subId != 0, \"subID not set\");\n    for (uint256 i = 0; i < consumers.length; i++) {\n      COORDINATOR.addConsumer(s_subId, consumers[i]);\n    }\n  }\n\n  function testRequestRandomness(\n    bytes32 keyHash,\n    uint64 subId,\n    uint16 minReqConfs,\n    uint32 callbackGasLimit,\n    uint32 numWords\n  ) external returns (uint256) {\n    s_requestId = COORDINATOR.requestRandomWords(keyHash, subId, minReqConfs, callbackGasLimit, numWords);\n    return s_requestId;\n  }\n}\n"
    },
    "src/v0.8/interfaces/VRFCoordinatorV2Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface VRFCoordinatorV2Interface {\n  /**\n   * @notice Get configuration relevant for making requests\n   * @return minimumRequestConfirmations global min for request confirmations\n   * @return maxGasLimit global max for request gas limit\n   * @return s_provingKeyHashes list of registered key hashes\n   */\n  function getRequestConfig()\n    external\n    view\n    returns (\n      uint16,\n      uint32,\n      bytes32[] memory\n    );\n\n  /**\n   * @notice Request a set of random words.\n   * @param keyHash - Corresponds to a particular oracle job which uses\n   * that key for generating the VRF proof. Different keyHash's have different gas price\n   * ceilings, so you can select a specific one to bound your maximum per request cost.\n   * @param subId  - The ID of the VRF subscription. Must be funded\n   * with the minimum subscription balance required for the selected keyHash.\n   * @param minimumRequestConfirmations - How many blocks you'd like the\n   * oracle to wait before responding to the request. See SECURITY CONSIDERATIONS\n   * for why you may want to request more. The acceptable range is\n   * [minimumRequestBlockConfirmations, 200].\n   * @param callbackGasLimit - How much gas you'd like to receive in your\n   * fulfillRandomWords callback. Note that gasleft() inside fulfillRandomWords\n   * may be slightly less than this amount because of gas used calling the function\n   * (argument decoding etc.), so you may need to request slightly more than you expect\n   * to have inside fulfillRandomWords. The acceptable range is\n   * [0, maxGasLimit]\n   * @param numWords - The number of uint256 random values you'd like to receive\n   * in your fulfillRandomWords callback. Note these numbers are expanded in a\n   * secure way by the VRFCoordinator from a single random value supplied by the oracle.\n   * @return requestId - A unique identifier of the request. Can be used to match\n   * a request to a response in fulfillRandomWords.\n   */\n  function requestRandomWords(\n    bytes32 keyHash,\n    uint64 subId,\n    uint16 minimumRequestConfirmations,\n    uint32 callbackGasLimit,\n    uint32 numWords\n  ) external returns (uint256 requestId);\n\n  /**\n   * @notice Create a VRF subscription.\n   * @return subId - A unique subscription id.\n   * @dev You can manage the consumer set dynamically with addConsumer/removeConsumer.\n   * @dev Note to fund the subscription, use transferAndCall. For example\n   * @dev  LINKTOKEN.transferAndCall(\n   * @dev    address(COORDINATOR),\n   * @dev    amount,\n   * @dev    abi.encode(subId));\n   */\n  function createSubscription() external returns (uint64 subId);\n\n  /**\n   * @notice Get a VRF subscription.\n   * @param subId - ID of the subscription\n   * @return balance - LINK balance of the subscription in juels.\n   * @return reqCount - number of requests for this subscription, determines fee tier.\n   * @return owner - owner of the subscription.\n   * @return consumers - list of consumer address which are able to use this subscription.\n   */\n  function getSubscription(uint64 subId)\n    external\n    view\n    returns (\n      uint96 balance,\n      uint64 reqCount,\n      address owner,\n      address[] memory consumers\n    );\n\n  /**\n   * @notice Request subscription owner transfer.\n   * @param subId - ID of the subscription\n   * @param newOwner - proposed new owner of the subscription\n   */\n  function requestSubscriptionOwnerTransfer(uint64 subId, address newOwner) external;\n\n  /**\n   * @notice Request subscription owner transfer.\n   * @param subId - ID of the subscription\n   * @dev will revert if original owner of subId has\n   * not requested that msg.sender become the new owner.\n   */\n  function acceptSubscriptionOwnerTransfer(uint64 subId) external;\n\n  /**\n   * @notice Add a consumer to a VRF subscription.\n   * @param subId - ID of the subscription\n   * @param consumer - New consumer which can use the subscription\n   */\n  function addConsumer(uint64 subId, address consumer) external;\n\n  /**\n   * @notice Remove a consumer from a VRF subscription.\n   * @param subId - ID of the subscription\n   * @param consumer - Consumer to remove from the subscription\n   */\n  function removeConsumer(uint64 subId, address consumer) external;\n\n  /**\n   * @notice Cancel a subscription\n   * @param subId - ID of the subscription\n   * @param to - Where to send the remaining LINK to\n   */\n  function cancelSubscription(uint64 subId, address to) external;\n\n  /*\n   * @notice Check to see if there exists a request commitment consumers\n   * for all consumers and keyhashes for a given sub.\n   * @param subId - ID of the subscription\n   * @return true if there exists at least one unfulfilled request for the subscription, false\n   * otherwise.\n   */\n  function pendingRequestExists(uint64 subId) external view returns (bool);\n}\n"
    },
    "src/v0.8/VRFConsumerBaseV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/** ****************************************************************************\n * @notice Interface for contracts using VRF randomness\n * *****************************************************************************\n * @dev PURPOSE\n *\n * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\n * @dev to Vera the verifier in such a way that Vera can be sure he's not\n * @dev making his output up to suit himself. Reggie provides Vera a public key\n * @dev to which he knows the secret key. Each time Vera provides a seed to\n * @dev Reggie, he gives back a value which is computed completely\n * @dev deterministically from the seed and the secret key.\n *\n * @dev Reggie provides a proof by which Vera can verify that the output was\n * @dev correctly computed once Reggie tells it to her, but without that proof,\n * @dev the output is indistinguishable to her from a uniform random sample\n * @dev from the output space.\n *\n * @dev The purpose of this contract is to make it easy for unrelated contracts\n * @dev to talk to Vera the verifier about the work Reggie is doing, to provide\n * @dev simple access to a verifiable source of randomness. It ensures 2 things:\n * @dev 1. The fulfillment came from the VRFCoordinator\n * @dev 2. The consumer contract implements fulfillRandomWords.\n * *****************************************************************************\n * @dev USAGE\n *\n * @dev Calling contracts must inherit from VRFConsumerBase, and can\n * @dev initialize VRFConsumerBase's attributes in their constructor as\n * @dev shown:\n *\n * @dev   contract VRFConsumer {\n * @dev     constructor(<other arguments>, address _vrfCoordinator, address _link)\n * @dev       VRFConsumerBase(_vrfCoordinator) public {\n * @dev         <initialization with other arguments goes here>\n * @dev       }\n * @dev   }\n *\n * @dev The oracle will have given you an ID for the VRF keypair they have\n * @dev committed to (let's call it keyHash). Create subscription, fund it\n * @dev and your consumer contract as a consumer of it (see VRFCoordinatorInterface\n * @dev subscription management functions).\n * @dev Call requestRandomWords(keyHash, subId, minimumRequestConfirmations,\n * @dev callbackGasLimit, numWords),\n * @dev see (VRFCoordinatorInterface for a description of the arguments).\n *\n * @dev Once the VRFCoordinator has received and validated the oracle's response\n * @dev to your request, it will call your contract's fulfillRandomWords method.\n *\n * @dev The randomness argument to fulfillRandomWords is a set of random words\n * @dev generated from your requestId and the blockHash of the request.\n *\n * @dev If your contract could have concurrent requests open, you can use the\n * @dev requestId returned from requestRandomWords to track which response is associated\n * @dev with which randomness request.\n * @dev See \"SECURITY CONSIDERATIONS\" for principles to keep in mind,\n * @dev if your contract could have multiple requests in flight simultaneously.\n *\n * @dev Colliding `requestId`s are cryptographically impossible as long as seeds\n * @dev differ.\n *\n * *****************************************************************************\n * @dev SECURITY CONSIDERATIONS\n *\n * @dev A method with the ability to call your fulfillRandomness method directly\n * @dev could spoof a VRF response with any random value, so it's critical that\n * @dev it cannot be directly called by anything other than this base contract\n * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomness method).\n *\n * @dev For your users to trust that your contract's random behavior is free\n * @dev from malicious interference, it's best if you can write it so that all\n * @dev behaviors implied by a VRF response are executed *during* your\n * @dev fulfillRandomness method. If your contract must store the response (or\n * @dev anything derived from it) and use it later, you must ensure that any\n * @dev user-significant behavior which depends on that stored value cannot be\n * @dev manipulated by a subsequent VRF request.\n *\n * @dev Similarly, both miners and the VRF oracle itself have some influence\n * @dev over the order in which VRF responses appear on the blockchain, so if\n * @dev your contract could have multiple VRF requests in flight simultaneously,\n * @dev you must ensure that the order in which the VRF responses arrive cannot\n * @dev be used to manipulate your contract's user-significant behavior.\n *\n * @dev Since the block hash of the block which contains the requestRandomness\n * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful\n * @dev miner could, in principle, fork the blockchain to evict the block\n * @dev containing the request, forcing the request to be included in a\n * @dev different block with a different hash, and therefore a different input\n * @dev to the VRF. However, such an attack would incur a substantial economic\n * @dev cost. This cost scales with the number of blocks the VRF oracle waits\n * @dev until it calls responds to a request. It is for this reason that\n * @dev that you can signal to an oracle you'd like them to wait longer before\n * @dev responding to the request (however this is not enforced in the contract\n * @dev and so remains effective only in the case of unmodified oracle software).\n */\nabstract contract VRFConsumerBaseV2 {\n  error OnlyCoordinatorCanFulfill(address have, address want);\n  address private immutable vrfCoordinator;\n\n  /**\n   * @param _vrfCoordinator address of VRFCoordinator contract\n   */\n  constructor(address _vrfCoordinator) {\n    vrfCoordinator = _vrfCoordinator;\n  }\n\n  /**\n   * @notice fulfillRandomness handles the VRF response. Your contract must\n   * @notice implement it. See \"SECURITY CONSIDERATIONS\" above for important\n   * @notice principles to keep in mind when implementing your fulfillRandomness\n   * @notice method.\n   *\n   * @dev VRFConsumerBaseV2 expects its subcontracts to have a method with this\n   * @dev signature, and will call it once it has verified the proof\n   * @dev associated with the randomness. (It is triggered via a call to\n   * @dev rawFulfillRandomness, below.)\n   *\n   * @param requestId The Id initially returned by requestRandomness\n   * @param randomWords the VRF output expanded to the requested number of words\n   */\n  function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal virtual;\n\n  // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF\n  // proof. rawFulfillRandomness then calls fulfillRandomness, after validating\n  // the origin of the call\n  function rawFulfillRandomWords(uint256 requestId, uint256[] memory randomWords) external {\n    if (msg.sender != vrfCoordinator) {\n      revert OnlyCoordinatorCanFulfill(msg.sender, vrfCoordinator);\n    }\n    fulfillRandomWords(requestId, randomWords);\n  }\n}\n"
    },
    "src/v0.8/tests/VRFSingleConsumerExample.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Example of a single consumer contract which owns the subscription.\npragma solidity ^0.8.0;\n\nimport \"../interfaces/LinkTokenInterface.sol\";\nimport \"../interfaces/VRFCoordinatorV2Interface.sol\";\nimport \"../VRFConsumerBaseV2.sol\";\n\ncontract VRFSingleConsumerExample is VRFConsumerBaseV2 {\n  VRFCoordinatorV2Interface COORDINATOR;\n  LinkTokenInterface LINKTOKEN;\n\n  struct RequestConfig {\n    uint64 subId;\n    uint32 callbackGasLimit;\n    uint16 requestConfirmations;\n    uint32 numWords;\n    bytes32 keyHash;\n  }\n  RequestConfig public s_requestConfig;\n  uint256[] public s_randomWords;\n  uint256 public s_requestId;\n  address s_owner;\n\n  constructor(\n    address vrfCoordinator,\n    address link,\n    uint32 callbackGasLimit,\n    uint16 requestConfirmations,\n    uint32 numWords,\n    bytes32 keyHash\n  ) VRFConsumerBaseV2(vrfCoordinator) {\n    COORDINATOR = VRFCoordinatorV2Interface(vrfCoordinator);\n    LINKTOKEN = LinkTokenInterface(link);\n    s_owner = msg.sender;\n    s_requestConfig = RequestConfig({\n      subId: 0, // Unset initially\n      callbackGasLimit: callbackGasLimit,\n      requestConfirmations: requestConfirmations,\n      numWords: numWords,\n      keyHash: keyHash\n    });\n    subscribe();\n  }\n\n  function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal override {\n    require(requestId == s_requestId, \"request ID is incorrect\");\n    s_randomWords = randomWords;\n  }\n\n  // Assumes the subscription is funded sufficiently.\n  function requestRandomWords() external onlyOwner {\n    RequestConfig memory rc = s_requestConfig;\n    // Will revert if subscription is not set and funded.\n    s_requestId = COORDINATOR.requestRandomWords(\n      rc.keyHash,\n      rc.subId,\n      rc.requestConfirmations,\n      rc.callbackGasLimit,\n      rc.numWords\n    );\n  }\n\n  // Assumes this contract owns link\n  // This method is analogous to VRFv1, except the amount\n  // should be selected based on the keyHash (each keyHash functions like a \"gas lane\"\n  // with different link costs).\n  function fundAndRequestRandomWords(uint256 amount) external onlyOwner {\n    RequestConfig memory rc = s_requestConfig;\n    LINKTOKEN.transferAndCall(address(COORDINATOR), amount, abi.encode(s_requestConfig.subId));\n    // Will revert if subscription is not set and funded.\n    s_requestId = COORDINATOR.requestRandomWords(\n      rc.keyHash,\n      rc.subId,\n      rc.requestConfirmations,\n      rc.callbackGasLimit,\n      rc.numWords\n    );\n  }\n\n  // Assumes this contract owns link\n  function topUpSubscription(uint256 amount) external onlyOwner {\n    LINKTOKEN.transferAndCall(address(COORDINATOR), amount, abi.encode(s_requestConfig.subId));\n  }\n\n  function withdraw(uint256 amount, address to) external onlyOwner {\n    LINKTOKEN.transfer(to, amount);\n  }\n\n  function unsubscribe(address to) external onlyOwner {\n    // Returns funds to this address\n    COORDINATOR.cancelSubscription(s_requestConfig.subId, to);\n    s_requestConfig.subId = 0;\n  }\n\n  // Keep this separate in case the contract want to unsubscribe and then\n  // resubscribe.\n  function subscribe() public onlyOwner {\n    // Create a subscription, current subId\n    address[] memory consumers = new address[](1);\n    consumers[0] = address(this);\n    s_requestConfig.subId = COORDINATOR.createSubscription();\n    COORDINATOR.addConsumer(s_requestConfig.subId, consumers[0]);\n  }\n\n  modifier onlyOwner() {\n    require(msg.sender == s_owner);\n    _;\n  }\n}\n"
    },
    "src/v0.8/tests/VRFMaliciousConsumerV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../interfaces/LinkTokenInterface.sol\";\nimport \"../interfaces/VRFCoordinatorV2Interface.sol\";\nimport \"../VRFConsumerBaseV2.sol\";\n\ncontract VRFMaliciousConsumerV2 is VRFConsumerBaseV2 {\n  uint256[] public s_randomWords;\n  uint256 public s_requestId;\n  VRFCoordinatorV2Interface COORDINATOR;\n  LinkTokenInterface LINKTOKEN;\n  uint64 public s_subId;\n  uint256 public s_gasAvailable;\n  bytes32 s_keyHash;\n\n  constructor(address vrfCoordinator, address link) VRFConsumerBaseV2(vrfCoordinator) {\n    COORDINATOR = VRFCoordinatorV2Interface(vrfCoordinator);\n    LINKTOKEN = LinkTokenInterface(link);\n  }\n\n  function setKeyHash(bytes32 keyHash) public {\n    s_keyHash = keyHash;\n  }\n\n  function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal override {\n    s_gasAvailable = gasleft();\n    s_randomWords = randomWords;\n    s_requestId = requestId;\n    // Should revert\n    COORDINATOR.requestRandomWords(s_keyHash, s_subId, 1, 200000, 1);\n  }\n\n  function testCreateSubscriptionAndFund(uint96 amount) external {\n    if (s_subId == 0) {\n      s_subId = COORDINATOR.createSubscription();\n      COORDINATOR.addConsumer(s_subId, address(this));\n    }\n    // Approve the link transfer.\n    LINKTOKEN.transferAndCall(address(COORDINATOR), amount, abi.encode(s_subId));\n  }\n\n  function updateSubscription(address[] memory consumers) external {\n    require(s_subId != 0, \"subID not set\");\n    for (uint256 i = 0; i < consumers.length; i++) {\n      COORDINATOR.addConsumer(s_subId, consumers[i]);\n    }\n  }\n\n  function testRequestRandomness() external returns (uint256) {\n    return COORDINATOR.requestRandomWords(s_keyHash, s_subId, 1, 500000, 1);\n  }\n}\n"
    },
    "src/v0.8/tests/VRFLoadTestExternalSubOwner.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../interfaces/LinkTokenInterface.sol\";\nimport \"../interfaces/VRFCoordinatorV2Interface.sol\";\nimport \"../VRFConsumerBaseV2.sol\";\nimport \"../ConfirmedOwner.sol\";\n\n/**\n * @title The VRFLoadTestExternalSubOwner contract.\n * @notice Allows making many VRF V2 randomness requests in a single transaction for load testing.\n */\ncontract VRFLoadTestExternalSubOwner is VRFConsumerBaseV2, ConfirmedOwner {\n  VRFCoordinatorV2Interface public immutable COORDINATOR;\n  LinkTokenInterface public immutable LINK;\n\n  uint256 public s_responseCount;\n\n  constructor(address _vrfCoordinator, address _link) VRFConsumerBaseV2(_vrfCoordinator) ConfirmedOwner(msg.sender) {\n    COORDINATOR = VRFCoordinatorV2Interface(_vrfCoordinator);\n    LINK = LinkTokenInterface(_link);\n  }\n\n  function fulfillRandomWords(uint256, uint256[] memory) internal override {\n    s_responseCount++;\n  }\n\n  function requestRandomWords(\n    uint64 _subId,\n    uint16 _requestConfirmations,\n    bytes32 _keyHash,\n    uint16 _requestCount\n  ) external onlyOwner {\n    for (uint16 i = 0; i < _requestCount; i++) {\n      COORDINATOR.requestRandomWords(_keyHash, _subId, _requestConfirmations, 50_000, 1);\n    }\n  }\n}\n"
    },
    "src/v0.8/ConfirmedOwner.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./ConfirmedOwnerWithProposal.sol\";\n\n/**\n * @title The ConfirmedOwner contract\n * @notice A contract with helpers for basic contract ownership.\n */\ncontract ConfirmedOwner is ConfirmedOwnerWithProposal {\n  constructor(address newOwner) ConfirmedOwnerWithProposal(newOwner, address(0)) {}\n}\n"
    },
    "src/v0.8/ConfirmedOwnerWithProposal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./interfaces/OwnableInterface.sol\";\n\n/**\n * @title The ConfirmedOwner contract\n * @notice A contract with helpers for basic contract ownership.\n */\ncontract ConfirmedOwnerWithProposal is OwnableInterface {\n  address private s_owner;\n  address private s_pendingOwner;\n\n  event OwnershipTransferRequested(address indexed from, address indexed to);\n  event OwnershipTransferred(address indexed from, address indexed to);\n\n  constructor(address newOwner, address pendingOwner) {\n    require(newOwner != address(0), \"Cannot set owner to zero\");\n\n    s_owner = newOwner;\n    if (pendingOwner != address(0)) {\n      _transferOwnership(pendingOwner);\n    }\n  }\n\n  /**\n   * @notice Allows an owner to begin transferring ownership to a new address,\n   * pending.\n   */\n  function transferOwnership(address to) public override onlyOwner {\n    _transferOwnership(to);\n  }\n\n  /**\n   * @notice Allows an ownership transfer to be completed by the recipient.\n   */\n  function acceptOwnership() external override {\n    require(msg.sender == s_pendingOwner, \"Must be proposed owner\");\n\n    address oldOwner = s_owner;\n    s_owner = msg.sender;\n    s_pendingOwner = address(0);\n\n    emit OwnershipTransferred(oldOwner, msg.sender);\n  }\n\n  /**\n   * @notice Get the current owner\n   */\n  function owner() public view override returns (address) {\n    return s_owner;\n  }\n\n  /**\n   * @notice validate, transfer ownership, and emit relevant events\n   */\n  function _transferOwnership(address to) private {\n    require(to != msg.sender, \"Cannot transfer to self\");\n\n    s_pendingOwner = to;\n\n    emit OwnershipTransferRequested(s_owner, to);\n  }\n\n  /**\n   * @notice validate access\n   */\n  function _validateOwnership() internal view {\n    require(msg.sender == s_owner, \"Only callable by owner\");\n  }\n\n  /**\n   * @notice Reverts if called by anyone other than the contract owner.\n   */\n  modifier onlyOwner() {\n    _validateOwnership();\n    _;\n  }\n}\n"
    },
    "src/v0.8/interfaces/OwnableInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface OwnableInterface {\n  function owner() external returns (address);\n\n  function transferOwnership(address recipient) external;\n\n  function acceptOwnership() external;\n}\n"
    },
    "src/v0.8/ValidatorProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./ConfirmedOwner.sol\";\nimport \"./interfaces/AggregatorValidatorInterface.sol\";\nimport \"./interfaces/TypeAndVersionInterface.sol\";\n\ncontract ValidatorProxy is AggregatorValidatorInterface, TypeAndVersionInterface, ConfirmedOwner {\n  /// @notice Uses a single storage slot to store the current address\n  struct AggregatorConfiguration {\n    address target;\n    bool hasNewProposal;\n  }\n\n  struct ValidatorConfiguration {\n    AggregatorValidatorInterface target;\n    bool hasNewProposal;\n  }\n\n  // Configuration for the current aggregator\n  AggregatorConfiguration private s_currentAggregator;\n  // Proposed aggregator address\n  address private s_proposedAggregator;\n\n  // Configuration for the current validator\n  ValidatorConfiguration private s_currentValidator;\n  // Proposed validator address\n  AggregatorValidatorInterface private s_proposedValidator;\n\n  event AggregatorProposed(address indexed aggregator);\n  event AggregatorUpgraded(address indexed previous, address indexed current);\n  event ValidatorProposed(AggregatorValidatorInterface indexed validator);\n  event ValidatorUpgraded(AggregatorValidatorInterface indexed previous, AggregatorValidatorInterface indexed current);\n  /// @notice The proposed aggregator called validate, but the call was not passed on to any validators\n  event ProposedAggregatorValidateCall(\n    address indexed proposed,\n    uint256 previousRoundId,\n    int256 previousAnswer,\n    uint256 currentRoundId,\n    int256 currentAnswer\n  );\n\n  /**\n   * @notice Construct the ValidatorProxy with an aggregator and a validator\n   * @param aggregator address\n   * @param validator address\n   */\n  constructor(address aggregator, AggregatorValidatorInterface validator) ConfirmedOwner(msg.sender) {\n    s_currentAggregator = AggregatorConfiguration({target: aggregator, hasNewProposal: false});\n    s_currentValidator = ValidatorConfiguration({target: validator, hasNewProposal: false});\n  }\n\n  /**\n   * @notice Validate a transmission\n   * @dev Must be called by either the `s_currentAggregator.target`, or the `s_proposedAggregator`.\n   * If called by the `s_currentAggregator.target` this function passes the call on to the `s_currentValidator.target`\n   * and the `s_proposedValidator`, if it is set.\n   * If called by the `s_proposedAggregator` this function emits a `ProposedAggregatorValidateCall` to signal that\n   * the call was received.\n   * @dev To guard against external `validate` calls reverting, we use raw calls here.\n   * We favour `call` over try-catch to ensure that failures are avoided even if the validator address is incorrectly\n   * set as a non-contract address.\n   * @dev If the `aggregator` and `validator` are the same contract or collude, this could exhibit reentrancy behavior.\n   * However, since that contract would have to be explicitly written for reentrancy and that the `owner` would have\n   * to configure this contract to use that malicious contract, we refrain from using mutex or check here.\n   * @dev This does not perform any checks on any roundId, so it is possible that a validator receive different reports\n   * for the same roundId at different points in time. Validator implementations should be aware of this.\n   * @param previousRoundId uint256\n   * @param previousAnswer int256\n   * @param currentRoundId uint256\n   * @param currentAnswer int256\n   * @return bool\n   */\n  function validate(\n    uint256 previousRoundId,\n    int256 previousAnswer,\n    uint256 currentRoundId,\n    int256 currentAnswer\n  ) external override returns (bool) {\n    address currentAggregator = s_currentAggregator.target;\n    if (msg.sender != currentAggregator) {\n      address proposedAggregator = s_proposedAggregator;\n      require(msg.sender == proposedAggregator, \"Not a configured aggregator\");\n      // If the aggregator is still in proposed state, emit an event and don't push to any validator.\n      // This is to confirm that `validate` is being called prior to upgrade.\n      emit ProposedAggregatorValidateCall(\n        proposedAggregator,\n        previousRoundId,\n        previousAnswer,\n        currentRoundId,\n        currentAnswer\n      );\n      return true;\n    }\n\n    // Send the validate call to the current validator\n    ValidatorConfiguration memory currentValidator = s_currentValidator;\n    address currentValidatorAddress = address(currentValidator.target);\n    require(currentValidatorAddress != address(0), \"No validator set\");\n    currentValidatorAddress.call(\n      abi.encodeWithSelector(\n        AggregatorValidatorInterface.validate.selector,\n        previousRoundId,\n        previousAnswer,\n        currentRoundId,\n        currentAnswer\n      )\n    );\n    // If there is a new proposed validator, send the validate call to that validator also\n    if (currentValidator.hasNewProposal) {\n      address(s_proposedValidator).call(\n        abi.encodeWithSelector(\n          AggregatorValidatorInterface.validate.selector,\n          previousRoundId,\n          previousAnswer,\n          currentRoundId,\n          currentAnswer\n        )\n      );\n    }\n    return true;\n  }\n\n  /** AGGREGATOR CONFIGURATION FUNCTIONS **/\n\n  /**\n   * @notice Propose an aggregator\n   * @dev A zero address can be used to unset the proposed aggregator. Only owner can call.\n   * @param proposed address\n   */\n  function proposeNewAggregator(address proposed) external onlyOwner {\n    require(s_proposedAggregator != proposed && s_currentAggregator.target != proposed, \"Invalid proposal\");\n    s_proposedAggregator = proposed;\n    // If proposed is zero address, hasNewProposal = false\n    s_currentAggregator.hasNewProposal = (proposed != address(0));\n    emit AggregatorProposed(proposed);\n  }\n\n  /**\n   * @notice Upgrade the aggregator by setting the current aggregator as the proposed aggregator.\n   * @dev Must have a proposed aggregator. Only owner can call.\n   */\n  function upgradeAggregator() external onlyOwner {\n    // Get configuration in memory\n    AggregatorConfiguration memory current = s_currentAggregator;\n    address previous = current.target;\n    address proposed = s_proposedAggregator;\n\n    // Perform the upgrade\n    require(current.hasNewProposal, \"No proposal\");\n    s_currentAggregator = AggregatorConfiguration({target: proposed, hasNewProposal: false});\n    delete s_proposedAggregator;\n\n    emit AggregatorUpgraded(previous, proposed);\n  }\n\n  /**\n   * @notice Get aggregator details\n   * @return current address\n   * @return hasProposal bool\n   * @return proposed address\n   */\n  function getAggregators()\n    external\n    view\n    returns (\n      address current,\n      bool hasProposal,\n      address proposed\n    )\n  {\n    current = s_currentAggregator.target;\n    hasProposal = s_currentAggregator.hasNewProposal;\n    proposed = s_proposedAggregator;\n  }\n\n  /** VALIDATOR CONFIGURATION FUNCTIONS **/\n\n  /**\n   * @notice Propose an validator\n   * @dev A zero address can be used to unset the proposed validator. Only owner can call.\n   * @param proposed address\n   */\n  function proposeNewValidator(AggregatorValidatorInterface proposed) external onlyOwner {\n    require(s_proposedValidator != proposed && s_currentValidator.target != proposed, \"Invalid proposal\");\n    s_proposedValidator = proposed;\n    // If proposed is zero address, hasNewProposal = false\n    s_currentValidator.hasNewProposal = (address(proposed) != address(0));\n    emit ValidatorProposed(proposed);\n  }\n\n  /**\n   * @notice Upgrade the validator by setting the current validator as the proposed validator.\n   * @dev Must have a proposed validator. Only owner can call.\n   */\n  function upgradeValidator() external onlyOwner {\n    // Get configuration in memory\n    ValidatorConfiguration memory current = s_currentValidator;\n    AggregatorValidatorInterface previous = current.target;\n    AggregatorValidatorInterface proposed = s_proposedValidator;\n\n    // Perform the upgrade\n    require(current.hasNewProposal, \"No proposal\");\n    s_currentValidator = ValidatorConfiguration({target: proposed, hasNewProposal: false});\n    delete s_proposedValidator;\n\n    emit ValidatorUpgraded(previous, proposed);\n  }\n\n  /**\n   * @notice Get validator details\n   * @return current address\n   * @return hasProposal bool\n   * @return proposed address\n   */\n  function getValidators()\n    external\n    view\n    returns (\n      AggregatorValidatorInterface current,\n      bool hasProposal,\n      AggregatorValidatorInterface proposed\n    )\n  {\n    current = s_currentValidator.target;\n    hasProposal = s_currentValidator.hasNewProposal;\n    proposed = s_proposedValidator;\n  }\n\n  /**\n   * @notice The type and version of this contract\n   * @return Type and version string\n   */\n  function typeAndVersion() external pure virtual override returns (string memory) {\n    return \"ValidatorProxy 1.0.0\";\n  }\n}\n"
    },
    "src/v0.8/interfaces/AggregatorValidatorInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorValidatorInterface {\n  function validate(\n    uint256 previousRoundId,\n    int256 previousAnswer,\n    uint256 currentRoundId,\n    int256 currentAnswer\n  ) external returns (bool);\n}\n"
    },
    "src/v0.8/interfaces/TypeAndVersionInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nabstract contract TypeAndVersionInterface {\n  function typeAndVersion() external pure virtual returns (string memory);\n}\n"
    },
    "src/v0.8/UpkeepTranscoder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./interfaces/UpkeepTranscoderInterface.sol\";\nimport \"./interfaces/TypeAndVersionInterface.sol\";\n\n/**\n * @notice Transcoder for converting upkeep data from one keeper\n * registry version to another\n */\ncontract UpkeepTranscoder is UpkeepTranscoderInterface, TypeAndVersionInterface {\n  error InvalidTranscoding();\n\n  /**\n   * @notice versions:\n   * - UpkeepTranscoder 1.0.0: placeholder to allow new formats in the future\n   */\n  string public constant override typeAndVersion = \"UpkeepTranscoder 1.0.0\";\n\n  /**\n   * @notice transcodeUpkeeps transforms upkeep data from the format expected by\n   * one registry to the format expected by another. It future-proofs migrations\n   * by allowing keepers team to customize migration paths and set sensible defaults\n   * when new fields are added\n   * @param fromVersion struct version the upkeep is migrating from\n   * @param toVersion struct version the upkeep is migrating to\n   * @param encodedUpkeeps encoded upkeep data\n   * @dev this contract & function are simple now, but should evolve as new registries\n   * and migration paths are added\n   */\n  function transcodeUpkeeps(\n    UpkeepFormat fromVersion,\n    UpkeepFormat toVersion,\n    bytes calldata encodedUpkeeps\n  ) external view override returns (bytes memory) {\n    if (fromVersion != UpkeepFormat.V1 || toVersion != UpkeepFormat.V1) {\n      revert InvalidTranscoding();\n    }\n\n    return encodedUpkeeps;\n  }\n}\n"
    },
    "src/v0.8/interfaces/UpkeepTranscoderInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\nimport \"../UpkeepFormat.sol\";\n\npragma solidity ^0.8.0;\n\ninterface UpkeepTranscoderInterface {\n  function transcodeUpkeeps(\n    UpkeepFormat fromVersion,\n    UpkeepFormat toVersion,\n    bytes calldata encodedUpkeeps\n  ) external view returns (bytes memory);\n}\n"
    },
    "src/v0.8/UpkeepFormat.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nenum UpkeepFormat {\n  V1\n}\n"
    },
    "src/v0.8/KeeperRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"./KeeperBase.sol\";\nimport \"./ConfirmedOwner.sol\";\nimport \"./interfaces/TypeAndVersionInterface.sol\";\nimport \"./interfaces/AggregatorV3Interface.sol\";\nimport \"./interfaces/LinkTokenInterface.sol\";\nimport \"./interfaces/KeeperCompatibleInterface.sol\";\nimport \"./interfaces/KeeperRegistryInterface.sol\";\nimport \"./interfaces/MigratableKeeperRegistryInterface.sol\";\nimport \"./interfaces/UpkeepTranscoderInterface.sol\";\nimport \"./interfaces/ERC677ReceiverInterface.sol\";\n\n/**\n * @notice Registry for adding work for Chainlink Keepers to perform on client\n * contracts. Clients must support the Upkeep interface.\n */\ncontract KeeperRegistry is\n  TypeAndVersionInterface,\n  ConfirmedOwner,\n  KeeperBase,\n  ReentrancyGuard,\n  Pausable,\n  KeeperRegistryExecutableInterface,\n  MigratableKeeperRegistryInterface,\n  ERC677ReceiverInterface\n{\n  using Address for address;\n  using EnumerableSet for EnumerableSet.UintSet;\n\n  address private constant ZERO_ADDRESS = address(0);\n  address private constant IGNORE_ADDRESS = 0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF;\n  bytes4 private constant CHECK_SELECTOR = KeeperCompatibleInterface.checkUpkeep.selector;\n  bytes4 private constant PERFORM_SELECTOR = KeeperCompatibleInterface.performUpkeep.selector;\n  uint256 private constant PERFORM_GAS_MIN = 2_300;\n  uint256 private constant CANCELATION_DELAY = 50;\n  uint256 private constant PERFORM_GAS_CUSHION = 5_000;\n  uint256 private constant REGISTRY_GAS_OVERHEAD = 80_000;\n  uint256 private constant PPB_BASE = 1_000_000_000;\n  uint64 private constant UINT64_MAX = 2**64 - 1;\n  uint96 private constant LINK_TOTAL_SUPPLY = 1e27;\n\n  address[] private s_keeperList;\n  EnumerableSet.UintSet private s_upkeepIDs;\n  mapping(uint256 => Upkeep) private s_upkeep;\n  mapping(address => KeeperInfo) private s_keeperInfo;\n  mapping(address => address) private s_proposedPayee;\n  mapping(uint256 => bytes) private s_checkData;\n  mapping(address => MigrationPermission) private s_peerRegistryMigrationPermission;\n  Storage private s_storage;\n  uint256 private s_fallbackGasPrice; // not in config object for gas savings\n  uint256 private s_fallbackLinkPrice; // not in config object for gas savings\n  uint96 private s_ownerLinkBalance;\n  uint256 private s_expectedLinkBalance;\n  address private s_transcoder;\n  address private s_registrar;\n\n  LinkTokenInterface public immutable LINK;\n  AggregatorV3Interface public immutable LINK_ETH_FEED;\n  AggregatorV3Interface public immutable FAST_GAS_FEED;\n\n  /**\n   * @notice versions:\n   * - KeeperRegistry 1.2.0: allow funding within performUpkeep\n   *                       : allow configurable registry maxPerformGas\n   *                       : add function to let admin change upkeep gas limit\n   *                       : add minUpkeepSpend requirement\n                           : upgrade to solidity v0.8\n   * - KeeperRegistry 1.1.0: added flatFeeMicroLink\n   * - KeeperRegistry 1.0.0: initial release\n   */\n  string public constant override typeAndVersion = \"KeeperRegistry 1.2.0\";\n\n  error CannotCancel();\n  error UpkeepNotActive();\n  error MigrationNotPermitted();\n  error UpkeepNotCanceled();\n  error UpkeepNotNeeded();\n  error NotAContract();\n  error PaymentGreaterThanAllLINK();\n  error OnlyActiveKeepers();\n  error InsufficientFunds();\n  error KeepersMustTakeTurns();\n  error ParameterLengthError();\n  error OnlyCallableByOwnerOrAdmin();\n  error OnlyCallableByLINKToken();\n  error InvalidPayee();\n  error DuplicateEntry();\n  error ValueNotChanged();\n  error IndexOutOfRange();\n  error TranscoderNotSet();\n  error ArrayHasNoEntries();\n  error GasLimitOutsideRange();\n  error OnlyCallableByPayee();\n  error OnlyCallableByProposedPayee();\n  error GasLimitCanOnlyIncrease();\n  error OnlyCallableByAdmin();\n  error OnlyCallableByOwnerOrRegistrar();\n  error InvalidRecipient();\n  error InvalidDataLength();\n  error TargetCheckReverted(bytes reason);\n\n  enum MigrationPermission {\n    NONE,\n    OUTGOING,\n    INCOMING,\n    BIDIRECTIONAL\n  }\n\n  /**\n   * @notice storage of the registry, contains a mix of config and state data\n   */\n  struct Storage {\n    uint32 paymentPremiumPPB;\n    uint32 flatFeeMicroLink;\n    uint24 blockCountPerTurn;\n    uint32 checkGasLimit;\n    uint24 stalenessSeconds;\n    uint16 gasCeilingMultiplier;\n    uint96 minUpkeepSpend; // 1 evm word\n    uint32 maxPerformGas;\n    uint32 nonce; // 2 evm words\n  }\n\n  struct Upkeep {\n    uint96 balance;\n    address lastKeeper; // 1 storage slot full\n    uint32 executeGas;\n    uint64 maxValidBlocknumber;\n    address target; // 2 storage slots full\n    uint96 amountSpent;\n    address admin; // 3 storage slots full\n  }\n\n  struct KeeperInfo {\n    address payee;\n    uint96 balance;\n    bool active;\n  }\n\n  struct PerformParams {\n    address from;\n    uint256 id;\n    bytes performData;\n    uint256 maxLinkPayment;\n    uint256 gasLimit;\n    uint256 adjustedGasWei;\n    uint256 linkEth;\n  }\n\n  event UpkeepRegistered(uint256 indexed id, uint32 executeGas, address admin);\n  event UpkeepPerformed(\n    uint256 indexed id,\n    bool indexed success,\n    address indexed from,\n    uint96 payment,\n    bytes performData\n  );\n  event UpkeepCanceled(uint256 indexed id, uint64 indexed atBlockHeight);\n  event FundsAdded(uint256 indexed id, address indexed from, uint96 amount);\n  event FundsWithdrawn(uint256 indexed id, uint256 amount, address to);\n  event OwnerFundsWithdrawn(uint96 amount);\n  event UpkeepMigrated(uint256 indexed id, uint256 remainingBalance, address destination);\n  event UpkeepReceived(uint256 indexed id, uint256 startingBalance, address importedFrom);\n  event ConfigSet(Config config);\n  event KeepersUpdated(address[] keepers, address[] payees);\n  event PaymentWithdrawn(address indexed keeper, uint256 indexed amount, address indexed to, address payee);\n  event PayeeshipTransferRequested(address indexed keeper, address indexed from, address indexed to);\n  event PayeeshipTransferred(address indexed keeper, address indexed from, address indexed to);\n  event UpkeepGasLimitSet(uint256 indexed id, uint96 gasLimit);\n\n  /**\n   * @param link address of the LINK Token\n   * @param linkEthFeed address of the LINK/ETH price feed\n   * @param fastGasFeed address of the Fast Gas price feed\n   * @param config registry config settings\n   */\n  constructor(\n    address link,\n    address linkEthFeed,\n    address fastGasFeed,\n    Config memory config\n  ) ConfirmedOwner(msg.sender) {\n    LINK = LinkTokenInterface(link);\n    LINK_ETH_FEED = AggregatorV3Interface(linkEthFeed);\n    FAST_GAS_FEED = AggregatorV3Interface(fastGasFeed);\n    setConfig(config);\n  }\n\n  // ACTIONS\n\n  /**\n   * @notice adds a new upkeep\n   * @param target address to perform upkeep on\n   * @param gasLimit amount of gas to provide the target contract when\n   * performing upkeep\n   * @param admin address to cancel upkeep and withdraw remaining funds\n   * @param checkData data passed to the contract when checking for upkeep\n   */\n  function registerUpkeep(\n    address target,\n    uint32 gasLimit,\n    address admin,\n    bytes calldata checkData\n  ) external override onlyOwnerOrRegistrar returns (uint256 id) {\n    id = uint256(keccak256(abi.encodePacked(blockhash(block.number - 1), address(this), s_storage.nonce)));\n    _createUpkeep(id, target, gasLimit, admin, 0, checkData);\n    s_storage.nonce++;\n    emit UpkeepRegistered(id, gasLimit, admin);\n    return id;\n  }\n\n  /**\n   * @notice simulated by keepers via eth_call to see if the upkeep needs to be\n   * performed. If upkeep is needed, the call then simulates performUpkeep\n   * to make sure it succeeds. Finally, it returns the success status along with\n   * payment information and the perform data payload.\n   * @param id identifier of the upkeep to check\n   * @param from the address to simulate performing the upkeep from\n   */\n  function checkUpkeep(uint256 id, address from)\n    external\n    override\n    cannotExecute\n    returns (\n      bytes memory performData,\n      uint256 maxLinkPayment,\n      uint256 gasLimit,\n      uint256 adjustedGasWei,\n      uint256 linkEth\n    )\n  {\n    Upkeep memory upkeep = s_upkeep[id];\n\n    bytes memory callData = abi.encodeWithSelector(CHECK_SELECTOR, s_checkData[id]);\n    (bool success, bytes memory result) = upkeep.target.call{gas: s_storage.checkGasLimit}(callData);\n\n    if (!success) revert TargetCheckReverted(result);\n\n    (success, performData) = abi.decode(result, (bool, bytes));\n    if (!success) revert UpkeepNotNeeded();\n\n    PerformParams memory params = _generatePerformParams(from, id, performData, false);\n    _prePerformUpkeep(upkeep, params.from, params.maxLinkPayment);\n\n    return (performData, params.maxLinkPayment, params.gasLimit, params.adjustedGasWei, params.linkEth);\n  }\n\n  /**\n   * @notice executes the upkeep with the perform data returned from\n   * checkUpkeep, validates the keeper's permissions, and pays the keeper.\n   * @param id identifier of the upkeep to execute the data with.\n   * @param performData calldata parameter to be passed to the target upkeep.\n   */\n  function performUpkeep(uint256 id, bytes calldata performData)\n    external\n    override\n    whenNotPaused\n    returns (bool success)\n  {\n    return _performUpkeepWithParams(_generatePerformParams(msg.sender, id, performData, true));\n  }\n\n  /**\n   * @notice prevent an upkeep from being performed in the future\n   * @param id upkeep to be canceled\n   */\n  function cancelUpkeep(uint256 id) external override {\n    uint64 maxValid = s_upkeep[id].maxValidBlocknumber;\n    bool canceled = maxValid != UINT64_MAX;\n    bool isOwner = msg.sender == owner();\n\n    if (canceled && !(isOwner && maxValid > block.number)) revert CannotCancel();\n    if (!isOwner && msg.sender != s_upkeep[id].admin) revert OnlyCallableByOwnerOrAdmin();\n\n    uint256 height = block.number;\n    if (!isOwner) {\n      height = height + CANCELATION_DELAY;\n    }\n    s_upkeep[id].maxValidBlocknumber = uint64(height);\n    s_upkeepIDs.remove(id);\n\n    emit UpkeepCanceled(id, uint64(height));\n  }\n\n  /**\n   * @notice adds LINK funding for an upkeep by transferring from the sender's\n   * LINK balance\n   * @param id upkeep to fund\n   * @param amount number of LINK to transfer\n   */\n  function addFunds(uint256 id, uint96 amount) external override onlyActiveUpkeep(id) {\n    s_upkeep[id].balance = s_upkeep[id].balance + amount;\n    s_expectedLinkBalance = s_expectedLinkBalance + amount;\n    LINK.transferFrom(msg.sender, address(this), amount);\n    emit FundsAdded(id, msg.sender, amount);\n  }\n\n  /**\n   * @notice uses LINK's transferAndCall to LINK and add funding to an upkeep\n   * @dev safe to cast uint256 to uint96 as total LINK supply is under UINT96MAX\n   * @param sender the account which transferred the funds\n   * @param amount number of LINK transfer\n   */\n  function onTokenTransfer(\n    address sender,\n    uint256 amount,\n    bytes calldata data\n  ) external {\n    if (msg.sender != address(LINK)) revert OnlyCallableByLINKToken();\n    if (data.length != 32) revert InvalidDataLength();\n    uint256 id = abi.decode(data, (uint256));\n    if (s_upkeep[id].maxValidBlocknumber != UINT64_MAX) revert UpkeepNotActive();\n\n    s_upkeep[id].balance = s_upkeep[id].balance + uint96(amount);\n    s_expectedLinkBalance = s_expectedLinkBalance + amount;\n\n    emit FundsAdded(id, sender, uint96(amount));\n  }\n\n  /**\n   * @notice removes funding from a canceled upkeep\n   * @param id upkeep to withdraw funds from\n   * @param to destination address for sending remaining funds\n   */\n  function withdrawFunds(uint256 id, address to) external validRecipient(to) onlyUpkeepAdmin(id) {\n    if (s_upkeep[id].maxValidBlocknumber > block.number) revert UpkeepNotCanceled();\n\n    uint96 minUpkeepSpend = s_storage.minUpkeepSpend;\n    uint96 amountLeft = s_upkeep[id].balance;\n    uint96 amountSpent = s_upkeep[id].amountSpent;\n\n    uint96 cancellationFee = 0;\n    // cancellationFee is supposed to be min(max(minUpkeepSpend - amountSpent,0), amountLeft)\n    if (amountSpent < minUpkeepSpend) {\n      cancellationFee = minUpkeepSpend - amountSpent;\n      if (cancellationFee > amountLeft) {\n        cancellationFee = amountLeft;\n      }\n    }\n    uint96 amountToWithdraw = amountLeft - cancellationFee;\n\n    s_upkeep[id].balance = 0;\n    s_ownerLinkBalance = s_ownerLinkBalance + cancellationFee;\n\n    s_expectedLinkBalance = s_expectedLinkBalance - amountToWithdraw;\n    emit FundsWithdrawn(id, amountToWithdraw, to);\n\n    LINK.transfer(to, amountToWithdraw);\n  }\n\n  /**\n   * @notice withdraws LINK funds collected through cancellation fees\n   */\n  function withdrawOwnerFunds() external onlyOwner {\n    uint96 amount = s_ownerLinkBalance;\n\n    s_expectedLinkBalance = s_expectedLinkBalance - amount;\n    s_ownerLinkBalance = 0;\n\n    emit OwnerFundsWithdrawn(amount);\n    LINK.transfer(msg.sender, amount);\n  }\n\n  /**\n   * @notice allows the admin of an upkeep to modify gas limit\n   * @param id upkeep to be change the gas limit for\n   * @param gasLimit new gas limit for the upkeep\n   */\n  function setUpkeepGasLimit(uint256 id, uint32 gasLimit) external override onlyActiveUpkeep(id) onlyUpkeepAdmin(id) {\n    if (gasLimit < PERFORM_GAS_MIN || gasLimit > s_storage.maxPerformGas) revert GasLimitOutsideRange();\n\n    s_upkeep[id].executeGas = gasLimit;\n\n    emit UpkeepGasLimitSet(id, gasLimit);\n  }\n\n  /**\n   * @notice recovers LINK funds improperly transferred to the registry\n   * @dev In principle this function’s execution cost could exceed block\n   * gas limit. However, in our anticipated deployment, the number of upkeeps and\n   * keepers will be low enough to avoid this problem.\n   */\n  function recoverFunds() external onlyOwner {\n    uint256 total = LINK.balanceOf(address(this));\n    LINK.transfer(msg.sender, total - s_expectedLinkBalance);\n  }\n\n  /**\n   * @notice withdraws a keeper's payment, callable only by the keeper's payee\n   * @param from keeper address\n   * @param to address to send the payment to\n   */\n  function withdrawPayment(address from, address to) external validRecipient(to) {\n    KeeperInfo memory keeper = s_keeperInfo[from];\n    if (keeper.payee != msg.sender) revert OnlyCallableByPayee();\n\n    s_keeperInfo[from].balance = 0;\n    s_expectedLinkBalance = s_expectedLinkBalance - keeper.balance;\n    emit PaymentWithdrawn(from, keeper.balance, to, msg.sender);\n\n    LINK.transfer(to, keeper.balance);\n  }\n\n  /**\n   * @notice proposes the safe transfer of a keeper's payee to another address\n   * @param keeper address of the keeper to transfer payee role\n   * @param proposed address to nominate for next payeeship\n   */\n  function transferPayeeship(address keeper, address proposed) external {\n    if (s_keeperInfo[keeper].payee != msg.sender) revert OnlyCallableByPayee();\n    if (proposed == msg.sender) revert ValueNotChanged();\n\n    if (s_proposedPayee[keeper] != proposed) {\n      s_proposedPayee[keeper] = proposed;\n      emit PayeeshipTransferRequested(keeper, msg.sender, proposed);\n    }\n  }\n\n  /**\n   * @notice accepts the safe transfer of payee role for a keeper\n   * @param keeper address to accept the payee role for\n   */\n  function acceptPayeeship(address keeper) external {\n    if (s_proposedPayee[keeper] != msg.sender) revert OnlyCallableByProposedPayee();\n    address past = s_keeperInfo[keeper].payee;\n    s_keeperInfo[keeper].payee = msg.sender;\n    s_proposedPayee[keeper] = ZERO_ADDRESS;\n\n    emit PayeeshipTransferred(keeper, past, msg.sender);\n  }\n\n  /**\n   * @notice signals to keepers that they should not perform upkeeps until the\n   * contract has been unpaused\n   */\n  function pause() external onlyOwner {\n    _pause();\n  }\n\n  /**\n   * @notice signals to keepers that they can perform upkeeps once again after\n   * having been paused\n   */\n  function unpause() external onlyOwner {\n    _unpause();\n  }\n\n  // SETTERS\n\n  /**\n   * @notice updates the configuration of the registry\n   * @param config registry config fields\n   */\n  function setConfig(Config memory config) public onlyOwner {\n    if (config.maxPerformGas < s_storage.maxPerformGas) revert GasLimitCanOnlyIncrease();\n    s_storage = Storage({\n      paymentPremiumPPB: config.paymentPremiumPPB,\n      flatFeeMicroLink: config.flatFeeMicroLink,\n      blockCountPerTurn: config.blockCountPerTurn,\n      checkGasLimit: config.checkGasLimit,\n      stalenessSeconds: config.stalenessSeconds,\n      gasCeilingMultiplier: config.gasCeilingMultiplier,\n      minUpkeepSpend: config.minUpkeepSpend,\n      maxPerformGas: config.maxPerformGas,\n      nonce: s_storage.nonce\n    });\n    s_fallbackGasPrice = config.fallbackGasPrice;\n    s_fallbackLinkPrice = config.fallbackLinkPrice;\n    s_transcoder = config.transcoder;\n    s_registrar = config.registrar;\n    emit ConfigSet(config);\n  }\n\n  /**\n   * @notice update the list of keepers allowed to perform upkeep\n   * @param keepers list of addresses allowed to perform upkeep\n   * @param payees addresses corresponding to keepers who are allowed to\n   * move payments which have been accrued\n   */\n  function setKeepers(address[] calldata keepers, address[] calldata payees) external onlyOwner {\n    if (keepers.length != payees.length || keepers.length < 2) revert ParameterLengthError();\n    for (uint256 i = 0; i < s_keeperList.length; i++) {\n      address keeper = s_keeperList[i];\n      s_keeperInfo[keeper].active = false;\n    }\n    for (uint256 i = 0; i < keepers.length; i++) {\n      address keeper = keepers[i];\n      KeeperInfo storage s_keeper = s_keeperInfo[keeper];\n      address oldPayee = s_keeper.payee;\n      address newPayee = payees[i];\n      if (\n        (newPayee == ZERO_ADDRESS) || (oldPayee != ZERO_ADDRESS && oldPayee != newPayee && newPayee != IGNORE_ADDRESS)\n      ) revert InvalidPayee();\n      if (s_keeper.active) revert DuplicateEntry();\n      s_keeper.active = true;\n      if (newPayee != IGNORE_ADDRESS) {\n        s_keeper.payee = newPayee;\n      }\n    }\n    s_keeperList = keepers;\n    emit KeepersUpdated(keepers, payees);\n  }\n\n  // GETTERS\n\n  /**\n   * @notice read all of the details about an upkeep\n   */\n  function getUpkeep(uint256 id)\n    external\n    view\n    override\n    returns (\n      address target,\n      uint32 executeGas,\n      bytes memory checkData,\n      uint96 balance,\n      address lastKeeper,\n      address admin,\n      uint64 maxValidBlocknumber,\n      uint96 amountSpent\n    )\n  {\n    Upkeep memory reg = s_upkeep[id];\n    return (\n      reg.target,\n      reg.executeGas,\n      s_checkData[id],\n      reg.balance,\n      reg.lastKeeper,\n      reg.admin,\n      reg.maxValidBlocknumber,\n      reg.amountSpent\n    );\n  }\n\n  /**\n   * @notice retrieve active upkeep IDs\n   * @param startIndex starting index in list\n   * @param maxCount max count to retrieve (0 = unlimited)\n   * @dev the order of IDs in the list is **not guaranteed**, therefore, if making successive calls, one\n   * should consider keeping the blockheight constant to ensure a wholistic picture of the contract state\n   */\n  function getActiveUpkeepIDs(uint256 startIndex, uint256 maxCount) external view override returns (uint256[] memory) {\n    uint256 maxIdx = s_upkeepIDs.length();\n    if (startIndex >= maxIdx) revert IndexOutOfRange();\n    if (maxCount == 0) {\n      maxCount = maxIdx - startIndex;\n    }\n    uint256[] memory ids = new uint256[](maxCount);\n    for (uint256 idx = 0; idx < maxCount; idx++) {\n      ids[idx] = s_upkeepIDs.at(startIndex + idx);\n    }\n    return ids;\n  }\n\n  /**\n   * @notice read the current info about any keeper address\n   */\n  function getKeeperInfo(address query)\n    external\n    view\n    override\n    returns (\n      address payee,\n      bool active,\n      uint96 balance\n    )\n  {\n    KeeperInfo memory keeper = s_keeperInfo[query];\n    return (keeper.payee, keeper.active, keeper.balance);\n  }\n\n  /**\n   * @notice read the current state of the registry\n   */\n  function getState()\n    external\n    view\n    override\n    returns (\n      State memory state,\n      Config memory config,\n      address[] memory keepers\n    )\n  {\n    Storage memory store = s_storage;\n    state.nonce = store.nonce;\n    state.ownerLinkBalance = s_ownerLinkBalance;\n    state.expectedLinkBalance = s_expectedLinkBalance;\n    state.numUpkeeps = s_upkeepIDs.length();\n    config.paymentPremiumPPB = store.paymentPremiumPPB;\n    config.flatFeeMicroLink = store.flatFeeMicroLink;\n    config.blockCountPerTurn = store.blockCountPerTurn;\n    config.checkGasLimit = store.checkGasLimit;\n    config.stalenessSeconds = store.stalenessSeconds;\n    config.gasCeilingMultiplier = store.gasCeilingMultiplier;\n    config.minUpkeepSpend = store.minUpkeepSpend;\n    config.maxPerformGas = store.maxPerformGas;\n    config.fallbackGasPrice = s_fallbackGasPrice;\n    config.fallbackLinkPrice = s_fallbackLinkPrice;\n    config.transcoder = s_transcoder;\n    config.registrar = s_registrar;\n    return (state, config, s_keeperList);\n  }\n\n  /**\n   * @notice calculates the minimum balance required for an upkeep to remain eligible\n   * @param id the upkeep id to calculate minimum balance for\n   */\n  function getMinBalanceForUpkeep(uint256 id) external view returns (uint96 minBalance) {\n    return getMaxPaymentForGas(s_upkeep[id].executeGas);\n  }\n\n  /**\n   * @notice calculates the maximum payment for a given gas limit\n   * @param gasLimit the gas to calculate payment for\n   */\n  function getMaxPaymentForGas(uint256 gasLimit) public view returns (uint96 maxPayment) {\n    (uint256 gasWei, uint256 linkEth) = _getFeedData();\n    uint256 adjustedGasWei = _adjustGasPrice(gasWei, false);\n    return _calculatePaymentAmount(gasLimit, adjustedGasWei, linkEth);\n  }\n\n  /**\n   * @notice retrieves the migration permission for a peer registry\n   */\n  function getPeerRegistryMigrationPermission(address peer) external view returns (MigrationPermission) {\n    return s_peerRegistryMigrationPermission[peer];\n  }\n\n  /**\n   * @notice sets the peer registry migration permission\n   */\n  function setPeerRegistryMigrationPermission(address peer, MigrationPermission permission) external onlyOwner {\n    s_peerRegistryMigrationPermission[peer] = permission;\n  }\n\n  /**\n   * @inheritdoc MigratableKeeperRegistryInterface\n   */\n  function migrateUpkeeps(uint256[] calldata ids, address destination) external override {\n    if (\n      s_peerRegistryMigrationPermission[destination] != MigrationPermission.OUTGOING &&\n      s_peerRegistryMigrationPermission[destination] != MigrationPermission.BIDIRECTIONAL\n    ) revert MigrationNotPermitted();\n    if (s_transcoder == ZERO_ADDRESS) revert TranscoderNotSet();\n    if (ids.length == 0) revert ArrayHasNoEntries();\n    address admin = s_upkeep[ids[0]].admin;\n    bool isOwner = msg.sender == owner();\n    if (msg.sender != admin && !isOwner) revert OnlyCallableByOwnerOrAdmin();\n\n    uint256 id;\n    Upkeep memory upkeep;\n    uint256 totalBalanceRemaining;\n    bytes[] memory checkDatas = new bytes[](ids.length);\n    Upkeep[] memory upkeeps = new Upkeep[](ids.length);\n    for (uint256 idx = 0; idx < ids.length; idx++) {\n      id = ids[idx];\n      upkeep = s_upkeep[id];\n      if (upkeep.admin != admin) revert OnlyCallableByAdmin();\n      if (upkeep.maxValidBlocknumber != UINT64_MAX) revert UpkeepNotActive();\n      upkeeps[idx] = upkeep;\n      checkDatas[idx] = s_checkData[id];\n      totalBalanceRemaining = totalBalanceRemaining + upkeep.balance;\n      delete s_upkeep[id];\n      delete s_checkData[id];\n      s_upkeepIDs.remove(id);\n      emit UpkeepMigrated(id, upkeep.balance, destination);\n    }\n    s_expectedLinkBalance = s_expectedLinkBalance - totalBalanceRemaining;\n    bytes memory encodedUpkeeps = abi.encode(ids, upkeeps, checkDatas);\n    MigratableKeeperRegistryInterface(destination).receiveUpkeeps(\n      UpkeepTranscoderInterface(s_transcoder).transcodeUpkeeps(\n        UpkeepFormat.V1,\n        MigratableKeeperRegistryInterface(destination).upkeepTranscoderVersion(),\n        encodedUpkeeps\n      )\n    );\n    LINK.transfer(destination, totalBalanceRemaining);\n  }\n\n  /**\n   * @inheritdoc MigratableKeeperRegistryInterface\n   */\n  UpkeepFormat public constant upkeepTranscoderVersion = UpkeepFormat.V1;\n\n  /**\n   * @inheritdoc MigratableKeeperRegistryInterface\n   */\n  function receiveUpkeeps(bytes calldata encodedUpkeeps) external override {\n    if (\n      s_peerRegistryMigrationPermission[msg.sender] != MigrationPermission.INCOMING &&\n      s_peerRegistryMigrationPermission[msg.sender] != MigrationPermission.BIDIRECTIONAL\n    ) revert MigrationNotPermitted();\n    (uint256[] memory ids, Upkeep[] memory upkeeps, bytes[] memory checkDatas) = abi.decode(\n      encodedUpkeeps,\n      (uint256[], Upkeep[], bytes[])\n    );\n    for (uint256 idx = 0; idx < ids.length; idx++) {\n      _createUpkeep(\n        ids[idx],\n        upkeeps[idx].target,\n        upkeeps[idx].executeGas,\n        upkeeps[idx].admin,\n        upkeeps[idx].balance,\n        checkDatas[idx]\n      );\n      emit UpkeepReceived(ids[idx], upkeeps[idx].balance, msg.sender);\n    }\n  }\n\n  /**\n   * @notice creates a new upkeep with the given fields\n   * @param target address to perform upkeep on\n   * @param gasLimit amount of gas to provide the target contract when\n   * performing upkeep\n   * @param admin address to cancel upkeep and withdraw remaining funds\n   * @param checkData data passed to the contract when checking for upkeep\n   */\n  function _createUpkeep(\n    uint256 id,\n    address target,\n    uint32 gasLimit,\n    address admin,\n    uint96 balance,\n    bytes memory checkData\n  ) internal whenNotPaused {\n    if (!target.isContract()) revert NotAContract();\n    if (gasLimit < PERFORM_GAS_MIN || gasLimit > s_storage.maxPerformGas) revert GasLimitOutsideRange();\n    s_upkeep[id] = Upkeep({\n      target: target,\n      executeGas: gasLimit,\n      balance: balance,\n      admin: admin,\n      maxValidBlocknumber: UINT64_MAX,\n      lastKeeper: ZERO_ADDRESS,\n      amountSpent: 0\n    });\n    s_expectedLinkBalance = s_expectedLinkBalance + balance;\n    s_checkData[id] = checkData;\n    s_upkeepIDs.add(id);\n  }\n\n  /**\n   * @dev retrieves feed data for fast gas/eth and link/eth prices. if the feed\n   * data is stale it uses the configured fallback price. Once a price is picked\n   * for gas it takes the min of gas price in the transaction or the fast gas\n   * price in order to reduce costs for the upkeep clients.\n   */\n  function _getFeedData() private view returns (uint256 gasWei, uint256 linkEth) {\n    uint32 stalenessSeconds = s_storage.stalenessSeconds;\n    bool staleFallback = stalenessSeconds > 0;\n    uint256 timestamp;\n    int256 feedValue;\n    (, feedValue, , timestamp, ) = FAST_GAS_FEED.latestRoundData();\n    if ((staleFallback && stalenessSeconds < block.timestamp - timestamp) || feedValue <= 0) {\n      gasWei = s_fallbackGasPrice;\n    } else {\n      gasWei = uint256(feedValue);\n    }\n    (, feedValue, , timestamp, ) = LINK_ETH_FEED.latestRoundData();\n    if ((staleFallback && stalenessSeconds < block.timestamp - timestamp) || feedValue <= 0) {\n      linkEth = s_fallbackLinkPrice;\n    } else {\n      linkEth = uint256(feedValue);\n    }\n    return (gasWei, linkEth);\n  }\n\n  /**\n   * @dev calculates LINK paid for gas spent plus a configure premium percentage\n   */\n  function _calculatePaymentAmount(\n    uint256 gasLimit,\n    uint256 gasWei,\n    uint256 linkEth\n  ) private view returns (uint96 payment) {\n    uint256 weiForGas = gasWei * (gasLimit + REGISTRY_GAS_OVERHEAD);\n    uint256 premium = PPB_BASE + s_storage.paymentPremiumPPB;\n    uint256 total = ((weiForGas * (1e9) * (premium)) / (linkEth)) + (uint256(s_storage.flatFeeMicroLink) * (1e12));\n    if (total > LINK_TOTAL_SUPPLY) revert PaymentGreaterThanAllLINK();\n    return uint96(total); // LINK_TOTAL_SUPPLY < UINT96_MAX\n  }\n\n  /**\n   * @dev calls target address with exactly gasAmount gas and data as calldata\n   * or reverts if at least gasAmount gas is not available\n   */\n  function _callWithExactGas(\n    uint256 gasAmount,\n    address target,\n    bytes memory data\n  ) private returns (bool success) {\n    assembly {\n      let g := gas()\n      // Compute g -= PERFORM_GAS_CUSHION and check for underflow\n      if lt(g, PERFORM_GAS_CUSHION) {\n        revert(0, 0)\n      }\n      g := sub(g, PERFORM_GAS_CUSHION)\n      // if g - g//64 <= gasAmount, revert\n      // (we subtract g//64 because of EIP-150)\n      if iszero(gt(sub(g, div(g, 64)), gasAmount)) {\n        revert(0, 0)\n      }\n      // solidity calls check that a contract actually exists at the destination, so we do the same\n      if iszero(extcodesize(target)) {\n        revert(0, 0)\n      }\n      // call and return whether we succeeded. ignore return data\n      success := call(gasAmount, target, 0, add(data, 0x20), mload(data), 0, 0)\n    }\n    return success;\n  }\n\n  /**\n   * @dev calls the Upkeep target with the performData param passed in by the\n   * keeper and the exact gas required by the Upkeep\n   */\n  function _performUpkeepWithParams(PerformParams memory params)\n    private\n    nonReentrant\n    validUpkeep(params.id)\n    returns (bool success)\n  {\n    Upkeep memory upkeep = s_upkeep[params.id];\n    _prePerformUpkeep(upkeep, params.from, params.maxLinkPayment);\n\n    uint256 gasUsed = gasleft();\n    bytes memory callData = abi.encodeWithSelector(PERFORM_SELECTOR, params.performData);\n    success = _callWithExactGas(params.gasLimit, upkeep.target, callData);\n    gasUsed = gasUsed - gasleft();\n\n    uint96 payment = _calculatePaymentAmount(gasUsed, params.adjustedGasWei, params.linkEth);\n\n    s_upkeep[params.id].balance = s_upkeep[params.id].balance - payment;\n    s_upkeep[params.id].amountSpent = s_upkeep[params.id].amountSpent + payment;\n    s_upkeep[params.id].lastKeeper = params.from;\n    s_keeperInfo[params.from].balance = s_keeperInfo[params.from].balance + payment;\n\n    emit UpkeepPerformed(params.id, success, params.from, payment, params.performData);\n    return success;\n  }\n\n  /**\n   * @dev ensures all required checks are passed before an upkeep is performed\n   */\n  function _prePerformUpkeep(\n    Upkeep memory upkeep,\n    address from,\n    uint256 maxLinkPayment\n  ) private view {\n    if (!s_keeperInfo[from].active) revert OnlyActiveKeepers();\n    if (upkeep.balance < maxLinkPayment) revert InsufficientFunds();\n    if (upkeep.lastKeeper == from) revert KeepersMustTakeTurns();\n  }\n\n  /**\n   * @dev adjusts the gas price to min(ceiling, tx.gasprice) or just uses the ceiling if tx.gasprice is disabled\n   */\n  function _adjustGasPrice(uint256 gasWei, bool useTxGasPrice) private view returns (uint256 adjustedPrice) {\n    adjustedPrice = gasWei * s_storage.gasCeilingMultiplier;\n    if (useTxGasPrice && tx.gasprice < adjustedPrice) {\n      adjustedPrice = tx.gasprice;\n    }\n  }\n\n  /**\n   * @dev generates a PerformParams struct for use in _performUpkeepWithParams()\n   */\n  function _generatePerformParams(\n    address from,\n    uint256 id,\n    bytes memory performData,\n    bool useTxGasPrice\n  ) private view returns (PerformParams memory) {\n    uint256 gasLimit = s_upkeep[id].executeGas;\n    (uint256 gasWei, uint256 linkEth) = _getFeedData();\n    uint256 adjustedGasWei = _adjustGasPrice(gasWei, useTxGasPrice);\n    uint96 maxLinkPayment = _calculatePaymentAmount(gasLimit, adjustedGasWei, linkEth);\n\n    return\n      PerformParams({\n        from: from,\n        id: id,\n        performData: performData,\n        maxLinkPayment: maxLinkPayment,\n        gasLimit: gasLimit,\n        adjustedGasWei: adjustedGasWei,\n        linkEth: linkEth\n      });\n  }\n\n  // MODIFIERS\n\n  /**\n   * @dev ensures a upkeep is valid\n   */\n  modifier validUpkeep(uint256 id) {\n    if (s_upkeep[id].maxValidBlocknumber <= block.number) revert UpkeepNotActive();\n    _;\n  }\n\n  /**\n   * @dev Reverts if called by anyone other than the admin of upkeep #id\n   */\n  modifier onlyUpkeepAdmin(uint256 id) {\n    if (msg.sender != s_upkeep[id].admin) revert OnlyCallableByAdmin();\n    _;\n  }\n\n  /**\n   * @dev Reverts if called on a cancelled upkeep\n   */\n  modifier onlyActiveUpkeep(uint256 id) {\n    if (s_upkeep[id].maxValidBlocknumber != UINT64_MAX) revert UpkeepNotActive();\n    _;\n  }\n\n  /**\n   * @dev ensures that burns don't accidentally happen by sending to the zero\n   * address\n   */\n  modifier validRecipient(address to) {\n    if (to == ZERO_ADDRESS) revert InvalidRecipient();\n    _;\n  }\n\n  /**\n   * @dev Reverts if called by anyone other than the contract owner or registrar.\n   */\n  modifier onlyOwnerOrRegistrar() {\n    if (msg.sender != owner() && msg.sender != s_registrar) revert OnlyCallableByOwnerOrRegistrar();\n    _;\n  }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        require(!paused(), \"Pausable: paused\");\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        require(paused(), \"Pausable: not paused\");\n        _;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "src/v0.8/KeeperBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract KeeperBase {\n  error OnlySimulatedBackend();\n\n  /**\n   * @notice method that allows it to be simulated via eth_call by checking that\n   * the sender is the zero address.\n   */\n  function preventExecution() internal view {\n    if (tx.origin != address(0)) {\n      revert OnlySimulatedBackend();\n    }\n  }\n\n  /**\n   * @notice modifier that allows it to be simulated via eth_call by checking\n   * that the sender is the zero address.\n   */\n  modifier cannotExecute() {\n    preventExecution();\n    _;\n  }\n}\n"
    },
    "src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "src/v0.8/interfaces/KeeperCompatibleInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface KeeperCompatibleInterface {\n  /**\n   * @notice method that is simulated by the keepers to see if any work actually\n   * needs to be performed. This method does does not actually need to be\n   * executable, and since it is only ever simulated it can consume lots of gas.\n   * @dev To ensure that it is never called, you may want to add the\n   * cannotExecute modifier from KeeperBase to your implementation of this\n   * method.\n   * @param checkData specified in the upkeep registration so it is always the\n   * same for a registered upkeep. This can easily be broken down into specific\n   * arguments using `abi.decode`, so multiple upkeeps can be registered on the\n   * same contract and easily differentiated by the contract.\n   * @return upkeepNeeded boolean to indicate whether the keeper should call\n   * performUpkeep or not.\n   * @return performData bytes that the keeper should call performUpkeep with, if\n   * upkeep is needed. If you would like to encode data to decode later, try\n   * `abi.encode`.\n   */\n  function checkUpkeep(bytes calldata checkData) external returns (bool upkeepNeeded, bytes memory performData);\n\n  /**\n   * @notice method that is actually executed by the keepers, via the registry.\n   * The data returned by the checkUpkeep simulation will be passed into\n   * this method to actually be executed.\n   * @dev The input to this method should not be trusted, and the caller of the\n   * method should not even be restricted to any single registry. Anyone should\n   * be able call it, and the input should be validated, there is no guarantee\n   * that the data passed in is the performData returned from checkUpkeep. This\n   * could happen due to malicious keepers, racing keepers, or simply a state\n   * change while the performUpkeep transaction is waiting for confirmation.\n   * Always validate the data passed in.\n   * @param performData is the data which was passed back from the checkData\n   * simulation. If it is encoded, it can easily be decoded into other types by\n   * calling `abi.decode`. This data should not be trusted, and should be\n   * validated against the contract's current state.\n   */\n  function performUpkeep(bytes calldata performData) external;\n}\n"
    },
    "src/v0.8/interfaces/KeeperRegistryInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @notice config of the registry\n * @dev only used in params and return values\n * @member paymentPremiumPPB payment premium rate oracles receive on top of\n * being reimbursed for gas, measured in parts per billion\n * @member flatFeeMicroLink flat fee paid to oracles for performing upkeeps,\n * priced in MicroLink; can be used in conjunction with or independently of\n * paymentPremiumPPB\n * @member blockCountPerTurn number of blocks each oracle has during their turn to\n * perform upkeep before it will be the next keeper's turn to submit\n * @member checkGasLimit gas limit when checking for upkeep\n * @member stalenessSeconds number of seconds that is allowed for feed data to\n * be stale before switching to the fallback pricing\n * @member gasCeilingMultiplier multiplier to apply to the fast gas feed price\n * when calculating the payment ceiling for keepers\n * @member minUpkeepSpend minimum LINK that an upkeep must spend before cancelling\n * @member maxPerformGas max executeGas allowed for an upkeep on this registry\n * @member fallbackGasPrice gas price used if the gas price feed is stale\n * @member fallbackLinkPrice LINK price used if the LINK price feed is stale\n * @member transcoder address of the transcoder contract\n * @member registrar address of the registrar contract\n */\nstruct Config {\n  uint32 paymentPremiumPPB;\n  uint32 flatFeeMicroLink; // min 0.000001 LINK, max 4294 LINK\n  uint24 blockCountPerTurn;\n  uint32 checkGasLimit;\n  uint24 stalenessSeconds;\n  uint16 gasCeilingMultiplier;\n  uint96 minUpkeepSpend;\n  uint32 maxPerformGas;\n  uint256 fallbackGasPrice;\n  uint256 fallbackLinkPrice;\n  address transcoder;\n  address registrar;\n}\n\n/**\n * @notice config of the registry\n * @dev only used in params and return values\n * @member nonce used for ID generation\n * @ownerLinkBalance withdrawable balance of LINK by contract owner\n * @numUpkeeps total number of upkeeps on the registry\n */\nstruct State {\n  uint32 nonce;\n  uint96 ownerLinkBalance;\n  uint256 expectedLinkBalance;\n  uint256 numUpkeeps;\n}\n\ninterface KeeperRegistryBaseInterface {\n  function registerUpkeep(\n    address target,\n    uint32 gasLimit,\n    address admin,\n    bytes calldata checkData\n  ) external returns (uint256 id);\n\n  function performUpkeep(uint256 id, bytes calldata performData) external returns (bool success);\n\n  function cancelUpkeep(uint256 id) external;\n\n  function addFunds(uint256 id, uint96 amount) external;\n\n  function setUpkeepGasLimit(uint256 id, uint32 gasLimit) external;\n\n  function getUpkeep(uint256 id)\n    external\n    view\n    returns (\n      address target,\n      uint32 executeGas,\n      bytes memory checkData,\n      uint96 balance,\n      address lastKeeper,\n      address admin,\n      uint64 maxValidBlocknumber,\n      uint96 amountSpent\n    );\n\n  function getActiveUpkeepIDs(uint256 startIndex, uint256 maxCount) external view returns (uint256[] memory);\n\n  function getKeeperInfo(address query)\n    external\n    view\n    returns (\n      address payee,\n      bool active,\n      uint96 balance\n    );\n\n  function getState()\n    external\n    view\n    returns (\n      State memory,\n      Config memory,\n      address[] memory\n    );\n}\n\n/**\n * @dev The view methods are not actually marked as view in the implementation\n * but we want them to be easily queried off-chain. Solidity will not compile\n * if we actually inherit from this interface, so we document it here.\n */\ninterface KeeperRegistryInterface is KeeperRegistryBaseInterface {\n  function checkUpkeep(uint256 upkeepId, address from)\n    external\n    view\n    returns (\n      bytes memory performData,\n      uint256 maxLinkPayment,\n      uint256 gasLimit,\n      int256 gasWei,\n      int256 linkEth\n    );\n}\n\ninterface KeeperRegistryExecutableInterface is KeeperRegistryBaseInterface {\n  function checkUpkeep(uint256 upkeepId, address from)\n    external\n    returns (\n      bytes memory performData,\n      uint256 maxLinkPayment,\n      uint256 gasLimit,\n      uint256 adjustedGasWei,\n      uint256 linkEth\n    );\n}\n"
    },
    "src/v0.8/interfaces/MigratableKeeperRegistryInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../UpkeepFormat.sol\";\n\ninterface MigratableKeeperRegistryInterface {\n  function migrateUpkeeps(uint256[] calldata upkeepIDs, address destination) external;\n\n  function receiveUpkeeps(bytes calldata encodedUpkeeps) external;\n\n  function upkeepTranscoderVersion() external returns (UpkeepFormat version);\n}\n"
    },
    "src/v0.8/interfaces/ERC677ReceiverInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\ninterface ERC677ReceiverInterface {\n  function onTokenTransfer(\n    address sender,\n    uint256 amount,\n    bytes calldata data\n  ) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "src/v0.8/tests/VRFOwnerlessConsumerExample.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// An example VRF V1 consumer contract that can be triggered using a transferAndCall from the link\n// contract.\npragma solidity ^0.8.4;\n\nimport \"../VRFConsumerBase.sol\";\nimport \"../interfaces/ERC677ReceiverInterface.sol\";\n\ncontract VRFOwnerlessConsumerExample is VRFConsumerBase, ERC677ReceiverInterface {\n  uint256 public s_randomnessOutput;\n  bytes32 public s_requestId;\n\n  error OnlyCallableFromLink();\n\n  constructor(address _vrfCoordinator, address _link) VRFConsumerBase(_vrfCoordinator, _link) {\n    /* empty */\n  }\n\n  function fulfillRandomness(bytes32 requestId, uint256 _randomness) internal override {\n    require(requestId == s_requestId, \"request ID is incorrect\");\n    s_randomnessOutput = _randomness;\n  }\n\n  /**\n   * @dev Creates a new randomness request. This function can only be used by calling\n   * transferAndCall on the LinkToken contract.\n   * @param _amount The amount of LINK transferred to pay for this request.\n   * @param _data The data passed to transferAndCall on LinkToken. Must be an abi-encoded key hash.\n   */\n  function onTokenTransfer(\n    address, /* sender */\n    uint256 _amount,\n    bytes calldata _data\n  ) external override {\n    if (msg.sender != address(LINK)) {\n      revert OnlyCallableFromLink();\n    }\n\n    bytes32 keyHash = abi.decode(_data, (bytes32));\n    s_requestId = requestRandomness(keyHash, _amount);\n  }\n}\n"
    },
    "src/v0.8/VRFConsumerBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./interfaces/LinkTokenInterface.sol\";\n\nimport \"./VRFRequestIDBase.sol\";\n\n/** ****************************************************************************\n * @notice Interface for contracts using VRF randomness\n * *****************************************************************************\n * @dev PURPOSE\n *\n * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\n * @dev to Vera the verifier in such a way that Vera can be sure he's not\n * @dev making his output up to suit himself. Reggie provides Vera a public key\n * @dev to which he knows the secret key. Each time Vera provides a seed to\n * @dev Reggie, he gives back a value which is computed completely\n * @dev deterministically from the seed and the secret key.\n *\n * @dev Reggie provides a proof by which Vera can verify that the output was\n * @dev correctly computed once Reggie tells it to her, but without that proof,\n * @dev the output is indistinguishable to her from a uniform random sample\n * @dev from the output space.\n *\n * @dev The purpose of this contract is to make it easy for unrelated contracts\n * @dev to talk to Vera the verifier about the work Reggie is doing, to provide\n * @dev simple access to a verifiable source of randomness.\n * *****************************************************************************\n * @dev USAGE\n *\n * @dev Calling contracts must inherit from VRFConsumerBase, and can\n * @dev initialize VRFConsumerBase's attributes in their constructor as\n * @dev shown:\n *\n * @dev   contract VRFConsumer {\n * @dev     constructor(<other arguments>, address _vrfCoordinator, address _link)\n * @dev       VRFConsumerBase(_vrfCoordinator, _link) public {\n * @dev         <initialization with other arguments goes here>\n * @dev       }\n * @dev   }\n *\n * @dev The oracle will have given you an ID for the VRF keypair they have\n * @dev committed to (let's call it keyHash), and have told you the minimum LINK\n * @dev price for VRF service. Make sure your contract has sufficient LINK, and\n * @dev call requestRandomness(keyHash, fee, seed), where seed is the input you\n * @dev want to generate randomness from.\n *\n * @dev Once the VRFCoordinator has received and validated the oracle's response\n * @dev to your request, it will call your contract's fulfillRandomness method.\n *\n * @dev The randomness argument to fulfillRandomness is the actual random value\n * @dev generated from your seed.\n *\n * @dev The requestId argument is generated from the keyHash and the seed by\n * @dev makeRequestId(keyHash, seed). If your contract could have concurrent\n * @dev requests open, you can use the requestId to track which seed is\n * @dev associated with which randomness. See VRFRequestIDBase.sol for more\n * @dev details. (See \"SECURITY CONSIDERATIONS\" for principles to keep in mind,\n * @dev if your contract could have multiple requests in flight simultaneously.)\n *\n * @dev Colliding `requestId`s are cryptographically impossible as long as seeds\n * @dev differ. (Which is critical to making unpredictable randomness! See the\n * @dev next section.)\n *\n * *****************************************************************************\n * @dev SECURITY CONSIDERATIONS\n *\n * @dev A method with the ability to call your fulfillRandomness method directly\n * @dev could spoof a VRF response with any random value, so it's critical that\n * @dev it cannot be directly called by anything other than this base contract\n * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomness method).\n *\n * @dev For your users to trust that your contract's random behavior is free\n * @dev from malicious interference, it's best if you can write it so that all\n * @dev behaviors implied by a VRF response are executed *during* your\n * @dev fulfillRandomness method. If your contract must store the response (or\n * @dev anything derived from it) and use it later, you must ensure that any\n * @dev user-significant behavior which depends on that stored value cannot be\n * @dev manipulated by a subsequent VRF request.\n *\n * @dev Similarly, both miners and the VRF oracle itself have some influence\n * @dev over the order in which VRF responses appear on the blockchain, so if\n * @dev your contract could have multiple VRF requests in flight simultaneously,\n * @dev you must ensure that the order in which the VRF responses arrive cannot\n * @dev be used to manipulate your contract's user-significant behavior.\n *\n * @dev Since the ultimate input to the VRF is mixed with the block hash of the\n * @dev block in which the request is made, user-provided seeds have no impact\n * @dev on its economic security properties. They are only included for API\n * @dev compatability with previous versions of this contract.\n *\n * @dev Since the block hash of the block which contains the requestRandomness\n * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful\n * @dev miner could, in principle, fork the blockchain to evict the block\n * @dev containing the request, forcing the request to be included in a\n * @dev different block with a different hash, and therefore a different input\n * @dev to the VRF. However, such an attack would incur a substantial economic\n * @dev cost. This cost scales with the number of blocks the VRF oracle waits\n * @dev until it calls responds to a request.\n */\nabstract contract VRFConsumerBase is VRFRequestIDBase {\n  /**\n   * @notice fulfillRandomness handles the VRF response. Your contract must\n   * @notice implement it. See \"SECURITY CONSIDERATIONS\" above for important\n   * @notice principles to keep in mind when implementing your fulfillRandomness\n   * @notice method.\n   *\n   * @dev VRFConsumerBase expects its subcontracts to have a method with this\n   * @dev signature, and will call it once it has verified the proof\n   * @dev associated with the randomness. (It is triggered via a call to\n   * @dev rawFulfillRandomness, below.)\n   *\n   * @param requestId The Id initially returned by requestRandomness\n   * @param randomness the VRF output\n   */\n  function fulfillRandomness(bytes32 requestId, uint256 randomness) internal virtual;\n\n  /**\n   * @dev In order to keep backwards compatibility we have kept the user\n   * seed field around. We remove the use of it because given that the blockhash\n   * enters later, it overrides whatever randomness the used seed provides.\n   * Given that it adds no security, and can easily lead to misunderstandings,\n   * we have removed it from usage and can now provide a simpler API.\n   */\n  uint256 private constant USER_SEED_PLACEHOLDER = 0;\n\n  /**\n   * @notice requestRandomness initiates a request for VRF output given _seed\n   *\n   * @dev The fulfillRandomness method receives the output, once it's provided\n   * @dev by the Oracle, and verified by the vrfCoordinator.\n   *\n   * @dev The _keyHash must already be registered with the VRFCoordinator, and\n   * @dev the _fee must exceed the fee specified during registration of the\n   * @dev _keyHash.\n   *\n   * @dev The _seed parameter is vestigial, and is kept only for API\n   * @dev compatibility with older versions. It can't *hurt* to mix in some of\n   * @dev your own randomness, here, but it's not necessary because the VRF\n   * @dev oracle will mix the hash of the block containing your request into the\n   * @dev VRF seed it ultimately uses.\n   *\n   * @param _keyHash ID of public key against which randomness is generated\n   * @param _fee The amount of LINK to send with the request\n   *\n   * @return requestId unique ID for this request\n   *\n   * @dev The returned requestId can be used to distinguish responses to\n   * @dev concurrent requests. It is passed as the first argument to\n   * @dev fulfillRandomness.\n   */\n  function requestRandomness(bytes32 _keyHash, uint256 _fee) internal returns (bytes32 requestId) {\n    LINK.transferAndCall(vrfCoordinator, _fee, abi.encode(_keyHash, USER_SEED_PLACEHOLDER));\n    // This is the seed passed to VRFCoordinator. The oracle will mix this with\n    // the hash of the block containing this request to obtain the seed/input\n    // which is finally passed to the VRF cryptographic machinery.\n    uint256 vRFSeed = makeVRFInputSeed(_keyHash, USER_SEED_PLACEHOLDER, address(this), nonces[_keyHash]);\n    // nonces[_keyHash] must stay in sync with\n    // VRFCoordinator.nonces[_keyHash][this], which was incremented by the above\n    // successful LINK.transferAndCall (in VRFCoordinator.randomnessRequest).\n    // This provides protection against the user repeating their input seed,\n    // which would result in a predictable/duplicate output, if multiple such\n    // requests appeared in the same block.\n    nonces[_keyHash] = nonces[_keyHash] + 1;\n    return makeRequestId(_keyHash, vRFSeed);\n  }\n\n  LinkTokenInterface internal immutable LINK;\n  address private immutable vrfCoordinator;\n\n  // Nonces for each VRF key from which randomness has been requested.\n  //\n  // Must stay in sync with VRFCoordinator[_keyHash][this]\n  mapping(bytes32 => uint256) /* keyHash */ /* nonce */\n    private nonces;\n\n  /**\n   * @param _vrfCoordinator address of VRFCoordinator contract\n   * @param _link address of LINK token contract\n   *\n   * @dev https://docs.chain.link/docs/link-token-contracts\n   */\n  constructor(address _vrfCoordinator, address _link) {\n    vrfCoordinator = _vrfCoordinator;\n    LINK = LinkTokenInterface(_link);\n  }\n\n  // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF\n  // proof. rawFulfillRandomness then calls fulfillRandomness, after validating\n  // the origin of the call\n  function rawFulfillRandomness(bytes32 requestId, uint256 randomness) external {\n    require(msg.sender == vrfCoordinator, \"Only VRFCoordinator can fulfill\");\n    fulfillRandomness(requestId, randomness);\n  }\n}\n"
    },
    "src/v0.8/VRFRequestIDBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract VRFRequestIDBase {\n  /**\n   * @notice returns the seed which is actually input to the VRF coordinator\n   *\n   * @dev To prevent repetition of VRF output due to repetition of the\n   * @dev user-supplied seed, that seed is combined in a hash with the\n   * @dev user-specific nonce, and the address of the consuming contract. The\n   * @dev risk of repetition is mostly mitigated by inclusion of a blockhash in\n   * @dev the final seed, but the nonce does protect against repetition in\n   * @dev requests which are included in a single block.\n   *\n   * @param _userSeed VRF seed input provided by user\n   * @param _requester Address of the requesting contract\n   * @param _nonce User-specific nonce at the time of the request\n   */\n  function makeVRFInputSeed(\n    bytes32 _keyHash,\n    uint256 _userSeed,\n    address _requester,\n    uint256 _nonce\n  ) internal pure returns (uint256) {\n    return uint256(keccak256(abi.encode(_keyHash, _userSeed, _requester, _nonce)));\n  }\n\n  /**\n   * @notice Returns the id for this request\n   * @param _keyHash The serviceAgreement ID to be used for this request\n   * @param _vRFInputSeed The seed to be passed directly to the VRF\n   * @return The id for this request\n   *\n   * @dev Note that _vRFInputSeed is not the seed passed by the consuming\n   * @dev contract, but the one generated by makeVRFInputSeed\n   */\n  function makeRequestId(bytes32 _keyHash, uint256 _vRFInputSeed) internal pure returns (bytes32) {\n    return keccak256(abi.encodePacked(_keyHash, _vRFInputSeed));\n  }\n}\n"
    },
    "src/v0.8/tests/VRFLoadTestOwnerlessConsumer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../VRFConsumerBase.sol\";\nimport \"../interfaces/ERC677ReceiverInterface.sol\";\n\n/**\n * @title The VRFLoadTestOwnerlessConsumer contract.\n * @notice Allows making many VRF V1 randomness requests in a single transaction for load testing.\n */\ncontract VRFLoadTestOwnerlessConsumer is VRFConsumerBase, ERC677ReceiverInterface {\n  // The price of each VRF request in Juels. 1 LINK = 1e18 Juels.\n  uint256 public immutable PRICE;\n\n  uint256 public s_responseCount;\n\n  constructor(\n    address _vrfCoordinator,\n    address _link,\n    uint256 _price\n  ) VRFConsumerBase(_vrfCoordinator, _link) {\n    PRICE = _price;\n  }\n\n  function fulfillRandomness(bytes32, uint256) internal override {\n    s_responseCount++;\n  }\n\n  /**\n   * @dev Creates as many randomness requests as can be made with the funds transferred.\n   * @param _amount The amount of LINK transferred to pay for these requests.\n   * @param _data The data passed to transferAndCall on LinkToken. Must be an abi-encoded key hash.\n   */\n  function onTokenTransfer(\n    address,\n    uint256 _amount,\n    bytes calldata _data\n  ) external override {\n    if (msg.sender != address(LINK)) {\n      revert(\"only callable from LINK\");\n    }\n    bytes32 keyHash = abi.decode(_data, (bytes32));\n\n    uint256 spent = 0;\n    while (spent + PRICE <= _amount) {\n      requestRandomness(keyHash, PRICE);\n      spent += PRICE;\n    }\n  }\n}\n"
    },
    "src/v0.8/tests/VRFConsumer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../interfaces/LinkTokenInterface.sol\";\nimport \"../VRFConsumerBase.sol\";\n\ncontract VRFConsumer is VRFConsumerBase {\n  uint256 public randomnessOutput;\n  bytes32 public requestId;\n\n  constructor(address vrfCoordinator, address link)\n    // solhint-disable-next-line no-empty-blocks\n    VRFConsumerBase(vrfCoordinator, link)\n  {\n    /* empty */\n  }\n\n  function fulfillRandomness(\n    bytes32, /* requestId */\n    uint256 randomness\n  ) internal override {\n    randomnessOutput = randomness;\n    requestId = requestId;\n  }\n\n  function testRequestRandomness(bytes32 keyHash, uint256 fee) external returns (bytes32) {\n    return requestRandomness(keyHash, fee);\n  }\n}\n"
    },
    "src/v0.8/tests/VRFRequestIDBaseTestHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../VRFRequestIDBase.sol\";\n\ncontract VRFRequestIDBaseTestHelper is VRFRequestIDBase {\n  function makeVRFInputSeed_(\n    bytes32 _keyHash,\n    uint256 _userSeed,\n    address _requester,\n    uint256 _nonce\n  ) public pure returns (uint256) {\n    return makeVRFInputSeed(_keyHash, _userSeed, _requester, _nonce);\n  }\n\n  function makeRequestId_(bytes32 _keyHash, uint256 _vRFInputSeed) public pure returns (bytes32) {\n    return makeRequestId(_keyHash, _vRFInputSeed);\n  }\n}\n"
    },
    "src/v0.8/mocks/VRFCoordinatorMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../interfaces/LinkTokenInterface.sol\";\nimport \"../VRFConsumerBase.sol\";\n\ncontract VRFCoordinatorMock {\n  LinkTokenInterface public LINK;\n\n  event RandomnessRequest(address indexed sender, bytes32 indexed keyHash, uint256 indexed seed);\n\n  constructor(address linkAddress) public {\n    LINK = LinkTokenInterface(linkAddress);\n  }\n\n  function onTokenTransfer(\n    address sender,\n    uint256 fee,\n    bytes memory _data\n  ) public onlyLINK {\n    (bytes32 keyHash, uint256 seed) = abi.decode(_data, (bytes32, uint256));\n    emit RandomnessRequest(sender, keyHash, seed);\n  }\n\n  function callBackWithRandomness(\n    bytes32 requestId,\n    uint256 randomness,\n    address consumerContract\n  ) public {\n    VRFConsumerBase v;\n    bytes memory resp = abi.encodeWithSelector(v.rawFulfillRandomness.selector, requestId, randomness);\n    uint256 b = 206000;\n    require(gasleft() >= b, \"not enough gas for consumer\");\n    (bool success, ) = consumerContract.call(resp);\n  }\n\n  modifier onlyLINK() {\n    require(msg.sender == address(LINK), \"Must use LINK token\");\n    _;\n  }\n}\n"
    },
    "src/v0.8/KeeperRegistrar.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport \"./interfaces/LinkTokenInterface.sol\";\nimport \"./interfaces/KeeperRegistryInterface.sol\";\nimport \"./interfaces/TypeAndVersionInterface.sol\";\nimport \"./ConfirmedOwner.sol\";\nimport \"./interfaces/ERC677ReceiverInterface.sol\";\n\n/**\n * @notice Contract to accept requests for upkeep registrations\n * @dev There are 2 registration workflows in this contract\n * Flow 1. auto approve OFF / manual registration - UI calls `register` function on this contract, this contract owner at a later time then manually\n *  calls `approve` to register upkeep and emit events to inform UI and others interested.\n * Flow 2. auto approve ON / real time registration - UI calls `register` function as before, which calls the `registerUpkeep` function directly on\n *  keeper registry and then emits approved event to finish the flow automatically without manual intervention.\n * The idea is to have same interface(functions,events) for UI or anyone using this contract irrespective of auto approve being enabled or not.\n * they can just listen to `RegistrationRequested` & `RegistrationApproved` events and know the status on registrations.\n */\ncontract KeeperRegistrar is TypeAndVersionInterface, ConfirmedOwner, ERC677ReceiverInterface {\n  /**\n   * DISABLED: No auto approvals, all new upkeeps should be approved manually.\n   * ENABLED_SENDER_ALLOWLIST: Auto approvals for allowed senders subject to max allowed. Manual for rest.\n   * ENABLED_ALL: Auto approvals for all new upkeeps subject to max allowed.\n   */\n  enum AutoApproveType {\n    DISABLED,\n    ENABLED_SENDER_ALLOWLIST,\n    ENABLED_ALL\n  }\n\n  bytes4 private constant REGISTER_REQUEST_SELECTOR = this.register.selector;\n\n  mapping(bytes32 => PendingRequest) private s_pendingRequests;\n\n  LinkTokenInterface public immutable LINK;\n\n  /**\n   * @notice versions:\n   * - KeeperRegistrar 1.1.0: Add functionality for sender allowlist in auto approve\n   *                        : Remove rate limit and add max allowed for auto approve\n   * - KeeperRegistrar 1.0.0: initial release\n   */\n  string public constant override typeAndVersion = \"KeeperRegistrar 1.1.0\";\n\n  struct Config {\n    AutoApproveType autoApproveConfigType;\n    uint32 autoApproveMaxAllowed;\n    uint32 approvedCount;\n    KeeperRegistryBaseInterface keeperRegistry;\n    uint96 minLINKJuels;\n  }\n\n  struct PendingRequest {\n    address admin;\n    uint96 balance;\n  }\n\n  Config private s_config;\n  // Only applicable if s_config.configType is ENABLED_SENDER_ALLOWLIST\n  mapping(address => bool) private s_autoApproveAllowedSenders;\n\n  event RegistrationRequested(\n    bytes32 indexed hash,\n    string name,\n    bytes encryptedEmail,\n    address indexed upkeepContract,\n    uint32 gasLimit,\n    address adminAddress,\n    bytes checkData,\n    uint96 amount,\n    uint8 indexed source\n  );\n\n  event RegistrationApproved(bytes32 indexed hash, string displayName, uint256 indexed upkeepId);\n\n  event RegistrationRejected(bytes32 indexed hash);\n\n  event AutoApproveAllowedSenderSet(address indexed senderAddress, bool allowed);\n\n  event ConfigChanged(\n    AutoApproveType autoApproveConfigType,\n    uint32 autoApproveMaxAllowed,\n    address keeperRegistry,\n    uint96 minLINKJuels\n  );\n\n  error InvalidAdminAddress();\n  error RequestNotFound();\n  error HashMismatch();\n  error OnlyAdminOrOwner();\n  error InsufficientPayment();\n  error RegistrationRequestFailed();\n  error OnlyLink();\n  error AmountMismatch();\n  error SenderMismatch();\n  error FunctionNotPermitted();\n  error LinkTransferFailed(address to);\n  error InvalidDataLength();\n\n  /*\n   * @param LINKAddress Address of Link token\n   * @param autoApproveConfigType setting for auto-approve registrations\n   * @param autoApproveMaxAllowed max number of registrations that can be auto approved\n   * @param keeperRegistry keeper registry address\n   * @param minLINKJuels minimum LINK that new registrations should fund their upkeep with\n   */\n  constructor(\n    address LINKAddress,\n    AutoApproveType autoApproveConfigType,\n    uint16 autoApproveMaxAllowed,\n    address keeperRegistry,\n    uint96 minLINKJuels\n  ) ConfirmedOwner(msg.sender) {\n    LINK = LinkTokenInterface(LINKAddress);\n    setRegistrationConfig(autoApproveConfigType, autoApproveMaxAllowed, keeperRegistry, minLINKJuels);\n  }\n\n  //EXTERNAL\n\n  /**\n   * @notice register can only be called through transferAndCall on LINK contract\n   * @param name string of the upkeep to be registered\n   * @param encryptedEmail email address of upkeep contact\n   * @param upkeepContract address to perform upkeep on\n   * @param gasLimit amount of gas to provide the target contract when performing upkeep\n   * @param adminAddress address to cancel upkeep and withdraw remaining funds\n   * @param checkData data passed to the contract when checking for upkeep\n   * @param amount quantity of LINK upkeep is funded with (specified in Juels)\n   * @param source application sending this request\n   * @param sender address of the sender making the request\n   */\n  function register(\n    string memory name,\n    bytes calldata encryptedEmail,\n    address upkeepContract,\n    uint32 gasLimit,\n    address adminAddress,\n    bytes calldata checkData,\n    uint96 amount,\n    uint8 source,\n    address sender\n  ) external onlyLINK {\n    if (adminAddress == address(0)) {\n      revert InvalidAdminAddress();\n    }\n    bytes32 hash = keccak256(abi.encode(upkeepContract, gasLimit, adminAddress, checkData));\n\n    emit RegistrationRequested(\n      hash,\n      name,\n      encryptedEmail,\n      upkeepContract,\n      gasLimit,\n      adminAddress,\n      checkData,\n      amount,\n      source\n    );\n\n    Config memory config = s_config;\n    if (_shouldAutoApprove(config, sender)) {\n      s_config.approvedCount = config.approvedCount + 1;\n\n      _approve(name, upkeepContract, gasLimit, adminAddress, checkData, amount, hash);\n    } else {\n      uint96 newBalance = s_pendingRequests[hash].balance + amount;\n      s_pendingRequests[hash] = PendingRequest({admin: adminAddress, balance: newBalance});\n    }\n  }\n\n  /**\n   * @dev register upkeep on KeeperRegistry contract and emit RegistrationApproved event\n   */\n  function approve(\n    string memory name,\n    address upkeepContract,\n    uint32 gasLimit,\n    address adminAddress,\n    bytes calldata checkData,\n    bytes32 hash\n  ) external onlyOwner {\n    PendingRequest memory request = s_pendingRequests[hash];\n    if (request.admin == address(0)) {\n      revert RequestNotFound();\n    }\n    bytes32 expectedHash = keccak256(abi.encode(upkeepContract, gasLimit, adminAddress, checkData));\n    if (hash != expectedHash) {\n      revert HashMismatch();\n    }\n    delete s_pendingRequests[hash];\n    _approve(name, upkeepContract, gasLimit, adminAddress, checkData, request.balance, hash);\n  }\n\n  /**\n   * @notice cancel will remove a registration request and return the refunds to the msg.sender\n   * @param hash the request hash\n   */\n  function cancel(bytes32 hash) external {\n    PendingRequest memory request = s_pendingRequests[hash];\n    if (!(msg.sender == request.admin || msg.sender == owner())) {\n      revert OnlyAdminOrOwner();\n    }\n    if (request.admin == address(0)) {\n      revert RequestNotFound();\n    }\n    delete s_pendingRequests[hash];\n    bool success = LINK.transfer(msg.sender, request.balance);\n    if (!success) {\n      revert LinkTransferFailed(msg.sender);\n    }\n    emit RegistrationRejected(hash);\n  }\n\n  /**\n   * @notice owner calls this function to set if registration requests should be sent directly to the Keeper Registry\n   * @param autoApproveConfigType setting for auto-approve registrations\n   *                   note: autoApproveAllowedSenders list persists across config changes irrespective of type\n   * @param autoApproveMaxAllowed max number of registrations that can be auto approved\n   * @param keeperRegistry new keeper registry address\n   * @param minLINKJuels minimum LINK that new registrations should fund their upkeep with\n   */\n  function setRegistrationConfig(\n    AutoApproveType autoApproveConfigType,\n    uint16 autoApproveMaxAllowed,\n    address keeperRegistry,\n    uint96 minLINKJuels\n  ) public onlyOwner {\n    uint32 approvedCount = s_config.approvedCount;\n    s_config = Config({\n      autoApproveConfigType: autoApproveConfigType,\n      autoApproveMaxAllowed: autoApproveMaxAllowed,\n      approvedCount: approvedCount,\n      minLINKJuels: minLINKJuels,\n      keeperRegistry: KeeperRegistryBaseInterface(keeperRegistry)\n    });\n\n    emit ConfigChanged(autoApproveConfigType, autoApproveMaxAllowed, keeperRegistry, minLINKJuels);\n  }\n\n  /**\n   * @notice owner calls this function to set allowlist status for senderAddress\n   * @param senderAddress senderAddress to set the allowlist status for\n   * @param allowed true if senderAddress needs to be added to allowlist, false if needs to be removed\n   */\n  function setAutoApproveAllowedSender(address senderAddress, bool allowed) external onlyOwner {\n    s_autoApproveAllowedSenders[senderAddress] = allowed;\n\n    emit AutoApproveAllowedSenderSet(senderAddress, allowed);\n  }\n\n  /**\n   * @notice read the allowlist status of senderAddress\n   * @param senderAddress address to read the allowlist status for\n   */\n  function getAutoApproveAllowedSender(address senderAddress) external view returns (bool) {\n    return s_autoApproveAllowedSenders[senderAddress];\n  }\n\n  /**\n   * @notice read the current registration configuration\n   */\n  function getRegistrationConfig()\n    external\n    view\n    returns (\n      AutoApproveType autoApproveConfigType,\n      uint32 autoApproveMaxAllowed,\n      uint32 approvedCount,\n      address keeperRegistry,\n      uint256 minLINKJuels\n    )\n  {\n    Config memory config = s_config;\n    return (\n      config.autoApproveConfigType,\n      config.autoApproveMaxAllowed,\n      config.approvedCount,\n      address(config.keeperRegistry),\n      config.minLINKJuels\n    );\n  }\n\n  /**\n   * @notice gets the admin address and the current balance of a registration request\n   */\n  function getPendingRequest(bytes32 hash) external view returns (address, uint96) {\n    PendingRequest memory request = s_pendingRequests[hash];\n    return (request.admin, request.balance);\n  }\n\n  /**\n   * @notice Called when LINK is sent to the contract via `transferAndCall`\n   * @param sender Address of the sender transfering LINK\n   * @param amount Amount of LINK sent (specified in Juels)\n   * @param data Payload of the transaction\n   */\n  function onTokenTransfer(\n    address sender,\n    uint256 amount,\n    bytes calldata data\n  ) external onlyLINK permittedFunctionsForLINK(data) isActualAmount(amount, data) isActualSender(sender, data) {\n    if (data.length < 292) revert InvalidDataLength();\n    if (amount < s_config.minLINKJuels) {\n      revert InsufficientPayment();\n    }\n    (bool success, ) = address(this).delegatecall(data);\n    // calls register\n    if (!success) {\n      revert RegistrationRequestFailed();\n    }\n  }\n\n  //PRIVATE\n\n  /**\n   * @dev register upkeep on KeeperRegistry contract and emit RegistrationApproved event\n   */\n  function _approve(\n    string memory name,\n    address upkeepContract,\n    uint32 gasLimit,\n    address adminAddress,\n    bytes calldata checkData,\n    uint96 amount,\n    bytes32 hash\n  ) private {\n    KeeperRegistryBaseInterface keeperRegistry = s_config.keeperRegistry;\n\n    // register upkeep\n    uint256 upkeepId = keeperRegistry.registerUpkeep(upkeepContract, gasLimit, adminAddress, checkData);\n    // fund upkeep\n    bool success = LINK.transferAndCall(address(keeperRegistry), amount, abi.encode(upkeepId));\n    if (!success) {\n      revert LinkTransferFailed(address(keeperRegistry));\n    }\n\n    emit RegistrationApproved(hash, name, upkeepId);\n  }\n\n  /**\n   * @dev verify sender allowlist if needed and check max limit\n   */\n  function _shouldAutoApprove(Config memory config, address sender) private returns (bool) {\n    if (config.autoApproveConfigType == AutoApproveType.DISABLED) {\n      return false;\n    }\n    if (\n      config.autoApproveConfigType == AutoApproveType.ENABLED_SENDER_ALLOWLIST && (!s_autoApproveAllowedSenders[sender])\n    ) {\n      return false;\n    }\n    if (config.approvedCount < config.autoApproveMaxAllowed) {\n      return true;\n    }\n    return false;\n  }\n\n  //MODIFIERS\n\n  /**\n   * @dev Reverts if not sent from the LINK token\n   */\n  modifier onlyLINK() {\n    if (msg.sender != address(LINK)) {\n      revert OnlyLink();\n    }\n    _;\n  }\n\n  /**\n   * @dev Reverts if the given data does not begin with the `register` function selector\n   * @param _data The data payload of the request\n   */\n  modifier permittedFunctionsForLINK(bytes memory _data) {\n    bytes4 funcSelector;\n    assembly {\n      // solhint-disable-next-line avoid-low-level-calls\n      funcSelector := mload(add(_data, 32)) // First 32 bytes contain length of data\n    }\n    if (funcSelector != REGISTER_REQUEST_SELECTOR) {\n      revert FunctionNotPermitted();\n    }\n    _;\n  }\n\n  /**\n   * @dev Reverts if the actual amount passed does not match the expected amount\n   * @param expected amount that should match the actual amount\n   * @param data bytes\n   */\n  modifier isActualAmount(uint256 expected, bytes memory data) {\n    uint256 actual;\n    assembly {\n      actual := mload(add(data, 228))\n    }\n    if (expected != actual) {\n      revert AmountMismatch();\n    }\n    _;\n  }\n\n  /**\n   * @dev Reverts if the actual sender address does not match the expected sender address\n   * @param expected address that should match the actual sender address\n   * @param data bytes\n   */\n  modifier isActualSender(address expected, bytes memory data) {\n    address actual;\n    assembly {\n      actual := mload(add(data, 292))\n    }\n    if (expected != actual) {\n      revert SenderMismatch();\n    }\n    _;\n  }\n}\n"
    },
    "src/v0.8/dev/VRFCoordinatorV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/LinkTokenInterface.sol\";\nimport \"../interfaces/BlockhashStoreInterface.sol\";\nimport \"../interfaces/AggregatorV3Interface.sol\";\nimport \"../interfaces/VRFCoordinatorV2Interface.sol\";\nimport \"../interfaces/TypeAndVersionInterface.sol\";\nimport \"../interfaces/ERC677ReceiverInterface.sol\";\nimport \"./VRF.sol\";\nimport \"../ConfirmedOwner.sol\";\nimport \"../VRFConsumerBaseV2.sol\";\n\ncontract VRFCoordinatorV2 is\n  VRF,\n  ConfirmedOwner,\n  TypeAndVersionInterface,\n  VRFCoordinatorV2Interface,\n  ERC677ReceiverInterface\n{\n  LinkTokenInterface public immutable LINK;\n  AggregatorV3Interface public immutable LINK_ETH_FEED;\n  BlockhashStoreInterface public immutable BLOCKHASH_STORE;\n\n  // We need to maintain a list of consuming addresses.\n  // This bound ensures we are able to loop over them as needed.\n  // Should a user require more consumers, they can use multiple subscriptions.\n  uint16 public constant MAX_CONSUMERS = 100;\n  error TooManyConsumers();\n  error InsufficientBalance();\n  error InvalidConsumer(uint64 subId, address consumer);\n  error InvalidSubscription();\n  error OnlyCallableFromLink();\n  error InvalidCalldata();\n  error MustBeSubOwner(address owner);\n  error PendingRequestExists();\n  error MustBeRequestedOwner(address proposedOwner);\n  error BalanceInvariantViolated(uint256 internalBalance, uint256 externalBalance); // Should never happen\n  event FundsRecovered(address to, uint256 amount);\n  // We use the subscription struct (1 word)\n  // at fulfillment time.\n  struct Subscription {\n    // There are only 1e9*1e18 = 1e27 juels in existence, so the balance can fit in uint96 (2^96 ~ 7e28)\n    uint96 balance; // Common link balance used for all consumer requests.\n    uint64 reqCount; // For fee tiers\n  }\n  // We use the config for the mgmt APIs\n  struct SubscriptionConfig {\n    address owner; // Owner can fund/withdraw/cancel the sub.\n    address requestedOwner; // For safely transferring sub ownership.\n    // Maintains the list of keys in s_consumers.\n    // We do this for 2 reasons:\n    // 1. To be able to clean up all keys from s_consumers when canceling a subscription.\n    // 2. To be able to return the list of all consumers in getSubscription.\n    // Note that we need the s_consumers map to be able to directly check if a\n    // consumer is valid without reading all the consumers from storage.\n    address[] consumers;\n  }\n  // Note a nonce of 0 indicates an the consumer is not assigned to that subscription.\n  mapping(address => mapping(uint64 => uint64)) /* consumer */ /* subId */ /* nonce */\n    private s_consumers;\n  mapping(uint64 => SubscriptionConfig) /* subId */ /* subscriptionConfig */\n    private s_subscriptionConfigs;\n  mapping(uint64 => Subscription) /* subId */ /* subscription */\n    private s_subscriptions;\n  // We make the sub count public so that its possible to\n  // get all the current subscriptions via getSubscription.\n  uint64 private s_currentSubId;\n  // s_totalBalance tracks the total link sent to/from\n  // this contract through onTokenTransfer, cancelSubscription and oracleWithdraw.\n  // A discrepancy with this contract's link balance indicates someone\n  // sent tokens using transfer and so we may need to use recoverFunds.\n  uint96 private s_totalBalance;\n  event SubscriptionCreated(uint64 indexed subId, address owner);\n  event SubscriptionFunded(uint64 indexed subId, uint256 oldBalance, uint256 newBalance);\n  event SubscriptionConsumerAdded(uint64 indexed subId, address consumer);\n  event SubscriptionConsumerRemoved(uint64 indexed subId, address consumer);\n  event SubscriptionCanceled(uint64 indexed subId, address to, uint256 amount);\n  event SubscriptionOwnerTransferRequested(uint64 indexed subId, address from, address to);\n  event SubscriptionOwnerTransferred(uint64 indexed subId, address from, address to);\n\n  // Set this maximum to 200 to give us a 56 block window to fulfill\n  // the request before requiring the block hash feeder.\n  uint16 public constant MAX_REQUEST_CONFIRMATIONS = 200;\n  uint32 public constant MAX_NUM_WORDS = 500;\n  // 5k is plenty for an EXTCODESIZE call (2600) + warm CALL (100)\n  // and some arithmetic operations.\n  uint256 private constant GAS_FOR_CALL_EXACT_CHECK = 5_000;\n  error InvalidRequestConfirmations(uint16 have, uint16 min, uint16 max);\n  error GasLimitTooBig(uint32 have, uint32 want);\n  error NumWordsTooBig(uint32 have, uint32 want);\n  error ProvingKeyAlreadyRegistered(bytes32 keyHash);\n  error NoSuchProvingKey(bytes32 keyHash);\n  error InvalidLinkWeiPrice(int256 linkWei);\n  error InsufficientGasForConsumer(uint256 have, uint256 want);\n  error NoCorrespondingRequest();\n  error IncorrectCommitment();\n  error BlockhashNotInStore(uint256 blockNum);\n  error PaymentTooLarge();\n  error Reentrant();\n  struct RequestCommitment {\n    uint64 blockNum;\n    uint64 subId;\n    uint32 callbackGasLimit;\n    uint32 numWords;\n    address sender;\n  }\n  mapping(bytes32 => address) /* keyHash */ /* oracle */\n    private s_provingKeys;\n  bytes32[] private s_provingKeyHashes;\n  mapping(address => uint96) /* oracle */ /* LINK balance */\n    private s_withdrawableTokens;\n  mapping(uint256 => bytes32) /* requestID */ /* commitment */\n    private s_requestCommitments;\n  event ProvingKeyRegistered(bytes32 keyHash, address indexed oracle);\n  event ProvingKeyDeregistered(bytes32 keyHash, address indexed oracle);\n  event RandomWordsRequested(\n    bytes32 indexed keyHash,\n    uint256 requestId,\n    uint256 preSeed,\n    uint64 indexed subId,\n    uint16 minimumRequestConfirmations,\n    uint32 callbackGasLimit,\n    uint32 numWords,\n    address indexed sender\n  );\n  event RandomWordsFulfilled(uint256 indexed requestId, uint256 outputSeed, uint96 payment, bool success);\n\n  struct Config {\n    uint16 minimumRequestConfirmations;\n    uint32 maxGasLimit;\n    // Reentrancy protection.\n    bool reentrancyLock;\n    // stalenessSeconds is how long before we consider the feed price to be stale\n    // and fallback to fallbackWeiPerUnitLink.\n    uint32 stalenessSeconds;\n    // Gas to cover oracle payment after we calculate the payment.\n    // We make it configurable in case those operations are repriced.\n    uint32 gasAfterPaymentCalculation;\n  }\n  int256 private s_fallbackWeiPerUnitLink;\n  Config private s_config;\n  FeeConfig private s_feeConfig;\n  struct FeeConfig {\n    // Flat fee charged per fulfillment in millionths of link\n    // So fee range is [0, 2^32/10^6].\n    uint32 fulfillmentFlatFeeLinkPPMTier1;\n    uint32 fulfillmentFlatFeeLinkPPMTier2;\n    uint32 fulfillmentFlatFeeLinkPPMTier3;\n    uint32 fulfillmentFlatFeeLinkPPMTier4;\n    uint32 fulfillmentFlatFeeLinkPPMTier5;\n    uint24 reqsForTier2;\n    uint24 reqsForTier3;\n    uint24 reqsForTier4;\n    uint24 reqsForTier5;\n  }\n  event ConfigSet(\n    uint16 minimumRequestConfirmations,\n    uint32 maxGasLimit,\n    uint32 stalenessSeconds,\n    uint32 gasAfterPaymentCalculation,\n    int256 fallbackWeiPerUnitLink,\n    FeeConfig feeConfig\n  );\n\n  constructor(\n    address link,\n    address blockhashStore,\n    address linkEthFeed\n  ) ConfirmedOwner(msg.sender) {\n    LINK = LinkTokenInterface(link);\n    LINK_ETH_FEED = AggregatorV3Interface(linkEthFeed);\n    BLOCKHASH_STORE = BlockhashStoreInterface(blockhashStore);\n  }\n\n  /**\n   * @notice Registers a proving key to an oracle.\n   * @param oracle address of the oracle\n   * @param publicProvingKey key that oracle can use to submit vrf fulfillments\n   */\n  function registerProvingKey(address oracle, uint256[2] calldata publicProvingKey) external onlyOwner {\n    bytes32 kh = hashOfKey(publicProvingKey);\n    if (s_provingKeys[kh] != address(0)) {\n      revert ProvingKeyAlreadyRegistered(kh);\n    }\n    s_provingKeys[kh] = oracle;\n    s_provingKeyHashes.push(kh);\n    emit ProvingKeyRegistered(kh, oracle);\n  }\n\n  /**\n   * @notice Deregisters a proving key to an oracle.\n   * @param publicProvingKey key that oracle can use to submit vrf fulfillments\n   */\n  function deregisterProvingKey(uint256[2] calldata publicProvingKey) external onlyOwner {\n    bytes32 kh = hashOfKey(publicProvingKey);\n    address oracle = s_provingKeys[kh];\n    if (oracle == address(0)) {\n      revert NoSuchProvingKey(kh);\n    }\n    delete s_provingKeys[kh];\n    for (uint256 i = 0; i < s_provingKeyHashes.length; i++) {\n      if (s_provingKeyHashes[i] == kh) {\n        bytes32 last = s_provingKeyHashes[s_provingKeyHashes.length - 1];\n        // Copy last element and overwrite kh to be deleted with it\n        s_provingKeyHashes[i] = last;\n        s_provingKeyHashes.pop();\n      }\n    }\n    emit ProvingKeyDeregistered(kh, oracle);\n  }\n\n  /**\n   * @notice Returns the proving key hash key associated with this public key\n   * @param publicKey the key to return the hash of\n   */\n  function hashOfKey(uint256[2] memory publicKey) public pure returns (bytes32) {\n    return keccak256(abi.encode(publicKey));\n  }\n\n  /**\n   * @notice Sets the configuration of the vrfv2 coordinator\n   * @param minimumRequestConfirmations global min for request confirmations\n   * @param maxGasLimit global max for request gas limit\n   * @param stalenessSeconds if the eth/link feed is more stale then this, use the fallback price\n   * @param gasAfterPaymentCalculation gas used in doing accounting after completing the gas measurement\n   * @param fallbackWeiPerUnitLink fallback eth/link price in the case of a stale feed\n   * @param feeConfig fee tier configuration\n   */\n  function setConfig(\n    uint16 minimumRequestConfirmations,\n    uint32 maxGasLimit,\n    uint32 stalenessSeconds,\n    uint32 gasAfterPaymentCalculation,\n    int256 fallbackWeiPerUnitLink,\n    FeeConfig memory feeConfig\n  ) external onlyOwner {\n    if (minimumRequestConfirmations > MAX_REQUEST_CONFIRMATIONS) {\n      revert InvalidRequestConfirmations(\n        minimumRequestConfirmations,\n        minimumRequestConfirmations,\n        MAX_REQUEST_CONFIRMATIONS\n      );\n    }\n    if (fallbackWeiPerUnitLink <= 0) {\n      revert InvalidLinkWeiPrice(fallbackWeiPerUnitLink);\n    }\n    s_config = Config({\n      minimumRequestConfirmations: minimumRequestConfirmations,\n      maxGasLimit: maxGasLimit,\n      stalenessSeconds: stalenessSeconds,\n      gasAfterPaymentCalculation: gasAfterPaymentCalculation,\n      reentrancyLock: false\n    });\n    s_feeConfig = feeConfig;\n    s_fallbackWeiPerUnitLink = fallbackWeiPerUnitLink;\n    emit ConfigSet(\n      minimumRequestConfirmations,\n      maxGasLimit,\n      stalenessSeconds,\n      gasAfterPaymentCalculation,\n      fallbackWeiPerUnitLink,\n      s_feeConfig\n    );\n  }\n\n  function getConfig()\n    external\n    view\n    returns (\n      uint16 minimumRequestConfirmations,\n      uint32 maxGasLimit,\n      uint32 stalenessSeconds,\n      uint32 gasAfterPaymentCalculation\n    )\n  {\n    return (\n      s_config.minimumRequestConfirmations,\n      s_config.maxGasLimit,\n      s_config.stalenessSeconds,\n      s_config.gasAfterPaymentCalculation\n    );\n  }\n\n  function getFeeConfig()\n    external\n    view\n    returns (\n      uint32 fulfillmentFlatFeeLinkPPMTier1,\n      uint32 fulfillmentFlatFeeLinkPPMTier2,\n      uint32 fulfillmentFlatFeeLinkPPMTier3,\n      uint32 fulfillmentFlatFeeLinkPPMTier4,\n      uint32 fulfillmentFlatFeeLinkPPMTier5,\n      uint24 reqsForTier2,\n      uint24 reqsForTier3,\n      uint24 reqsForTier4,\n      uint24 reqsForTier5\n    )\n  {\n    return (\n      s_feeConfig.fulfillmentFlatFeeLinkPPMTier1,\n      s_feeConfig.fulfillmentFlatFeeLinkPPMTier2,\n      s_feeConfig.fulfillmentFlatFeeLinkPPMTier3,\n      s_feeConfig.fulfillmentFlatFeeLinkPPMTier4,\n      s_feeConfig.fulfillmentFlatFeeLinkPPMTier5,\n      s_feeConfig.reqsForTier2,\n      s_feeConfig.reqsForTier3,\n      s_feeConfig.reqsForTier4,\n      s_feeConfig.reqsForTier5\n    );\n  }\n\n  function getTotalBalance() external view returns (uint256) {\n    return s_totalBalance;\n  }\n\n  function getFallbackWeiPerUnitLink() external view returns (int256) {\n    return s_fallbackWeiPerUnitLink;\n  }\n\n  /**\n   * @notice Owner cancel subscription, sends remaining link directly to the subscription owner.\n   * @param subId subscription id\n   * @dev notably can be called even if there are pending requests, outstanding ones may fail onchain\n   */\n  function ownerCancelSubscription(uint64 subId) external onlyOwner {\n    if (s_subscriptionConfigs[subId].owner == address(0)) {\n      revert InvalidSubscription();\n    }\n    cancelSubscriptionHelper(subId, s_subscriptionConfigs[subId].owner);\n  }\n\n  /**\n   * @notice Recover link sent with transfer instead of transferAndCall.\n   * @param to address to send link to\n   */\n  function recoverFunds(address to) external onlyOwner {\n    uint256 externalBalance = LINK.balanceOf(address(this));\n    uint256 internalBalance = uint256(s_totalBalance);\n    if (internalBalance > externalBalance) {\n      revert BalanceInvariantViolated(internalBalance, externalBalance);\n    }\n    if (internalBalance < externalBalance) {\n      uint256 amount = externalBalance - internalBalance;\n      LINK.transfer(to, amount);\n      emit FundsRecovered(to, amount);\n    }\n    // If the balances are equal, nothing to be done.\n  }\n\n  /**\n   * @inheritdoc VRFCoordinatorV2Interface\n   */\n  function getRequestConfig()\n    external\n    view\n    override\n    returns (\n      uint16,\n      uint32,\n      bytes32[] memory\n    )\n  {\n    return (s_config.minimumRequestConfirmations, s_config.maxGasLimit, s_provingKeyHashes);\n  }\n\n  /**\n   * @inheritdoc VRFCoordinatorV2Interface\n   */\n  function requestRandomWords(\n    bytes32 keyHash,\n    uint64 subId,\n    uint16 requestConfirmations,\n    uint32 callbackGasLimit,\n    uint32 numWords\n  ) external override nonReentrant returns (uint256) {\n    // Input validation using the subscription storage.\n    if (s_subscriptionConfigs[subId].owner == address(0)) {\n      revert InvalidSubscription();\n    }\n    // Its important to ensure that the consumer is in fact who they say they\n    // are, otherwise they could use someone else's subscription balance.\n    // A nonce of 0 indicates consumer is not allocated to the sub.\n    uint64 currentNonce = s_consumers[msg.sender][subId];\n    if (currentNonce == 0) {\n      revert InvalidConsumer(subId, msg.sender);\n    }\n    // Input validation using the config storage word.\n    if (\n      requestConfirmations < s_config.minimumRequestConfirmations || requestConfirmations > MAX_REQUEST_CONFIRMATIONS\n    ) {\n      revert InvalidRequestConfirmations(\n        requestConfirmations,\n        s_config.minimumRequestConfirmations,\n        MAX_REQUEST_CONFIRMATIONS\n      );\n    }\n    // No lower bound on the requested gas limit. A user could request 0\n    // and they would simply be billed for the proof verification and wouldn't be\n    // able to do anything with the random value.\n    if (callbackGasLimit > s_config.maxGasLimit) {\n      revert GasLimitTooBig(callbackGasLimit, s_config.maxGasLimit);\n    }\n    if (numWords > MAX_NUM_WORDS) {\n      revert NumWordsTooBig(numWords, MAX_NUM_WORDS);\n    }\n    // Note we do not check whether the keyHash is valid to save gas.\n    // The consequence for users is that they can send requests\n    // for invalid keyHashes which will simply not be fulfilled.\n    uint64 nonce = currentNonce + 1;\n    (uint256 requestId, uint256 preSeed) = computeRequestId(keyHash, msg.sender, subId, nonce);\n\n    s_requestCommitments[requestId] = keccak256(\n      abi.encode(requestId, block.number, subId, callbackGasLimit, numWords, msg.sender)\n    );\n    emit RandomWordsRequested(\n      keyHash,\n      requestId,\n      preSeed,\n      subId,\n      requestConfirmations,\n      callbackGasLimit,\n      numWords,\n      msg.sender\n    );\n    s_consumers[msg.sender][subId] = nonce;\n\n    return requestId;\n  }\n\n  /**\n   * @notice Get request commitment\n   * @param requestId id of request\n   * @dev used to determine if a request is fulfilled or not\n   */\n  function getCommitment(uint256 requestId) external view returns (bytes32) {\n    return s_requestCommitments[requestId];\n  }\n\n  function computeRequestId(\n    bytes32 keyHash,\n    address sender,\n    uint64 subId,\n    uint64 nonce\n  ) private pure returns (uint256, uint256) {\n    uint256 preSeed = uint256(keccak256(abi.encode(keyHash, sender, subId, nonce)));\n    return (uint256(keccak256(abi.encode(keyHash, preSeed))), preSeed);\n  }\n\n  /**\n   * @dev calls target address with exactly gasAmount gas and data as calldata\n   * or reverts if at least gasAmount gas is not available.\n   */\n  function callWithExactGas(\n    uint256 gasAmount,\n    address target,\n    bytes memory data\n  ) private returns (bool success) {\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      let g := gas()\n      // Compute g -= GAS_FOR_CALL_EXACT_CHECK and check for underflow\n      // The gas actually passed to the callee is min(gasAmount, 63//64*gas available).\n      // We want to ensure that we revert if gasAmount >  63//64*gas available\n      // as we do not want to provide them with less, however that check itself costs\n      // gas.  GAS_FOR_CALL_EXACT_CHECK ensures we have at least enough gas to be able\n      // to revert if gasAmount >  63//64*gas available.\n      if lt(g, GAS_FOR_CALL_EXACT_CHECK) {\n        revert(0, 0)\n      }\n      g := sub(g, GAS_FOR_CALL_EXACT_CHECK)\n      // if g - g//64 <= gasAmount, revert\n      // (we subtract g//64 because of EIP-150)\n      if iszero(gt(sub(g, div(g, 64)), gasAmount)) {\n        revert(0, 0)\n      }\n      // solidity calls check that a contract actually exists at the destination, so we do the same\n      if iszero(extcodesize(target)) {\n        revert(0, 0)\n      }\n      // call and return whether we succeeded. ignore return data\n      // call(gas,addr,value,argsOffset,argsLength,retOffset,retLength)\n      success := call(gasAmount, target, 0, add(data, 0x20), mload(data), 0, 0)\n    }\n    return success;\n  }\n\n  function getRandomnessFromProof(Proof memory proof, RequestCommitment memory rc)\n    private\n    view\n    returns (\n      bytes32 keyHash,\n      uint256 requestId,\n      uint256 randomness\n    )\n  {\n    keyHash = hashOfKey(proof.pk);\n    // Only registered proving keys are permitted.\n    address oracle = s_provingKeys[keyHash];\n    if (oracle == address(0)) {\n      revert NoSuchProvingKey(keyHash);\n    }\n    requestId = uint256(keccak256(abi.encode(keyHash, proof.seed)));\n    bytes32 commitment = s_requestCommitments[requestId];\n    if (commitment == 0) {\n      revert NoCorrespondingRequest();\n    }\n    if (\n      commitment != keccak256(abi.encode(requestId, rc.blockNum, rc.subId, rc.callbackGasLimit, rc.numWords, rc.sender))\n    ) {\n      revert IncorrectCommitment();\n    }\n\n    bytes32 blockHash = blockhash(rc.blockNum);\n    if (blockHash == bytes32(0)) {\n      blockHash = BLOCKHASH_STORE.getBlockhash(rc.blockNum);\n      if (blockHash == bytes32(0)) {\n        revert BlockhashNotInStore(rc.blockNum);\n      }\n    }\n\n    // The seed actually used by the VRF machinery, mixing in the blockhash\n    uint256 actualSeed = uint256(keccak256(abi.encodePacked(proof.seed, blockHash)));\n    randomness = VRF.randomValueFromVRFProof(proof, actualSeed); // Reverts on failure\n  }\n\n  /*\n   * @notice Compute fee based on the request count\n   * @param reqCount number of requests\n   * @return feePPM fee in LINK PPM\n   */\n  function getFeeTier(uint64 reqCount) public view returns (uint32) {\n    FeeConfig memory fc = s_feeConfig;\n    if (0 <= reqCount && reqCount <= fc.reqsForTier2) {\n      return fc.fulfillmentFlatFeeLinkPPMTier1;\n    }\n    if (fc.reqsForTier2 < reqCount && reqCount <= fc.reqsForTier3) {\n      return fc.fulfillmentFlatFeeLinkPPMTier2;\n    }\n    if (fc.reqsForTier3 < reqCount && reqCount <= fc.reqsForTier4) {\n      return fc.fulfillmentFlatFeeLinkPPMTier3;\n    }\n    if (fc.reqsForTier4 < reqCount && reqCount <= fc.reqsForTier5) {\n      return fc.fulfillmentFlatFeeLinkPPMTier4;\n    }\n    return fc.fulfillmentFlatFeeLinkPPMTier5;\n  }\n\n  /*\n   * @notice Fulfill a randomness request\n   * @param proof contains the proof and randomness\n   * @param rc request commitment pre-image, committed to at request time\n   * @return payment amount billed to the subscription\n   * @dev simulated offchain to determine if sufficient balance is present to fulfill the request\n   */\n  function fulfillRandomWords(Proof memory proof, RequestCommitment memory rc) external nonReentrant returns (uint96) {\n    uint256 startGas = gasleft();\n    (bytes32 keyHash, uint256 requestId, uint256 randomness) = getRandomnessFromProof(proof, rc);\n\n    uint256[] memory randomWords = new uint256[](rc.numWords);\n    for (uint256 i = 0; i < rc.numWords; i++) {\n      randomWords[i] = uint256(keccak256(abi.encode(randomness, i)));\n    }\n\n    delete s_requestCommitments[requestId];\n    VRFConsumerBaseV2 v;\n    bytes memory resp = abi.encodeWithSelector(v.rawFulfillRandomWords.selector, requestId, randomWords);\n    // Call with explicitly the amount of callback gas requested\n    // Important to not let them exhaust the gas budget and avoid oracle payment.\n    // Do not allow any non-view/non-pure coordinator functions to be called\n    // during the consumers callback code via reentrancyLock.\n    // Note that callWithExactGas will revert if we do not have sufficient gas\n    // to give the callee their requested amount.\n    s_config.reentrancyLock = true;\n    bool success = callWithExactGas(rc.callbackGasLimit, rc.sender, resp);\n    s_config.reentrancyLock = false;\n\n    // Increment the req count for fee tier selection.\n    uint64 reqCount = s_subscriptions[rc.subId].reqCount;\n    s_subscriptions[rc.subId].reqCount += 1;\n\n    // We want to charge users exactly for how much gas they use in their callback.\n    // The gasAfterPaymentCalculation is meant to cover these additional operations where we\n    // decrement the subscription balance and increment the oracles withdrawable balance.\n    // We also add the flat link fee to the payment amount.\n    // Its specified in millionths of link, if s_config.fulfillmentFlatFeeLinkPPM = 1\n    // 1 link / 1e6 = 1e18 juels / 1e6 = 1e12 juels.\n    uint96 payment = calculatePaymentAmount(\n      startGas,\n      s_config.gasAfterPaymentCalculation,\n      getFeeTier(reqCount),\n      tx.gasprice\n    );\n    if (s_subscriptions[rc.subId].balance < payment) {\n      revert InsufficientBalance();\n    }\n    s_subscriptions[rc.subId].balance -= payment;\n    s_withdrawableTokens[s_provingKeys[keyHash]] += payment;\n    // Include payment in the event for tracking costs.\n    emit RandomWordsFulfilled(requestId, randomness, payment, success);\n    return payment;\n  }\n\n  // Get the amount of gas used for fulfillment\n  function calculatePaymentAmount(\n    uint256 startGas,\n    uint256 gasAfterPaymentCalculation,\n    uint32 fulfillmentFlatFeeLinkPPM,\n    uint256 weiPerUnitGas\n  ) internal view returns (uint96) {\n    int256 weiPerUnitLink;\n    weiPerUnitLink = getFeedData();\n    if (weiPerUnitLink <= 0) {\n      revert InvalidLinkWeiPrice(weiPerUnitLink);\n    }\n    // (1e18 juels/link) (wei/gas * gas) / (wei/link) = juels\n    uint256 paymentNoFee = (1e18 * weiPerUnitGas * (gasAfterPaymentCalculation + startGas - gasleft())) /\n      uint256(weiPerUnitLink);\n    uint256 fee = 1e12 * uint256(fulfillmentFlatFeeLinkPPM);\n    if (paymentNoFee > (1e27 - fee)) {\n      revert PaymentTooLarge(); // Payment + fee cannot be more than all of the link in existence.\n    }\n    return uint96(paymentNoFee + fee);\n  }\n\n  function getFeedData() private view returns (int256) {\n    uint32 stalenessSeconds = s_config.stalenessSeconds;\n    bool staleFallback = stalenessSeconds > 0;\n    uint256 timestamp;\n    int256 weiPerUnitLink;\n    (, weiPerUnitLink, , timestamp, ) = LINK_ETH_FEED.latestRoundData();\n    // solhint-disable-next-line not-rely-on-time\n    if (staleFallback && stalenessSeconds < block.timestamp - timestamp) {\n      weiPerUnitLink = s_fallbackWeiPerUnitLink;\n    }\n    return weiPerUnitLink;\n  }\n\n  /*\n   * @notice Oracle withdraw LINK earned through fulfilling requests\n   * @param recipient where to send the funds\n   * @param amount amount to withdraw\n   */\n  function oracleWithdraw(address recipient, uint96 amount) external nonReentrant {\n    if (s_withdrawableTokens[msg.sender] < amount) {\n      revert InsufficientBalance();\n    }\n    s_withdrawableTokens[msg.sender] -= amount;\n    s_totalBalance -= amount;\n    if (!LINK.transfer(recipient, amount)) {\n      revert InsufficientBalance();\n    }\n  }\n\n  function onTokenTransfer(\n    address, /* sender */\n    uint256 amount,\n    bytes calldata data\n  ) external override nonReentrant {\n    if (msg.sender != address(LINK)) {\n      revert OnlyCallableFromLink();\n    }\n    if (data.length != 32) {\n      revert InvalidCalldata();\n    }\n    uint64 subId = abi.decode(data, (uint64));\n    if (s_subscriptionConfigs[subId].owner == address(0)) {\n      revert InvalidSubscription();\n    }\n    // We do not check that the msg.sender is the subscription owner,\n    // anyone can fund a subscription.\n    uint256 oldBalance = s_subscriptions[subId].balance;\n    s_subscriptions[subId].balance += uint96(amount);\n    s_totalBalance += uint96(amount);\n    emit SubscriptionFunded(subId, oldBalance, oldBalance + amount);\n  }\n\n  function getCurrentSubId() external view returns (uint64) {\n    return s_currentSubId;\n  }\n\n  /**\n   * @inheritdoc VRFCoordinatorV2Interface\n   */\n  function getSubscription(uint64 subId)\n    external\n    view\n    override\n    returns (\n      uint96 balance,\n      uint64 reqCount,\n      address owner,\n      address[] memory consumers\n    )\n  {\n    if (s_subscriptionConfigs[subId].owner == address(0)) {\n      revert InvalidSubscription();\n    }\n    return (\n      s_subscriptions[subId].balance,\n      s_subscriptions[subId].reqCount,\n      s_subscriptionConfigs[subId].owner,\n      s_subscriptionConfigs[subId].consumers\n    );\n  }\n\n  /**\n   * @inheritdoc VRFCoordinatorV2Interface\n   */\n  function createSubscription() external override nonReentrant returns (uint64) {\n    s_currentSubId++;\n    uint64 currentSubId = s_currentSubId;\n    address[] memory consumers = new address[](0);\n    s_subscriptions[currentSubId] = Subscription({balance: 0, reqCount: 0});\n    s_subscriptionConfigs[currentSubId] = SubscriptionConfig({\n      owner: msg.sender,\n      requestedOwner: address(0),\n      consumers: consumers\n    });\n\n    emit SubscriptionCreated(currentSubId, msg.sender);\n    return currentSubId;\n  }\n\n  /**\n   * @inheritdoc VRFCoordinatorV2Interface\n   */\n  function requestSubscriptionOwnerTransfer(uint64 subId, address newOwner)\n    external\n    override\n    onlySubOwner(subId)\n    nonReentrant\n  {\n    // Proposing to address(0) would never be claimable so don't need to check.\n    if (s_subscriptionConfigs[subId].requestedOwner != newOwner) {\n      s_subscriptionConfigs[subId].requestedOwner = newOwner;\n      emit SubscriptionOwnerTransferRequested(subId, msg.sender, newOwner);\n    }\n  }\n\n  /**\n   * @inheritdoc VRFCoordinatorV2Interface\n   */\n  function acceptSubscriptionOwnerTransfer(uint64 subId) external override nonReentrant {\n    if (s_subscriptionConfigs[subId].owner == address(0)) {\n      revert InvalidSubscription();\n    }\n    if (s_subscriptionConfigs[subId].requestedOwner != msg.sender) {\n      revert MustBeRequestedOwner(s_subscriptionConfigs[subId].requestedOwner);\n    }\n    address oldOwner = s_subscriptionConfigs[subId].owner;\n    s_subscriptionConfigs[subId].owner = msg.sender;\n    s_subscriptionConfigs[subId].requestedOwner = address(0);\n    emit SubscriptionOwnerTransferred(subId, oldOwner, msg.sender);\n  }\n\n  /**\n   * @inheritdoc VRFCoordinatorV2Interface\n   */\n  function removeConsumer(uint64 subId, address consumer) external override onlySubOwner(subId) nonReentrant {\n    if (s_consumers[consumer][subId] == 0) {\n      revert InvalidConsumer(subId, consumer);\n    }\n    // Note bounded by MAX_CONSUMERS\n    address[] memory consumers = s_subscriptionConfigs[subId].consumers;\n    uint256 lastConsumerIndex = consumers.length - 1;\n    for (uint256 i = 0; i < consumers.length; i++) {\n      if (consumers[i] == consumer) {\n        address last = consumers[lastConsumerIndex];\n        // Storage write to preserve last element\n        s_subscriptionConfigs[subId].consumers[i] = last;\n        // Storage remove last element\n        s_subscriptionConfigs[subId].consumers.pop();\n        break;\n      }\n    }\n    delete s_consumers[consumer][subId];\n    emit SubscriptionConsumerRemoved(subId, consumer);\n  }\n\n  /**\n   * @inheritdoc VRFCoordinatorV2Interface\n   */\n  function addConsumer(uint64 subId, address consumer) external override onlySubOwner(subId) nonReentrant {\n    // Already maxed, cannot add any more consumers.\n    if (s_subscriptionConfigs[subId].consumers.length == MAX_CONSUMERS) {\n      revert TooManyConsumers();\n    }\n    if (s_consumers[consumer][subId] != 0) {\n      // Idempotence - do nothing if already added.\n      // Ensures uniqueness in s_subscriptions[subId].consumers.\n      return;\n    }\n    // Initialize the nonce to 1, indicating the consumer is allocated.\n    s_consumers[consumer][subId] = 1;\n    s_subscriptionConfigs[subId].consumers.push(consumer);\n\n    emit SubscriptionConsumerAdded(subId, consumer);\n  }\n\n  /**\n   * @inheritdoc VRFCoordinatorV2Interface\n   */\n  function cancelSubscription(uint64 subId, address to) external override onlySubOwner(subId) nonReentrant {\n    if (pendingRequestExists(subId)) {\n      revert PendingRequestExists();\n    }\n    cancelSubscriptionHelper(subId, to);\n  }\n\n  function cancelSubscriptionHelper(uint64 subId, address to) private nonReentrant {\n    SubscriptionConfig memory subConfig = s_subscriptionConfigs[subId];\n    Subscription memory sub = s_subscriptions[subId];\n    uint96 balance = sub.balance;\n    // Note bounded by MAX_CONSUMERS;\n    // If no consumers, does nothing.\n    for (uint256 i = 0; i < subConfig.consumers.length; i++) {\n      delete s_consumers[subConfig.consumers[i]][subId];\n    }\n    delete s_subscriptionConfigs[subId];\n    delete s_subscriptions[subId];\n    s_totalBalance -= balance;\n    if (!LINK.transfer(to, uint256(balance))) {\n      revert InsufficientBalance();\n    }\n    emit SubscriptionCanceled(subId, to, balance);\n  }\n\n  /**\n   * @inheritdoc VRFCoordinatorV2Interface\n   * @dev Looping is bounded to MAX_CONSUMERS*(number of keyhashes).\n   * @dev Used to disable subscription canceling while outstanding request are present.\n   */\n  function pendingRequestExists(uint64 subId) public view override returns (bool) {\n    SubscriptionConfig memory subConfig = s_subscriptionConfigs[subId];\n    for (uint256 i = 0; i < subConfig.consumers.length; i++) {\n      for (uint256 j = 0; j < s_provingKeyHashes.length; j++) {\n        (uint256 reqId, ) = computeRequestId(\n          s_provingKeyHashes[j],\n          subConfig.consumers[i],\n          subId,\n          s_consumers[subConfig.consumers[i]][subId]\n        );\n        if (s_requestCommitments[reqId] != 0) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  modifier onlySubOwner(uint64 subId) {\n    address owner = s_subscriptionConfigs[subId].owner;\n    if (owner == address(0)) {\n      revert InvalidSubscription();\n    }\n    if (msg.sender != owner) {\n      revert MustBeSubOwner(owner);\n    }\n    _;\n  }\n\n  modifier nonReentrant() {\n    if (s_config.reentrancyLock) {\n      revert Reentrant();\n    }\n    _;\n  }\n\n  /**\n   * @notice The type and version of this contract\n   * @return Type and version string\n   */\n  function typeAndVersion() external pure virtual override returns (string memory) {\n    return \"VRFCoordinatorV2 1.0.0\";\n  }\n}\n"
    },
    "src/v0.8/interfaces/BlockhashStoreInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface BlockhashStoreInterface {\n  function getBlockhash(uint256 number) external view returns (bytes32);\n}\n"
    },
    "src/v0.8/dev/VRF.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/** ****************************************************************************\n  * @notice Verification of verifiable-random-function (VRF) proofs, following\n  * @notice https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-5.3\n  * @notice See https://eprint.iacr.org/2017/099.pdf for security proofs.\n\n  * @dev Bibliographic references:\n\n  * @dev Goldberg, et al., \"Verifiable Random Functions (VRFs)\", Internet Draft\n  * @dev draft-irtf-cfrg-vrf-05, IETF, Aug 11 2019,\n  * @dev https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05\n\n  * @dev Papadopoulos, et al., \"Making NSEC5 Practical for DNSSEC\", Cryptology\n  * @dev ePrint Archive, Report 2017/099, https://eprint.iacr.org/2017/099.pdf\n  * ****************************************************************************\n  * @dev USAGE\n\n  * @dev The main entry point is randomValueFromVRFProof. See its docstring.\n  * ****************************************************************************\n  * @dev PURPOSE\n\n  * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\n  * @dev to Vera the verifier in such a way that Vera can be sure he's not\n  * @dev making his output up to suit himself. Reggie provides Vera a public key\n  * @dev to which he knows the secret key. Each time Vera provides a seed to\n  * @dev Reggie, he gives back a value which is computed completely\n  * @dev deterministically from the seed and the secret key.\n\n  * @dev Reggie provides a proof by which Vera can verify that the output was\n  * @dev correctly computed once Reggie tells it to her, but without that proof,\n  * @dev the output is computationally indistinguishable to her from a uniform\n  * @dev random sample from the output space.\n\n  * @dev The purpose of this contract is to perform that verification.\n  * ****************************************************************************\n  * @dev DESIGN NOTES\n\n  * @dev The VRF algorithm verified here satisfies the full uniqueness, full\n  * @dev collision resistance, and full pseudo-randomness security properties.\n  * @dev See \"SECURITY PROPERTIES\" below, and\n  * @dev https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-3\n\n  * @dev An elliptic curve point is generally represented in the solidity code\n  * @dev as a uint256[2], corresponding to its affine coordinates in\n  * @dev GF(FIELD_SIZE).\n\n  * @dev For the sake of efficiency, this implementation deviates from the spec\n  * @dev in some minor ways:\n\n  * @dev - Keccak hash rather than the SHA256 hash recommended in\n  * @dev   https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-5.5\n  * @dev   Keccak costs much less gas on the EVM, and provides similar security.\n\n  * @dev - Secp256k1 curve instead of the P-256 or ED25519 curves recommended in\n  * @dev   https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-5.5\n  * @dev   For curve-point multiplication, it's much cheaper to abuse ECRECOVER\n\n  * @dev - hashToCurve recursively hashes until it finds a curve x-ordinate. On\n  * @dev   the EVM, this is slightly more efficient than the recommendation in\n  * @dev   https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-5.4.1.1\n  * @dev   step 5, to concatenate with a nonce then hash, and rehash with the\n  * @dev   nonce updated until a valid x-ordinate is found.\n\n  * @dev - hashToCurve does not include a cipher version string or the byte 0x1\n  * @dev   in the hash message, as recommended in step 5.B of the draft\n  * @dev   standard. They are unnecessary here because no variation in the\n  * @dev   cipher suite is allowed.\n\n  * @dev - Similarly, the hash input in scalarFromCurvePoints does not include a\n  * @dev   commitment to the cipher suite, either, which differs from step 2 of\n  * @dev   https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-5.4.3\n  * @dev   . Also, the hash input is the concatenation of the uncompressed\n  * @dev   points, not the compressed points as recommended in step 3.\n\n  * @dev - In the calculation of the challenge value \"c\", the \"u\" value (i.e.\n  * @dev   the value computed by Reggie as the nonce times the secp256k1\n  * @dev   generator point, see steps 5 and 7 of\n  * @dev   https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-5.3\n  * @dev   ) is replaced by its ethereum address, i.e. the lower 160 bits of the\n  * @dev   keccak hash of the original u. This is because we only verify the\n  * @dev   calculation of u up to its address, by abusing ECRECOVER.\n  * ****************************************************************************\n  * @dev   SECURITY PROPERTIES\n\n  * @dev Here are the security properties for this VRF:\n\n  * @dev Full uniqueness: For any seed and valid VRF public key, there is\n  * @dev   exactly one VRF output which can be proved to come from that seed, in\n  * @dev   the sense that the proof will pass verifyVRFProof.\n\n  * @dev Full collision resistance: It's cryptographically infeasible to find\n  * @dev   two seeds with same VRF output from a fixed, valid VRF key\n\n  * @dev Full pseudorandomness: Absent the proofs that the VRF outputs are\n  * @dev   derived from a given seed, the outputs are computationally\n  * @dev   indistinguishable from randomness.\n\n  * @dev https://eprint.iacr.org/2017/099.pdf, Appendix B contains the proofs\n  * @dev for these properties.\n\n  * @dev For secp256k1, the key validation described in section\n  * @dev https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-5.6\n  * @dev is unnecessary, because secp256k1 has cofactor 1, and the\n  * @dev representation of the public key used here (affine x- and y-ordinates\n  * @dev of the secp256k1 point on the standard y^2=x^3+7 curve) cannot refer to\n  * @dev the point at infinity.\n  * ****************************************************************************\n  * @dev OTHER SECURITY CONSIDERATIONS\n  *\n  * @dev The seed input to the VRF could in principle force an arbitrary amount\n  * @dev of work in hashToCurve, by requiring extra rounds of hashing and\n  * @dev checking whether that's yielded the x ordinate of a secp256k1 point.\n  * @dev However, under the Random Oracle Model the probability of choosing a\n  * @dev point which forces n extra rounds in hashToCurve is 2⁻ⁿ. The base cost\n  * @dev for calling hashToCurve is about 25,000 gas, and each round of checking\n  * @dev for a valid x ordinate costs about 15,555 gas, so to find a seed for\n  * @dev which hashToCurve would cost more than 2,017,000 gas, one would have to\n  * @dev try, in expectation, about 2¹²⁸ seeds, which is infeasible for any\n  * @dev foreseeable computational resources. (25,000 + 128 * 15,555 < 2,017,000.)\n\n  * @dev Since the gas block limit for the Ethereum main net is 10,000,000 gas,\n  * @dev this means it is infeasible for an adversary to prevent correct\n  * @dev operation of this contract by choosing an adverse seed.\n\n  * @dev (See TestMeasureHashToCurveGasCost for verification of the gas cost for\n  * @dev hashToCurve.)\n\n  * @dev It may be possible to make a secure constant-time hashToCurve function.\n  * @dev See notes in hashToCurve docstring.\n*/\ncontract VRF {\n  // See https://www.secg.org/sec2-v2.pdf, section 2.4.1, for these constants.\n  // Number of points in Secp256k1\n  uint256 private constant GROUP_ORDER = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141;\n  // Prime characteristic of the galois field over which Secp256k1 is defined\n  uint256 private constant FIELD_SIZE =\n    // solium-disable-next-line indentation\n    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F;\n  uint256 private constant WORD_LENGTH_BYTES = 0x20;\n\n  // (base^exponent) % FIELD_SIZE\n  // Cribbed from https://medium.com/@rbkhmrcr/precompiles-solidity-e5d29bd428c4\n  function bigModExp(uint256 base, uint256 exponent) internal view returns (uint256 exponentiation) {\n    uint256 callResult;\n    uint256[6] memory bigModExpContractInputs;\n    bigModExpContractInputs[0] = WORD_LENGTH_BYTES; // Length of base\n    bigModExpContractInputs[1] = WORD_LENGTH_BYTES; // Length of exponent\n    bigModExpContractInputs[2] = WORD_LENGTH_BYTES; // Length of modulus\n    bigModExpContractInputs[3] = base;\n    bigModExpContractInputs[4] = exponent;\n    bigModExpContractInputs[5] = FIELD_SIZE;\n    uint256[1] memory output;\n    assembly {\n      // solhint-disable-line no-inline-assembly\n      callResult := staticcall(\n        not(0), // Gas cost: no limit\n        0x05, // Bigmodexp contract address\n        bigModExpContractInputs,\n        0xc0, // Length of input segment: 6*0x20-bytes\n        output,\n        0x20 // Length of output segment\n      )\n    }\n    if (callResult == 0) {\n      revert(\"bigModExp failure!\");\n    }\n    return output[0];\n  }\n\n  // Let q=FIELD_SIZE. q % 4 = 3, ∴ x≡r^2 mod q ⇒ x^SQRT_POWER≡±r mod q.  See\n  // https://en.wikipedia.org/wiki/Modular_square_root#Prime_or_prime_power_modulus\n  uint256 private constant SQRT_POWER = (FIELD_SIZE + 1) >> 2;\n\n  // Computes a s.t. a^2 = x in the field. Assumes a exists\n  function squareRoot(uint256 x) internal view returns (uint256) {\n    return bigModExp(x, SQRT_POWER);\n  }\n\n  // The value of y^2 given that (x,y) is on secp256k1.\n  function ySquared(uint256 x) internal pure returns (uint256) {\n    // Curve is y^2=x^3+7. See section 2.4.1 of https://www.secg.org/sec2-v2.pdf\n    uint256 xCubed = mulmod(x, mulmod(x, x, FIELD_SIZE), FIELD_SIZE);\n    return addmod(xCubed, 7, FIELD_SIZE);\n  }\n\n  // True iff p is on secp256k1\n  function isOnCurve(uint256[2] memory p) internal pure returns (bool) {\n    // Section 2.3.6. in https://www.secg.org/sec1-v2.pdf\n    // requires each ordinate to be in [0, ..., FIELD_SIZE-1]\n    require(p[0] < FIELD_SIZE, \"invalid x-ordinate\");\n    require(p[1] < FIELD_SIZE, \"invalid y-ordinate\");\n    return ySquared(p[0]) == mulmod(p[1], p[1], FIELD_SIZE);\n  }\n\n  // Hash x uniformly into {0, ..., FIELD_SIZE-1}.\n  function fieldHash(bytes memory b) internal pure returns (uint256 x_) {\n    x_ = uint256(keccak256(b));\n    // Rejecting if x >= FIELD_SIZE corresponds to step 2.1 in section 2.3.4 of\n    // http://www.secg.org/sec1-v2.pdf , which is part of the definition of\n    // string_to_point in the IETF draft\n    while (x_ >= FIELD_SIZE) {\n      x_ = uint256(keccak256(abi.encodePacked(x_)));\n    }\n  }\n\n  // Hash b to a random point which hopefully lies on secp256k1. The y ordinate\n  // is always even, due to\n  // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-5.4.1.1\n  // step 5.C, which references arbitrary_string_to_point, defined in\n  // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-5.5 as\n  // returning the point with given x ordinate, and even y ordinate.\n  function newCandidateSecp256k1Point(bytes memory b) internal view returns (uint256[2] memory p) {\n    unchecked {\n      p[0] = fieldHash(b);\n      p[1] = squareRoot(ySquared(p[0]));\n      if (p[1] % 2 == 1) {\n        // Note that 0 <= p[1] < FIELD_SIZE\n        // so this cannot wrap, we use unchecked to save gas.\n        p[1] = FIELD_SIZE - p[1];\n      }\n    }\n  }\n\n  // Domain-separation tag for initial hash in hashToCurve. Corresponds to\n  // vrf.go/hashToCurveHashPrefix\n  uint256 internal constant HASH_TO_CURVE_HASH_PREFIX = 1;\n\n  // Cryptographic hash function onto the curve.\n  //\n  // Corresponds to algorithm in section 5.4.1.1 of the draft standard. (But see\n  // DESIGN NOTES above for slight differences.)\n  //\n  // TODO(alx): Implement a bounded-computation hash-to-curve, as described in\n  // \"Construction of Rational Points on Elliptic Curves over Finite Fields\"\n  // http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.831.5299&rep=rep1&type=pdf\n  // and suggested by\n  // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-01#section-5.2.2\n  // (Though we can't used exactly that because secp256k1's j-invariant is 0.)\n  //\n  // This would greatly simplify the analysis in \"OTHER SECURITY CONSIDERATIONS\"\n  // https://www.pivotaltracker.com/story/show/171120900\n  function hashToCurve(uint256[2] memory pk, uint256 input) internal view returns (uint256[2] memory rv) {\n    rv = newCandidateSecp256k1Point(abi.encodePacked(HASH_TO_CURVE_HASH_PREFIX, pk, input));\n    while (!isOnCurve(rv)) {\n      rv = newCandidateSecp256k1Point(abi.encodePacked(rv[0]));\n    }\n  }\n\n  /** *********************************************************************\n   * @notice Check that product==scalar*multiplicand\n   *\n   * @dev Based on Vitalik Buterin's idea in ethresear.ch post cited below.\n   *\n   * @param multiplicand: secp256k1 point\n   * @param scalar: non-zero GF(GROUP_ORDER) scalar\n   * @param product: secp256k1 expected to be multiplier * multiplicand\n   * @return verifies true iff product==scalar*multiplicand, with cryptographically high probability\n   */\n  function ecmulVerify(\n    uint256[2] memory multiplicand,\n    uint256 scalar,\n    uint256[2] memory product\n  ) internal pure returns (bool verifies) {\n    require(scalar != 0, \"zero scalar\"); // Rules out an ecrecover failure case\n    uint256 x = multiplicand[0]; // x ordinate of multiplicand\n    uint8 v = multiplicand[1] % 2 == 0 ? 27 : 28; // parity of y ordinate\n    // https://ethresear.ch/t/you-can-kinda-abuse-ecrecover-to-do-ecmul-in-secp256k1-today/2384/9\n    // Point corresponding to address ecrecover(0, v, x, s=scalar*x) is\n    // (x⁻¹ mod GROUP_ORDER) * (scalar * x * multiplicand - 0 * g), i.e.\n    // scalar*multiplicand. See https://crypto.stackexchange.com/a/18106\n    bytes32 scalarTimesX = bytes32(mulmod(scalar, x, GROUP_ORDER));\n    address actual = ecrecover(bytes32(0), v, bytes32(x), scalarTimesX);\n    // Explicit conversion to address takes bottom 160 bits\n    address expected = address(uint160(uint256(keccak256(abi.encodePacked(product)))));\n    return (actual == expected);\n  }\n\n  // Returns x1/z1-x2/z2=(x1z2-x2z1)/(z1z2) in projective coordinates on P¹(𝔽ₙ)\n  function projectiveSub(\n    uint256 x1,\n    uint256 z1,\n    uint256 x2,\n    uint256 z2\n  ) internal pure returns (uint256 x3, uint256 z3) {\n    unchecked {\n      uint256 num1 = mulmod(z2, x1, FIELD_SIZE);\n      // Note this cannot wrap since x2 is a point in [0, FIELD_SIZE-1]\n      // we use unchecked to save gas.\n      uint256 num2 = mulmod(FIELD_SIZE - x2, z1, FIELD_SIZE);\n      (x3, z3) = (addmod(num1, num2, FIELD_SIZE), mulmod(z1, z2, FIELD_SIZE));\n    }\n  }\n\n  // Returns x1/z1*x2/z2=(x1x2)/(z1z2), in projective coordinates on P¹(𝔽ₙ)\n  function projectiveMul(\n    uint256 x1,\n    uint256 z1,\n    uint256 x2,\n    uint256 z2\n  ) internal pure returns (uint256 x3, uint256 z3) {\n    (x3, z3) = (mulmod(x1, x2, FIELD_SIZE), mulmod(z1, z2, FIELD_SIZE));\n  }\n\n  /** **************************************************************************\n        @notice Computes elliptic-curve sum, in projective co-ordinates\n\n        @dev Using projective coordinates avoids costly divisions\n\n        @dev To use this with p and q in affine coordinates, call\n        @dev projectiveECAdd(px, py, qx, qy). This will return\n        @dev the addition of (px, py, 1) and (qx, qy, 1), in the\n        @dev secp256k1 group.\n\n        @dev This can be used to calculate the z which is the inverse to zInv\n        @dev in isValidVRFOutput. But consider using a faster\n        @dev re-implementation such as ProjectiveECAdd in the golang vrf package.\n\n        @dev This function assumes [px,py,1],[qx,qy,1] are valid projective\n             coordinates of secp256k1 points. That is safe in this contract,\n             because this method is only used by linearCombination, which checks\n             points are on the curve via ecrecover.\n        **************************************************************************\n        @param px The first affine coordinate of the first summand\n        @param py The second affine coordinate of the first summand\n        @param qx The first affine coordinate of the second summand\n        @param qy The second affine coordinate of the second summand\n\n        (px,py) and (qx,qy) must be distinct, valid secp256k1 points.\n        **************************************************************************\n        Return values are projective coordinates of [px,py,1]+[qx,qy,1] as points\n        on secp256k1, in P²(𝔽ₙ)\n        @return sx\n        @return sy\n        @return sz\n    */\n  function projectiveECAdd(\n    uint256 px,\n    uint256 py,\n    uint256 qx,\n    uint256 qy\n  )\n    internal\n    pure\n    returns (\n      uint256 sx,\n      uint256 sy,\n      uint256 sz\n    )\n  {\n    unchecked {\n      // See \"Group law for E/K : y^2 = x^3 + ax + b\", in section 3.1.2, p. 80,\n      // \"Guide to Elliptic Curve Cryptography\" by Hankerson, Menezes and Vanstone\n      // We take the equations there for (sx,sy), and homogenize them to\n      // projective coordinates. That way, no inverses are required, here, and we\n      // only need the one inverse in affineECAdd.\n\n      // We only need the \"point addition\" equations from Hankerson et al. Can\n      // skip the \"point doubling\" equations because p1 == p2 is cryptographically\n      // impossible, and required not to be the case in linearCombination.\n\n      // Add extra \"projective coordinate\" to the two points\n      (uint256 z1, uint256 z2) = (1, 1);\n\n      // (lx, lz) = (qy-py)/(qx-px), i.e., gradient of secant line.\n      // Cannot wrap since px and py are in [0, FIELD_SIZE-1]\n      uint256 lx = addmod(qy, FIELD_SIZE - py, FIELD_SIZE);\n      uint256 lz = addmod(qx, FIELD_SIZE - px, FIELD_SIZE);\n\n      uint256 dx; // Accumulates denominator from sx calculation\n      // sx=((qy-py)/(qx-px))^2-px-qx\n      (sx, dx) = projectiveMul(lx, lz, lx, lz); // ((qy-py)/(qx-px))^2\n      (sx, dx) = projectiveSub(sx, dx, px, z1); // ((qy-py)/(qx-px))^2-px\n      (sx, dx) = projectiveSub(sx, dx, qx, z2); // ((qy-py)/(qx-px))^2-px-qx\n\n      uint256 dy; // Accumulates denominator from sy calculation\n      // sy=((qy-py)/(qx-px))(px-sx)-py\n      (sy, dy) = projectiveSub(px, z1, sx, dx); // px-sx\n      (sy, dy) = projectiveMul(sy, dy, lx, lz); // ((qy-py)/(qx-px))(px-sx)\n      (sy, dy) = projectiveSub(sy, dy, py, z1); // ((qy-py)/(qx-px))(px-sx)-py\n\n      if (dx != dy) {\n        // Cross-multiply to put everything over a common denominator\n        sx = mulmod(sx, dy, FIELD_SIZE);\n        sy = mulmod(sy, dx, FIELD_SIZE);\n        sz = mulmod(dx, dy, FIELD_SIZE);\n      } else {\n        // Already over a common denominator, use that for z ordinate\n        sz = dx;\n      }\n    }\n  }\n\n  // p1+p2, as affine points on secp256k1.\n  //\n  // invZ must be the inverse of the z returned by projectiveECAdd(p1, p2).\n  // It is computed off-chain to save gas.\n  //\n  // p1 and p2 must be distinct, because projectiveECAdd doesn't handle\n  // point doubling.\n  function affineECAdd(\n    uint256[2] memory p1,\n    uint256[2] memory p2,\n    uint256 invZ\n  ) internal pure returns (uint256[2] memory) {\n    uint256 x;\n    uint256 y;\n    uint256 z;\n    (x, y, z) = projectiveECAdd(p1[0], p1[1], p2[0], p2[1]);\n    require(mulmod(z, invZ, FIELD_SIZE) == 1, \"invZ must be inverse of z\");\n    // Clear the z ordinate of the projective representation by dividing through\n    // by it, to obtain the affine representation\n    return [mulmod(x, invZ, FIELD_SIZE), mulmod(y, invZ, FIELD_SIZE)];\n  }\n\n  // True iff address(c*p+s*g) == lcWitness, where g is generator. (With\n  // cryptographically high probability.)\n  function verifyLinearCombinationWithGenerator(\n    uint256 c,\n    uint256[2] memory p,\n    uint256 s,\n    address lcWitness\n  ) internal pure returns (bool) {\n    // Rule out ecrecover failure modes which return address 0.\n    unchecked {\n      require(lcWitness != address(0), \"bad witness\");\n      uint8 v = (p[1] % 2 == 0) ? 27 : 28; // parity of y-ordinate of p\n      // Note this cannot wrap (X - Y % X), but we use unchecked to save\n      // gas.\n      bytes32 pseudoHash = bytes32(GROUP_ORDER - mulmod(p[0], s, GROUP_ORDER)); // -s*p[0]\n      bytes32 pseudoSignature = bytes32(mulmod(c, p[0], GROUP_ORDER)); // c*p[0]\n      // https://ethresear.ch/t/you-can-kinda-abuse-ecrecover-to-do-ecmul-in-secp256k1-today/2384/9\n      // The point corresponding to the address returned by\n      // ecrecover(-s*p[0],v,p[0],c*p[0]) is\n      // (p[0]⁻¹ mod GROUP_ORDER)*(c*p[0]-(-s)*p[0]*g)=c*p+s*g.\n      // See https://crypto.stackexchange.com/a/18106\n      // https://bitcoin.stackexchange.com/questions/38351/ecdsa-v-r-s-what-is-v\n      address computed = ecrecover(pseudoHash, v, bytes32(p[0]), pseudoSignature);\n      return computed == lcWitness;\n    }\n  }\n\n  // c*p1 + s*p2. Requires cp1Witness=c*p1 and sp2Witness=s*p2. Also\n  // requires cp1Witness != sp2Witness (which is fine for this application,\n  // since it is cryptographically impossible for them to be equal. In the\n  // (cryptographically impossible) case that a prover accidentally derives\n  // a proof with equal c*p1 and s*p2, they should retry with a different\n  // proof nonce.) Assumes that all points are on secp256k1\n  // (which is checked in verifyVRFProof below.)\n  function linearCombination(\n    uint256 c,\n    uint256[2] memory p1,\n    uint256[2] memory cp1Witness,\n    uint256 s,\n    uint256[2] memory p2,\n    uint256[2] memory sp2Witness,\n    uint256 zInv\n  ) internal pure returns (uint256[2] memory) {\n    unchecked {\n      // Note we are relying on the wrap around here\n      require((cp1Witness[0] % FIELD_SIZE) != (sp2Witness[0] % FIELD_SIZE), \"points in sum must be distinct\");\n      require(ecmulVerify(p1, c, cp1Witness), \"First mul check failed\");\n      require(ecmulVerify(p2, s, sp2Witness), \"Second mul check failed\");\n      return affineECAdd(cp1Witness, sp2Witness, zInv);\n    }\n  }\n\n  // Domain-separation tag for the hash taken in scalarFromCurvePoints.\n  // Corresponds to scalarFromCurveHashPrefix in vrf.go\n  uint256 internal constant SCALAR_FROM_CURVE_POINTS_HASH_PREFIX = 2;\n\n  // Pseudo-random number from inputs. Matches vrf.go/scalarFromCurvePoints, and\n  // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-5.4.3\n  // The draft calls (in step 7, via the definition of string_to_int, in\n  // https://datatracker.ietf.org/doc/html/rfc8017#section-4.2 ) for taking the\n  // first hash without checking that it corresponds to a number less than the\n  // group order, which will lead to a slight bias in the sample.\n  //\n  // TODO(alx): We could save a bit of gas by following the standard here and\n  // using the compressed representation of the points, if we collated the y\n  // parities into a single bytes32.\n  // https://www.pivotaltracker.com/story/show/171120588\n  function scalarFromCurvePoints(\n    uint256[2] memory hash,\n    uint256[2] memory pk,\n    uint256[2] memory gamma,\n    address uWitness,\n    uint256[2] memory v\n  ) internal pure returns (uint256 s) {\n    return uint256(keccak256(abi.encodePacked(SCALAR_FROM_CURVE_POINTS_HASH_PREFIX, hash, pk, gamma, v, uWitness)));\n  }\n\n  // True if (gamma, c, s) is a correctly constructed randomness proof from pk\n  // and seed. zInv must be the inverse of the third ordinate from\n  // projectiveECAdd applied to cGammaWitness and sHashWitness. Corresponds to\n  // section 5.3 of the IETF draft.\n  //\n  // TODO(alx): Since I'm only using pk in the ecrecover call, I could only pass\n  // the x ordinate, and the parity of the y ordinate in the top bit of uWitness\n  // (which I could make a uint256 without using any extra space.) Would save\n  // about 2000 gas. https://www.pivotaltracker.com/story/show/170828567\n  function verifyVRFProof(\n    uint256[2] memory pk,\n    uint256[2] memory gamma,\n    uint256 c,\n    uint256 s,\n    uint256 seed,\n    address uWitness,\n    uint256[2] memory cGammaWitness,\n    uint256[2] memory sHashWitness,\n    uint256 zInv\n  ) internal view {\n    unchecked {\n      require(isOnCurve(pk), \"public key is not on curve\");\n      require(isOnCurve(gamma), \"gamma is not on curve\");\n      require(isOnCurve(cGammaWitness), \"cGammaWitness is not on curve\");\n      require(isOnCurve(sHashWitness), \"sHashWitness is not on curve\");\n      // Step 5. of IETF draft section 5.3 (pk corresponds to 5.3's Y, and here\n      // we use the address of u instead of u itself. Also, here we add the\n      // terms instead of taking the difference, and in the proof construction in\n      // vrf.GenerateProof, we correspondingly take the difference instead of\n      // taking the sum as they do in step 7 of section 5.1.)\n      require(verifyLinearCombinationWithGenerator(c, pk, s, uWitness), \"addr(c*pk+s*g)!=_uWitness\");\n      // Step 4. of IETF draft section 5.3 (pk corresponds to Y, seed to alpha_string)\n      uint256[2] memory hash = hashToCurve(pk, seed);\n      // Step 6. of IETF draft section 5.3, but see note for step 5 about +/- terms\n      uint256[2] memory v = linearCombination(c, gamma, cGammaWitness, s, hash, sHashWitness, zInv);\n      // Steps 7. and 8. of IETF draft section 5.3\n      uint256 derivedC = scalarFromCurvePoints(hash, pk, gamma, uWitness, v);\n      require(c == derivedC, \"invalid proof\");\n    }\n  }\n\n  // Domain-separation tag for the hash used as the final VRF output.\n  // Corresponds to vrfRandomOutputHashPrefix in vrf.go\n  uint256 internal constant VRF_RANDOM_OUTPUT_HASH_PREFIX = 3;\n\n  struct Proof {\n    uint256[2] pk;\n    uint256[2] gamma;\n    uint256 c;\n    uint256 s;\n    uint256 seed;\n    address uWitness;\n    uint256[2] cGammaWitness;\n    uint256[2] sHashWitness;\n    uint256 zInv;\n  }\n\n  /* ***************************************************************************\n     * @notice Returns proof's output, if proof is valid. Otherwise reverts\n\n     * @param proof vrf proof components\n     * @param seed  seed used to generate the vrf output\n     *\n     * Throws if proof is invalid, otherwise:\n     * @return output i.e., the random output implied by the proof\n     * ***************************************************************************\n     */\n  function randomValueFromVRFProof(Proof memory proof, uint256 seed) internal view returns (uint256 output) {\n    verifyVRFProof(\n      proof.pk,\n      proof.gamma,\n      proof.c,\n      proof.s,\n      seed,\n      proof.uWitness,\n      proof.cGammaWitness,\n      proof.sHashWitness,\n      proof.zInv\n    );\n    output = uint256(keccak256(abi.encode(VRF_RANDOM_OUTPUT_HASH_PREFIX, proof.gamma)));\n  }\n}\n"
    },
    "src/v0.8/tests/VRFCoordinatorV2TestHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../dev/VRFCoordinatorV2.sol\";\n\ncontract VRFCoordinatorV2TestHelper is VRFCoordinatorV2 {\n  uint96 s_paymentAmount;\n  uint256 s_gasStart;\n\n  constructor(\n    address link,\n    address blockhashStore,\n    address linkEthFeed\n  )\n    // solhint-disable-next-line no-empty-blocks\n    VRFCoordinatorV2(link, blockhashStore, linkEthFeed)\n  {\n    /* empty */\n  }\n\n  function calculatePaymentAmountTest(\n    uint256 gasAfterPaymentCalculation,\n    uint32 fulfillmentFlatFeeLinkPPM,\n    uint256 weiPerUnitGas\n  ) external {\n    s_paymentAmount = calculatePaymentAmount(\n      gasleft(),\n      gasAfterPaymentCalculation,\n      fulfillmentFlatFeeLinkPPM,\n      weiPerUnitGas\n    );\n  }\n\n  function getPaymentAmount() public view returns (uint96) {\n    return s_paymentAmount;\n  }\n\n  function getGasStart() public view returns (uint256) {\n    return s_gasStart;\n  }\n}\n"
    },
    "src/v0.8/tests/VRFTestHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../dev/VRF.sol\";\n\n/** ***********************************************************************\n    @notice Testing harness for VRF.sol, exposing its internal methods. Not to\n    @notice be used for production.\n*/\ncontract VRFTestHelper is VRF {\n  function bigModExp_(uint256 base, uint256 exponent) public view returns (uint256) {\n    return super.bigModExp(base, exponent);\n  }\n\n  function squareRoot_(uint256 x) public view returns (uint256) {\n    return super.squareRoot(x);\n  }\n\n  function ySquared_(uint256 x) public pure returns (uint256) {\n    return super.ySquared(x);\n  }\n\n  function fieldHash_(bytes memory b) public pure returns (uint256) {\n    return super.fieldHash(b);\n  }\n\n  function hashToCurve_(uint256[2] memory pk, uint256 x) public view returns (uint256[2] memory) {\n    return super.hashToCurve(pk, x);\n  }\n\n  function ecmulVerify_(\n    uint256[2] memory x,\n    uint256 scalar,\n    uint256[2] memory q\n  ) public pure returns (bool) {\n    return super.ecmulVerify(x, scalar, q);\n  }\n\n  function projectiveECAdd_(\n    uint256 px,\n    uint256 py,\n    uint256 qx,\n    uint256 qy\n  )\n    public\n    pure\n    returns (\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    return super.projectiveECAdd(px, py, qx, qy);\n  }\n\n  function affineECAdd_(\n    uint256[2] memory p1,\n    uint256[2] memory p2,\n    uint256 invZ\n  ) public pure returns (uint256[2] memory) {\n    return super.affineECAdd(p1, p2, invZ);\n  }\n\n  function verifyLinearCombinationWithGenerator_(\n    uint256 c,\n    uint256[2] memory p,\n    uint256 s,\n    address lcWitness\n  ) public pure returns (bool) {\n    return super.verifyLinearCombinationWithGenerator(c, p, s, lcWitness);\n  }\n\n  function linearCombination_(\n    uint256 c,\n    uint256[2] memory p1,\n    uint256[2] memory cp1Witness,\n    uint256 s,\n    uint256[2] memory p2,\n    uint256[2] memory sp2Witness,\n    uint256 zInv\n  ) public pure returns (uint256[2] memory) {\n    return super.linearCombination(c, p1, cp1Witness, s, p2, sp2Witness, zInv);\n  }\n\n  function scalarFromCurvePoints_(\n    uint256[2] memory hash,\n    uint256[2] memory pk,\n    uint256[2] memory gamma,\n    address uWitness,\n    uint256[2] memory v\n  ) public pure returns (uint256) {\n    return super.scalarFromCurvePoints(hash, pk, gamma, uWitness, v);\n  }\n\n  function isOnCurve_(uint256[2] memory p) public pure returns (bool) {\n    return super.isOnCurve(p);\n  }\n\n  function verifyVRFProof_(\n    uint256[2] memory pk,\n    uint256[2] memory gamma,\n    uint256 c,\n    uint256 s,\n    uint256 seed,\n    address uWitness,\n    uint256[2] memory cGammaWitness,\n    uint256[2] memory sHashWitness,\n    uint256 zInv\n  ) public view {\n    super.verifyVRFProof(pk, gamma, c, s, seed, uWitness, cGammaWitness, sHashWitness, zInv);\n  }\n\n  function randomValueFromVRFProof_(Proof memory proof, uint256 seed) public view returns (uint256 output) {\n    return super.randomValueFromVRFProof(proof, seed);\n  }\n}\n"
    },
    "src/v0.8/dev/OptimismValidator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../interfaces/AggregatorValidatorInterface.sol\";\nimport \"../interfaces/TypeAndVersionInterface.sol\";\nimport \"../interfaces/AccessControllerInterface.sol\";\nimport \"../interfaces/AggregatorV3Interface.sol\";\nimport \"../SimpleWriteAccessController.sol\";\n\n/* ./dev dependencies - to be moved from ./dev after audit */\nimport \"./interfaces/FlagsInterface.sol\";\nimport \"./interfaces/ForwarderInterface.sol\";\nimport \"./interfaces/OptimismSequencerUptimeFeedInterface.sol\";\nimport \"@eth-optimism/contracts/L1/messaging/IL1CrossDomainMessenger.sol\";\nimport \"@eth-optimism/contracts/L2/messaging/IL2ERC20Bridge.sol\";\nimport \"./vendor/openzeppelin-solidity/v4.3.1/contracts/utils/Address.sol\";\n\n/**\n * @title OptimismValidator - makes xDomain L2 Flags contract call (using L2 xDomain Forwarder contract)\n * @notice Allows to raise and lower Flags on the Optimism L2 network through L1 bridge\n *  - The internal AccessController controls the access of the validate method\n */\ncontract OptimismValidator is TypeAndVersionInterface, AggregatorValidatorInterface, SimpleWriteAccessController {\n  int256 private constant ANSWER_SEQ_OFFLINE = 1;\n  uint32 private s_gasLimit;\n\n  address public immutable L1_CROSS_DOMAIN_MESSENGER_ADDRESS;\n  address public immutable L2_UPTIME_FEED_ADDR;\n\n  /**\n   * @notice emitted when a new ETH withdrawal from L2 was requested\n   * @param amount of funds to withdraw\n   */\n  event L2WithdrawalRequested(uint256 amount);\n\n  /**\n   * @notice emitted when gas cost to spend on L2 is updated\n   * @param gasLimit updated gas cost\n   */\n  event GasLimitUpdated(uint32 gasLimit);\n\n  /**\n   * @param l1CrossDomainMessengerAddress address the L1CrossDomainMessenger contract address\n   * @param l2UptimeFeedAddr the address of the OptimismSequencerUptimeFeed contract address\n   * @param gasLimit the gasLimit to use for sending a message from L1 to L2\n   */\n  constructor(\n    address l1CrossDomainMessengerAddress,\n    address l2UptimeFeedAddr,\n    uint32 gasLimit\n  ) {\n    require(l1CrossDomainMessengerAddress != address(0), \"Invalid xDomain Messenger address\");\n    require(l2UptimeFeedAddr != address(0), \"Invalid OptimismSequencerUptimeFeed contract address\");\n    L1_CROSS_DOMAIN_MESSENGER_ADDRESS = l1CrossDomainMessengerAddress;\n    L2_UPTIME_FEED_ADDR = l2UptimeFeedAddr;\n    s_gasLimit = gasLimit;\n  }\n\n  /**\n   * @notice versions:\n   *\n   * - OptimismValidator 0.1.0: initial release\n   * - OptimismValidator 1.0.0: change target of L2 sequencer status update\n   *   - now calls `updateStatus` on an L2 OptimismSequencerUptimeFeed contract instead of\n   *     directly calling the Flags contract\n   *\n   * @inheritdoc TypeAndVersionInterface\n   */\n  function typeAndVersion() external pure virtual override returns (string memory) {\n    return \"OptimismValidator 1.0.0\";\n  }\n\n  /**\n   * @notice sets the new gas cost to spend when sending cross chain message\n   * @param gasLimit the updated gas cost\n   */\n  function setGasLimit(uint32 gasLimit) external onlyOwner {\n    s_gasLimit = gasLimit;\n    emit GasLimitUpdated(gasLimit);\n  }\n\n  /**\n   * @notice fetches the gas cost of sending a cross chain message\n   */\n  function getGasLimit() external view returns (uint32) {\n    return s_gasLimit;\n  }\n\n  /**\n   * @notice makes this contract payable\n   * @dev receives funds:\n   *  - to use them (if configured) to pay for L2 execution on L1\n   *  - when withdrawing funds from L2 xDomain alias address (pay for L2 execution on L2)\n   */\n  receive() external payable {}\n\n  /**\n   * @notice withdraws all funds available in this contract to the msg.sender\n   * @dev only owner can call this\n   */\n  function withdrawFunds() external onlyOwner {\n    address payable recipient = payable(msg.sender);\n    uint256 amount = address(this).balance;\n    Address.sendValue(recipient, amount);\n  }\n\n  /**\n   * @notice withdraws all funds available in this contract to the address specified\n   * @dev only owner can call this\n   * @param recipient address where to send the funds\n   */\n  function withdrawFundsTo(address payable recipient) external onlyOwner {\n    uint256 amount = address(this).balance;\n    Address.sendValue(recipient, amount);\n  }\n\n  /**\n   * @notice validate method sends an xDomain L2 tx to update Flags contract, in case of change from `previousAnswer`.\n   * @dev A message is created on the Optimism L1 Inbox contract. This method is accessed controlled.\n   * @param previousAnswer previous aggregator answer\n   * @param currentAnswer new aggregator answer - value of 1 considers the service offline.\n   */\n  function validate(\n    uint256, /* previousRoundId */\n    int256 previousAnswer,\n    uint256, /* currentRoundId */\n    int256 currentAnswer\n  ) external override checkAccess returns (bool) {\n    // Avoids resending to L2 the same tx on every call\n    if (previousAnswer == currentAnswer) {\n      return true;\n    }\n\n    // Encode the OptimismSequencerUptimeFeed call\n    bytes4 selector = OptimismSequencerUptimeFeedInterface.updateStatus.selector;\n    bool status = currentAnswer == ANSWER_SEQ_OFFLINE;\n    uint64 timestamp = uint64(block.timestamp);\n    // Encode `status` and `timestamp`\n    bytes memory message = abi.encodeWithSelector(selector, status, timestamp);\n    // Make the xDomain call\n    IL1CrossDomainMessenger(L1_CROSS_DOMAIN_MESSENGER_ADDRESS).sendMessage(\n      L2_UPTIME_FEED_ADDR, // target\n      message,\n      s_gasLimit\n    );\n    // return success\n    return true;\n  }\n}\n"
    },
    "src/v0.8/interfaces/AccessControllerInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AccessControllerInterface {\n  function hasAccess(address user, bytes calldata data) external view returns (bool);\n}\n"
    },
    "src/v0.8/SimpleWriteAccessController.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./ConfirmedOwner.sol\";\nimport \"./interfaces/AccessControllerInterface.sol\";\n\n/**\n * @title SimpleWriteAccessController\n * @notice Gives access to accounts explicitly added to an access list by the\n * controller's owner.\n * @dev does not make any special permissions for externally, see\n * SimpleReadAccessController for that.\n */\ncontract SimpleWriteAccessController is AccessControllerInterface, ConfirmedOwner {\n  bool public checkEnabled;\n  mapping(address => bool) internal accessList;\n\n  event AddedAccess(address user);\n  event RemovedAccess(address user);\n  event CheckAccessEnabled();\n  event CheckAccessDisabled();\n\n  constructor() ConfirmedOwner(msg.sender) {\n    checkEnabled = true;\n  }\n\n  /**\n   * @notice Returns the access of an address\n   * @param _user The address to query\n   */\n  function hasAccess(address _user, bytes memory) public view virtual override returns (bool) {\n    return accessList[_user] || !checkEnabled;\n  }\n\n  /**\n   * @notice Adds an address to the access list\n   * @param _user The address to add\n   */\n  function addAccess(address _user) external onlyOwner {\n    if (!accessList[_user]) {\n      accessList[_user] = true;\n\n      emit AddedAccess(_user);\n    }\n  }\n\n  /**\n   * @notice Removes an address from the access list\n   * @param _user The address to remove\n   */\n  function removeAccess(address _user) external onlyOwner {\n    if (accessList[_user]) {\n      accessList[_user] = false;\n\n      emit RemovedAccess(_user);\n    }\n  }\n\n  /**\n   * @notice makes the access check enforced\n   */\n  function enableAccessCheck() external onlyOwner {\n    if (!checkEnabled) {\n      checkEnabled = true;\n\n      emit CheckAccessEnabled();\n    }\n  }\n\n  /**\n   * @notice makes the access check unenforced\n   */\n  function disableAccessCheck() external onlyOwner {\n    if (checkEnabled) {\n      checkEnabled = false;\n\n      emit CheckAccessDisabled();\n    }\n  }\n\n  /**\n   * @dev reverts if the caller does not have access\n   */\n  modifier checkAccess() {\n    require(hasAccess(msg.sender, msg.data), \"No access\");\n    _;\n  }\n}\n"
    },
    "src/v0.8/dev/interfaces/FlagsInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\ninterface FlagsInterface {\n  function getFlag(address) external view returns (bool);\n\n  function getFlags(address[] calldata) external view returns (bool[] memory);\n\n  function raiseFlag(address) external;\n\n  function raiseFlags(address[] calldata) external;\n\n  function lowerFlag(address) external;\n\n  function lowerFlags(address[] calldata) external;\n\n  function setRaisingAccessController(address) external;\n\n  function setLoweringAccessController(address) external;\n}\n"
    },
    "src/v0.8/dev/interfaces/ForwarderInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title ForwarderInterface - forwards a call to a target, under some conditions\ninterface ForwarderInterface {\n  /**\n   * @notice forward calls the `target` with `data`\n   * @param target contract address to be called\n   * @param data to send to target contract\n   */\n  function forward(address target, bytes memory data) external;\n}\n"
    },
    "src/v0.8/dev/interfaces/OptimismSequencerUptimeFeedInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface OptimismSequencerUptimeFeedInterface {\n  function updateStatus(bool status, uint64 timestamp) external;\n}\n"
    },
    "@eth-optimism/contracts/L1/messaging/IL1CrossDomainMessenger.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/* Library Imports */\nimport { Lib_OVMCodec } from \"../../libraries/codec/Lib_OVMCodec.sol\";\n\n/* Interface Imports */\nimport { ICrossDomainMessenger } from \"../../libraries/bridge/ICrossDomainMessenger.sol\";\n\n/**\n * @title IL1CrossDomainMessenger\n */\ninterface IL1CrossDomainMessenger is ICrossDomainMessenger {\n    /*******************\n     * Data Structures *\n     *******************/\n\n    struct L2MessageInclusionProof {\n        bytes32 stateRoot;\n        Lib_OVMCodec.ChainBatchHeader stateRootBatchHeader;\n        Lib_OVMCodec.ChainInclusionProof stateRootProof;\n        bytes stateTrieWitness;\n        bytes storageTrieWitness;\n    }\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * Relays a cross domain message to a contract.\n     * @param _target Target contract address.\n     * @param _sender Message sender address.\n     * @param _message Message to send to the target.\n     * @param _messageNonce Nonce for the provided message.\n     * @param _proof Inclusion proof for the given message.\n     */\n    function relayMessage(\n        address _target,\n        address _sender,\n        bytes memory _message,\n        uint256 _messageNonce,\n        L2MessageInclusionProof memory _proof\n    ) external;\n\n    /**\n     * Replays a cross domain message to the target messenger.\n     * @param _target Target contract address.\n     * @param _sender Original sender address.\n     * @param _message Message to send to the target.\n     * @param _queueIndex CTC Queue index for the message to replay.\n     * @param _oldGasLimit Original gas limit used to send the message.\n     * @param _newGasLimit New gas limit to be used for this message.\n     */\n    function replayMessage(\n        address _target,\n        address _sender,\n        bytes memory _message,\n        uint256 _queueIndex,\n        uint32 _oldGasLimit,\n        uint32 _newGasLimit\n    ) external;\n}\n"
    },
    "@eth-optimism/contracts/L2/messaging/IL2ERC20Bridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/**\n * @title IL2ERC20Bridge\n */\ninterface IL2ERC20Bridge {\n    /**********\n     * Events *\n     **********/\n\n    event WithdrawalInitiated(\n        address indexed _l1Token,\n        address indexed _l2Token,\n        address indexed _from,\n        address _to,\n        uint256 _amount,\n        bytes _data\n    );\n\n    event DepositFinalized(\n        address indexed _l1Token,\n        address indexed _l2Token,\n        address indexed _from,\n        address _to,\n        uint256 _amount,\n        bytes _data\n    );\n\n    event DepositFailed(\n        address indexed _l1Token,\n        address indexed _l2Token,\n        address indexed _from,\n        address _to,\n        uint256 _amount,\n        bytes _data\n    );\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * @dev get the address of the corresponding L1 bridge contract.\n     * @return Address of the corresponding L1 bridge contract.\n     */\n    function l1TokenBridge() external returns (address);\n\n    /**\n     * @dev initiate a withdraw of some tokens to the caller's account on L1\n     * @param _l2Token Address of L2 token where withdrawal was initiated.\n     * @param _amount Amount of the token to withdraw.\n     * param _l1Gas Unused, but included for potential forward compatibility considerations.\n     * @param _data Optional data to forward to L1. This data is provided\n     *        solely as a convenience for external contracts. Aside from enforcing a maximum\n     *        length, these contracts provide no guarantees about its content.\n     */\n    function withdraw(\n        address _l2Token,\n        uint256 _amount,\n        uint32 _l1Gas,\n        bytes calldata _data\n    ) external;\n\n    /**\n     * @dev initiate a withdraw of some token to a recipient's account on L1.\n     * @param _l2Token Address of L2 token where withdrawal is initiated.\n     * @param _to L1 adress to credit the withdrawal to.\n     * @param _amount Amount of the token to withdraw.\n     * param _l1Gas Unused, but included for potential forward compatibility considerations.\n     * @param _data Optional data to forward to L1. This data is provided\n     *        solely as a convenience for external contracts. Aside from enforcing a maximum\n     *        length, these contracts provide no guarantees about its content.\n     */\n    function withdrawTo(\n        address _l2Token,\n        address _to,\n        uint256 _amount,\n        uint32 _l1Gas,\n        bytes calldata _data\n    ) external;\n\n    /*************************\n     * Cross-chain Functions *\n     *************************/\n\n    /**\n     * @dev Complete a deposit from L1 to L2, and credits funds to the recipient's balance of this\n     * L2 token. This call will fail if it did not originate from a corresponding deposit in\n     * L1StandardTokenBridge.\n     * @param _l1Token Address for the l1 token this is called with\n     * @param _l2Token Address for the l2 token this is called with\n     * @param _from Account to pull the deposit from on L2.\n     * @param _to Address to receive the withdrawal at\n     * @param _amount Amount of the token to withdraw\n     * @param _data Data provider by the sender on L1. This data is provided\n     *        solely as a convenience for external contracts. Aside from enforcing a maximum\n     *        length, these contracts provide no guarantees about its content.\n     */\n    function finalizeDeposit(\n        address _l1Token,\n        address _l2Token,\n        address _from,\n        address _to,\n        uint256 _amount,\n        bytes calldata _data\n    ) external;\n}\n"
    },
    "src/v0.8/dev/vendor/openzeppelin-solidity/v4.3.1/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n  /**\n   * @dev Returns true if `account` is a contract.\n   *\n   * [IMPORTANT]\n   * ====\n   * It is unsafe to assume that an address for which this function returns\n   * false is an externally-owned account (EOA) and not a contract.\n   *\n   * Among others, `isContract` will return false for the following\n   * types of addresses:\n   *\n   *  - an externally-owned account\n   *  - a contract in construction\n   *  - an address where a contract will be created\n   *  - an address where a contract lived, but was destroyed\n   * ====\n   */\n  function isContract(address account) internal view returns (bool) {\n    // This method relies on extcodesize, which returns 0 for contracts in\n    // construction, since the code is only stored at the end of the\n    // constructor execution.\n\n    uint256 size;\n    assembly {\n      size := extcodesize(account)\n    }\n    return size > 0;\n  }\n\n  /**\n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n   * `recipient`, forwarding all available gas and reverting on errors.\n   *\n   * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n   * of certain opcodes, possibly making contracts go over the 2300 gas limit\n   * imposed by `transfer`, making them unable to receive funds via\n   * `transfer`. {sendValue} removes this limitation.\n   *\n   * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n   *\n   * IMPORTANT: because control is transferred to `recipient`, care must be\n   * taken to not create reentrancy vulnerabilities. Consider using\n   * {ReentrancyGuard} or the\n   * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n   */\n  function sendValue(address payable recipient, uint256 amount) internal {\n    require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n    (bool success, ) = recipient.call{value: amount}(\"\");\n    require(success, \"Address: unable to send value, recipient may have reverted\");\n  }\n\n  /**\n   * @dev Performs a Solidity function call using a low level `call`. A\n   * plain `call` is an unsafe replacement for a function call: use this\n   * function instead.\n   *\n   * If `target` reverts with a revert reason, it is bubbled up by this\n   * function (like regular Solidity function calls).\n   *\n   * Returns the raw returned data. To convert to the expected return value,\n   * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n   *\n   * Requirements:\n   *\n   * - `target` must be a contract.\n   * - calling `target` with `data` must not revert.\n   *\n   * _Available since v3.1._\n   */\n  function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n    return functionCall(target, data, \"Address: low-level call failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n   * `errorMessage` as a fallback revert reason when `target` reverts.\n   *\n   * _Available since v3.1._\n   */\n  function functionCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    return functionCallWithValue(target, data, 0, errorMessage);\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n   * but also transferring `value` wei to `target`.\n   *\n   * Requirements:\n   *\n   * - the calling contract must have an ETH balance of at least `value`.\n   * - the called Solidity function must be `payable`.\n   *\n   * _Available since v3.1._\n   */\n  function functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 value\n  ) internal returns (bytes memory) {\n    return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n   * with `errorMessage` as a fallback revert reason when `target` reverts.\n   *\n   * _Available since v3.1._\n   */\n  function functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 value,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    require(address(this).balance >= value, \"Address: insufficient balance for call\");\n    require(isContract(target), \"Address: call to non-contract\");\n\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\n    return verifyCallResult(success, returndata, errorMessage);\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n   * but performing a static call.\n   *\n   * _Available since v3.3._\n   */\n  function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n    return functionStaticCall(target, data, \"Address: low-level static call failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n   * but performing a static call.\n   *\n   * _Available since v3.3._\n   */\n  function functionStaticCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal view returns (bytes memory) {\n    require(isContract(target), \"Address: static call to non-contract\");\n\n    (bool success, bytes memory returndata) = target.staticcall(data);\n    return verifyCallResult(success, returndata, errorMessage);\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n   * but performing a delegate call.\n   *\n   * _Available since v3.4._\n   */\n  function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n    return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n   * but performing a delegate call.\n   *\n   * _Available since v3.4._\n   */\n  function functionDelegateCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    require(isContract(target), \"Address: delegate call to non-contract\");\n\n    (bool success, bytes memory returndata) = target.delegatecall(data);\n    return verifyCallResult(success, returndata, errorMessage);\n  }\n\n  /**\n   * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n   * revert reason using the provided one.\n   *\n   * _Available since v4.3._\n   */\n  function verifyCallResult(\n    bool success,\n    bytes memory returndata,\n    string memory errorMessage\n  ) internal pure returns (bytes memory) {\n    if (success) {\n      return returndata;\n    } else {\n      // Look for revert reason and bubble it up if present\n      if (returndata.length > 0) {\n        // The easiest way to bubble the revert reason is using memory via assembly\n\n        assembly {\n          let returndata_size := mload(returndata)\n          revert(add(32, returndata), returndata_size)\n        }\n      } else {\n        revert(errorMessage);\n      }\n    }\n  }\n}\n"
    },
    "@eth-optimism/contracts/libraries/codec/Lib_OVMCodec.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/* Library Imports */\nimport { Lib_RLPReader } from \"../rlp/Lib_RLPReader.sol\";\nimport { Lib_RLPWriter } from \"../rlp/Lib_RLPWriter.sol\";\nimport { Lib_BytesUtils } from \"../utils/Lib_BytesUtils.sol\";\nimport { Lib_Bytes32Utils } from \"../utils/Lib_Bytes32Utils.sol\";\n\n/**\n * @title Lib_OVMCodec\n */\nlibrary Lib_OVMCodec {\n    /*********\n     * Enums *\n     *********/\n\n    enum QueueOrigin {\n        SEQUENCER_QUEUE,\n        L1TOL2_QUEUE\n    }\n\n    /***********\n     * Structs *\n     ***********/\n\n    struct EVMAccount {\n        uint256 nonce;\n        uint256 balance;\n        bytes32 storageRoot;\n        bytes32 codeHash;\n    }\n\n    struct ChainBatchHeader {\n        uint256 batchIndex;\n        bytes32 batchRoot;\n        uint256 batchSize;\n        uint256 prevTotalElements;\n        bytes extraData;\n    }\n\n    struct ChainInclusionProof {\n        uint256 index;\n        bytes32[] siblings;\n    }\n\n    struct Transaction {\n        uint256 timestamp;\n        uint256 blockNumber;\n        QueueOrigin l1QueueOrigin;\n        address l1TxOrigin;\n        address entrypoint;\n        uint256 gasLimit;\n        bytes data;\n    }\n\n    struct TransactionChainElement {\n        bool isSequenced;\n        uint256 queueIndex; // QUEUED TX ONLY\n        uint256 timestamp; // SEQUENCER TX ONLY\n        uint256 blockNumber; // SEQUENCER TX ONLY\n        bytes txData; // SEQUENCER TX ONLY\n    }\n\n    struct QueueElement {\n        bytes32 transactionHash;\n        uint40 timestamp;\n        uint40 blockNumber;\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /**\n     * Encodes a standard OVM transaction.\n     * @param _transaction OVM transaction to encode.\n     * @return Encoded transaction bytes.\n     */\n    function encodeTransaction(Transaction memory _transaction)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return\n            abi.encodePacked(\n                _transaction.timestamp,\n                _transaction.blockNumber,\n                _transaction.l1QueueOrigin,\n                _transaction.l1TxOrigin,\n                _transaction.entrypoint,\n                _transaction.gasLimit,\n                _transaction.data\n            );\n    }\n\n    /**\n     * Hashes a standard OVM transaction.\n     * @param _transaction OVM transaction to encode.\n     * @return Hashed transaction\n     */\n    function hashTransaction(Transaction memory _transaction) internal pure returns (bytes32) {\n        return keccak256(encodeTransaction(_transaction));\n    }\n\n    /**\n     * @notice Decodes an RLP-encoded account state into a useful struct.\n     * @param _encoded RLP-encoded account state.\n     * @return Account state struct.\n     */\n    function decodeEVMAccount(bytes memory _encoded) internal pure returns (EVMAccount memory) {\n        Lib_RLPReader.RLPItem[] memory accountState = Lib_RLPReader.readList(_encoded);\n\n        return\n            EVMAccount({\n                nonce: Lib_RLPReader.readUint256(accountState[0]),\n                balance: Lib_RLPReader.readUint256(accountState[1]),\n                storageRoot: Lib_RLPReader.readBytes32(accountState[2]),\n                codeHash: Lib_RLPReader.readBytes32(accountState[3])\n            });\n    }\n\n    /**\n     * Calculates a hash for a given batch header.\n     * @param _batchHeader Header to hash.\n     * @return Hash of the header.\n     */\n    function hashBatchHeader(Lib_OVMCodec.ChainBatchHeader memory _batchHeader)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return\n            keccak256(\n                abi.encode(\n                    _batchHeader.batchRoot,\n                    _batchHeader.batchSize,\n                    _batchHeader.prevTotalElements,\n                    _batchHeader.extraData\n                )\n            );\n    }\n}\n"
    },
    "@eth-optimism/contracts/libraries/bridge/ICrossDomainMessenger.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.9.0;\n\n/**\n * @title ICrossDomainMessenger\n */\ninterface ICrossDomainMessenger {\n    /**********\n     * Events *\n     **********/\n\n    event SentMessage(\n        address indexed target,\n        address sender,\n        bytes message,\n        uint256 messageNonce,\n        uint256 gasLimit\n    );\n    event RelayedMessage(bytes32 indexed msgHash);\n    event FailedRelayedMessage(bytes32 indexed msgHash);\n\n    /*************\n     * Variables *\n     *************/\n\n    function xDomainMessageSender() external view returns (address);\n\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * Sends a cross domain message to the target messenger.\n     * @param _target Target contract address.\n     * @param _message Message to send to the target.\n     * @param _gasLimit Gas limit for the provided message.\n     */\n    function sendMessage(\n        address _target,\n        bytes calldata _message,\n        uint32 _gasLimit\n    ) external;\n}\n"
    },
    "@eth-optimism/contracts/libraries/rlp/Lib_RLPReader.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/**\n * @title Lib_RLPReader\n * @dev Adapted from \"RLPReader\" by Hamdi Allam (hamdi.allam97@gmail.com).\n */\nlibrary Lib_RLPReader {\n    /*************\n     * Constants *\n     *************/\n\n    uint256 internal constant MAX_LIST_LENGTH = 32;\n\n    /*********\n     * Enums *\n     *********/\n\n    enum RLPItemType {\n        DATA_ITEM,\n        LIST_ITEM\n    }\n\n    /***********\n     * Structs *\n     ***********/\n\n    struct RLPItem {\n        uint256 length;\n        uint256 ptr;\n    }\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /**\n     * Converts bytes to a reference to memory position and length.\n     * @param _in Input bytes to convert.\n     * @return Output memory reference.\n     */\n    function toRLPItem(bytes memory _in) internal pure returns (RLPItem memory) {\n        uint256 ptr;\n        assembly {\n            ptr := add(_in, 32)\n        }\n\n        return RLPItem({ length: _in.length, ptr: ptr });\n    }\n\n    /**\n     * Reads an RLP list value into a list of RLP items.\n     * @param _in RLP list value.\n     * @return Decoded RLP list items.\n     */\n    function readList(RLPItem memory _in) internal pure returns (RLPItem[] memory) {\n        (uint256 listOffset, , RLPItemType itemType) = _decodeLength(_in);\n\n        require(itemType == RLPItemType.LIST_ITEM, \"Invalid RLP list value.\");\n\n        // Solidity in-memory arrays can't be increased in size, but *can* be decreased in size by\n        // writing to the length. Since we can't know the number of RLP items without looping over\n        // the entire input, we'd have to loop twice to accurately size this array. It's easier to\n        // simply set a reasonable maximum list length and decrease the size before we finish.\n        RLPItem[] memory out = new RLPItem[](MAX_LIST_LENGTH);\n\n        uint256 itemCount = 0;\n        uint256 offset = listOffset;\n        while (offset < _in.length) {\n            require(itemCount < MAX_LIST_LENGTH, \"Provided RLP list exceeds max list length.\");\n\n            (uint256 itemOffset, uint256 itemLength, ) = _decodeLength(\n                RLPItem({ length: _in.length - offset, ptr: _in.ptr + offset })\n            );\n\n            out[itemCount] = RLPItem({ length: itemLength + itemOffset, ptr: _in.ptr + offset });\n\n            itemCount += 1;\n            offset += itemOffset + itemLength;\n        }\n\n        // Decrease the array size to match the actual item count.\n        assembly {\n            mstore(out, itemCount)\n        }\n\n        return out;\n    }\n\n    /**\n     * Reads an RLP list value into a list of RLP items.\n     * @param _in RLP list value.\n     * @return Decoded RLP list items.\n     */\n    function readList(bytes memory _in) internal pure returns (RLPItem[] memory) {\n        return readList(toRLPItem(_in));\n    }\n\n    /**\n     * Reads an RLP bytes value into bytes.\n     * @param _in RLP bytes value.\n     * @return Decoded bytes.\n     */\n    function readBytes(RLPItem memory _in) internal pure returns (bytes memory) {\n        (uint256 itemOffset, uint256 itemLength, RLPItemType itemType) = _decodeLength(_in);\n\n        require(itemType == RLPItemType.DATA_ITEM, \"Invalid RLP bytes value.\");\n\n        return _copy(_in.ptr, itemOffset, itemLength);\n    }\n\n    /**\n     * Reads an RLP bytes value into bytes.\n     * @param _in RLP bytes value.\n     * @return Decoded bytes.\n     */\n    function readBytes(bytes memory _in) internal pure returns (bytes memory) {\n        return readBytes(toRLPItem(_in));\n    }\n\n    /**\n     * Reads an RLP string value into a string.\n     * @param _in RLP string value.\n     * @return Decoded string.\n     */\n    function readString(RLPItem memory _in) internal pure returns (string memory) {\n        return string(readBytes(_in));\n    }\n\n    /**\n     * Reads an RLP string value into a string.\n     * @param _in RLP string value.\n     * @return Decoded string.\n     */\n    function readString(bytes memory _in) internal pure returns (string memory) {\n        return readString(toRLPItem(_in));\n    }\n\n    /**\n     * Reads an RLP bytes32 value into a bytes32.\n     * @param _in RLP bytes32 value.\n     * @return Decoded bytes32.\n     */\n    function readBytes32(RLPItem memory _in) internal pure returns (bytes32) {\n        require(_in.length <= 33, \"Invalid RLP bytes32 value.\");\n\n        (uint256 itemOffset, uint256 itemLength, RLPItemType itemType) = _decodeLength(_in);\n\n        require(itemType == RLPItemType.DATA_ITEM, \"Invalid RLP bytes32 value.\");\n\n        uint256 ptr = _in.ptr + itemOffset;\n        bytes32 out;\n        assembly {\n            out := mload(ptr)\n\n            // Shift the bytes over to match the item size.\n            if lt(itemLength, 32) {\n                out := div(out, exp(256, sub(32, itemLength)))\n            }\n        }\n\n        return out;\n    }\n\n    /**\n     * Reads an RLP bytes32 value into a bytes32.\n     * @param _in RLP bytes32 value.\n     * @return Decoded bytes32.\n     */\n    function readBytes32(bytes memory _in) internal pure returns (bytes32) {\n        return readBytes32(toRLPItem(_in));\n    }\n\n    /**\n     * Reads an RLP uint256 value into a uint256.\n     * @param _in RLP uint256 value.\n     * @return Decoded uint256.\n     */\n    function readUint256(RLPItem memory _in) internal pure returns (uint256) {\n        return uint256(readBytes32(_in));\n    }\n\n    /**\n     * Reads an RLP uint256 value into a uint256.\n     * @param _in RLP uint256 value.\n     * @return Decoded uint256.\n     */\n    function readUint256(bytes memory _in) internal pure returns (uint256) {\n        return readUint256(toRLPItem(_in));\n    }\n\n    /**\n     * Reads an RLP bool value into a bool.\n     * @param _in RLP bool value.\n     * @return Decoded bool.\n     */\n    function readBool(RLPItem memory _in) internal pure returns (bool) {\n        require(_in.length == 1, \"Invalid RLP boolean value.\");\n\n        uint256 ptr = _in.ptr;\n        uint256 out;\n        assembly {\n            out := byte(0, mload(ptr))\n        }\n\n        require(out == 0 || out == 1, \"Lib_RLPReader: Invalid RLP boolean value, must be 0 or 1\");\n\n        return out != 0;\n    }\n\n    /**\n     * Reads an RLP bool value into a bool.\n     * @param _in RLP bool value.\n     * @return Decoded bool.\n     */\n    function readBool(bytes memory _in) internal pure returns (bool) {\n        return readBool(toRLPItem(_in));\n    }\n\n    /**\n     * Reads an RLP address value into a address.\n     * @param _in RLP address value.\n     * @return Decoded address.\n     */\n    function readAddress(RLPItem memory _in) internal pure returns (address) {\n        if (_in.length == 1) {\n            return address(0);\n        }\n\n        require(_in.length == 21, \"Invalid RLP address value.\");\n\n        return address(uint160(readUint256(_in)));\n    }\n\n    /**\n     * Reads an RLP address value into a address.\n     * @param _in RLP address value.\n     * @return Decoded address.\n     */\n    function readAddress(bytes memory _in) internal pure returns (address) {\n        return readAddress(toRLPItem(_in));\n    }\n\n    /**\n     * Reads the raw bytes of an RLP item.\n     * @param _in RLP item to read.\n     * @return Raw RLP bytes.\n     */\n    function readRawBytes(RLPItem memory _in) internal pure returns (bytes memory) {\n        return _copy(_in);\n    }\n\n    /*********************\n     * Private Functions *\n     *********************/\n\n    /**\n     * Decodes the length of an RLP item.\n     * @param _in RLP item to decode.\n     * @return Offset of the encoded data.\n     * @return Length of the encoded data.\n     * @return RLP item type (LIST_ITEM or DATA_ITEM).\n     */\n    function _decodeLength(RLPItem memory _in)\n        private\n        pure\n        returns (\n            uint256,\n            uint256,\n            RLPItemType\n        )\n    {\n        require(_in.length > 0, \"RLP item cannot be null.\");\n\n        uint256 ptr = _in.ptr;\n        uint256 prefix;\n        assembly {\n            prefix := byte(0, mload(ptr))\n        }\n\n        if (prefix <= 0x7f) {\n            // Single byte.\n\n            return (0, 1, RLPItemType.DATA_ITEM);\n        } else if (prefix <= 0xb7) {\n            // Short string.\n\n            // slither-disable-next-line variable-scope\n            uint256 strLen = prefix - 0x80;\n\n            require(_in.length > strLen, \"Invalid RLP short string.\");\n\n            return (1, strLen, RLPItemType.DATA_ITEM);\n        } else if (prefix <= 0xbf) {\n            // Long string.\n            uint256 lenOfStrLen = prefix - 0xb7;\n\n            require(_in.length > lenOfStrLen, \"Invalid RLP long string length.\");\n\n            uint256 strLen;\n            assembly {\n                // Pick out the string length.\n                strLen := div(mload(add(ptr, 1)), exp(256, sub(32, lenOfStrLen)))\n            }\n\n            require(_in.length > lenOfStrLen + strLen, \"Invalid RLP long string.\");\n\n            return (1 + lenOfStrLen, strLen, RLPItemType.DATA_ITEM);\n        } else if (prefix <= 0xf7) {\n            // Short list.\n            // slither-disable-next-line variable-scope\n            uint256 listLen = prefix - 0xc0;\n\n            require(_in.length > listLen, \"Invalid RLP short list.\");\n\n            return (1, listLen, RLPItemType.LIST_ITEM);\n        } else {\n            // Long list.\n            uint256 lenOfListLen = prefix - 0xf7;\n\n            require(_in.length > lenOfListLen, \"Invalid RLP long list length.\");\n\n            uint256 listLen;\n            assembly {\n                // Pick out the list length.\n                listLen := div(mload(add(ptr, 1)), exp(256, sub(32, lenOfListLen)))\n            }\n\n            require(_in.length > lenOfListLen + listLen, \"Invalid RLP long list.\");\n\n            return (1 + lenOfListLen, listLen, RLPItemType.LIST_ITEM);\n        }\n    }\n\n    /**\n     * Copies the bytes from a memory location.\n     * @param _src Pointer to the location to read from.\n     * @param _offset Offset to start reading from.\n     * @param _length Number of bytes to read.\n     * @return Copied bytes.\n     */\n    function _copy(\n        uint256 _src,\n        uint256 _offset,\n        uint256 _length\n    ) private pure returns (bytes memory) {\n        bytes memory out = new bytes(_length);\n        if (out.length == 0) {\n            return out;\n        }\n\n        uint256 src = _src + _offset;\n        uint256 dest;\n        assembly {\n            dest := add(out, 32)\n        }\n\n        // Copy over as many complete words as we can.\n        for (uint256 i = 0; i < _length / 32; i++) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n\n            src += 32;\n            dest += 32;\n        }\n\n        // Pick out the remaining bytes.\n        uint256 mask;\n        unchecked {\n            mask = 256**(32 - (_length % 32)) - 1;\n        }\n\n        assembly {\n            mstore(dest, or(and(mload(src), not(mask)), and(mload(dest), mask)))\n        }\n        return out;\n    }\n\n    /**\n     * Copies an RLP item into bytes.\n     * @param _in RLP item to copy.\n     * @return Copied bytes.\n     */\n    function _copy(RLPItem memory _in) private pure returns (bytes memory) {\n        return _copy(_in.ptr, 0, _in.length);\n    }\n}\n"
    },
    "@eth-optimism/contracts/libraries/rlp/Lib_RLPWriter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/**\n * @title Lib_RLPWriter\n * @author Bakaoh (with modifications)\n */\nlibrary Lib_RLPWriter {\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /**\n     * RLP encodes a byte string.\n     * @param _in The byte string to encode.\n     * @return The RLP encoded string in bytes.\n     */\n    function writeBytes(bytes memory _in) internal pure returns (bytes memory) {\n        bytes memory encoded;\n\n        if (_in.length == 1 && uint8(_in[0]) < 128) {\n            encoded = _in;\n        } else {\n            encoded = abi.encodePacked(_writeLength(_in.length, 128), _in);\n        }\n\n        return encoded;\n    }\n\n    /**\n     * RLP encodes a list of RLP encoded byte byte strings.\n     * @param _in The list of RLP encoded byte strings.\n     * @return The RLP encoded list of items in bytes.\n     */\n    function writeList(bytes[] memory _in) internal pure returns (bytes memory) {\n        bytes memory list = _flatten(_in);\n        return abi.encodePacked(_writeLength(list.length, 192), list);\n    }\n\n    /**\n     * RLP encodes a string.\n     * @param _in The string to encode.\n     * @return The RLP encoded string in bytes.\n     */\n    function writeString(string memory _in) internal pure returns (bytes memory) {\n        return writeBytes(bytes(_in));\n    }\n\n    /**\n     * RLP encodes an address.\n     * @param _in The address to encode.\n     * @return The RLP encoded address in bytes.\n     */\n    function writeAddress(address _in) internal pure returns (bytes memory) {\n        return writeBytes(abi.encodePacked(_in));\n    }\n\n    /**\n     * RLP encodes a uint.\n     * @param _in The uint256 to encode.\n     * @return The RLP encoded uint256 in bytes.\n     */\n    function writeUint(uint256 _in) internal pure returns (bytes memory) {\n        return writeBytes(_toBinary(_in));\n    }\n\n    /**\n     * RLP encodes a bool.\n     * @param _in The bool to encode.\n     * @return The RLP encoded bool in bytes.\n     */\n    function writeBool(bool _in) internal pure returns (bytes memory) {\n        bytes memory encoded = new bytes(1);\n        encoded[0] = (_in ? bytes1(0x01) : bytes1(0x80));\n        return encoded;\n    }\n\n    /*********************\n     * Private Functions *\n     *********************/\n\n    /**\n     * Encode the first byte, followed by the `len` in binary form if `length` is more than 55.\n     * @param _len The length of the string or the payload.\n     * @param _offset 128 if item is string, 192 if item is list.\n     * @return RLP encoded bytes.\n     */\n    function _writeLength(uint256 _len, uint256 _offset) private pure returns (bytes memory) {\n        bytes memory encoded;\n\n        if (_len < 56) {\n            encoded = new bytes(1);\n            encoded[0] = bytes1(uint8(_len) + uint8(_offset));\n        } else {\n            uint256 lenLen;\n            uint256 i = 1;\n            while (_len / i != 0) {\n                lenLen++;\n                i *= 256;\n            }\n\n            encoded = new bytes(lenLen + 1);\n            encoded[0] = bytes1(uint8(lenLen) + uint8(_offset) + 55);\n            for (i = 1; i <= lenLen; i++) {\n                encoded[i] = bytes1(uint8((_len / (256**(lenLen - i))) % 256));\n            }\n        }\n\n        return encoded;\n    }\n\n    /**\n     * Encode integer in big endian binary form with no leading zeroes.\n     * @notice TODO: This should be optimized with assembly to save gas costs.\n     * @param _x The integer to encode.\n     * @return RLP encoded bytes.\n     */\n    function _toBinary(uint256 _x) private pure returns (bytes memory) {\n        bytes memory b = abi.encodePacked(_x);\n\n        uint256 i = 0;\n        for (; i < 32; i++) {\n            if (b[i] != 0) {\n                break;\n            }\n        }\n\n        bytes memory res = new bytes(32 - i);\n        for (uint256 j = 0; j < res.length; j++) {\n            res[j] = b[i++];\n        }\n\n        return res;\n    }\n\n    /**\n     * Copies a piece of memory to another location.\n     * @notice From: https://github.com/Arachnid/solidity-stringutils/blob/master/src/strings.sol.\n     * @param _dest Destination location.\n     * @param _src Source location.\n     * @param _len Length of memory to copy.\n     */\n    function _memcpy(\n        uint256 _dest,\n        uint256 _src,\n        uint256 _len\n    ) private pure {\n        uint256 dest = _dest;\n        uint256 src = _src;\n        uint256 len = _len;\n\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        uint256 mask;\n        unchecked {\n            mask = 256**(32 - len) - 1;\n        }\n        assembly {\n            let srcpart := and(mload(src), not(mask))\n            let destpart := and(mload(dest), mask)\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n\n    /**\n     * Flattens a list of byte strings into one byte string.\n     * @notice From: https://github.com/sammayo/solidity-rlp-encoder/blob/master/RLPEncode.sol.\n     * @param _list List of byte strings to flatten.\n     * @return The flattened byte string.\n     */\n    function _flatten(bytes[] memory _list) private pure returns (bytes memory) {\n        if (_list.length == 0) {\n            return new bytes(0);\n        }\n\n        uint256 len;\n        uint256 i = 0;\n        for (; i < _list.length; i++) {\n            len += _list[i].length;\n        }\n\n        bytes memory flattened = new bytes(len);\n        uint256 flattenedPtr;\n        assembly {\n            flattenedPtr := add(flattened, 0x20)\n        }\n\n        for (i = 0; i < _list.length; i++) {\n            bytes memory item = _list[i];\n\n            uint256 listPtr;\n            assembly {\n                listPtr := add(item, 0x20)\n            }\n\n            _memcpy(flattenedPtr, listPtr, item.length);\n            flattenedPtr += _list[i].length;\n        }\n\n        return flattened;\n    }\n}\n"
    },
    "@eth-optimism/contracts/libraries/utils/Lib_BytesUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/**\n * @title Lib_BytesUtils\n */\nlibrary Lib_BytesUtils {\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    ) internal pure returns (bytes memory) {\n        require(_length + 31 >= _length, \"slice_overflow\");\n        require(_start + _length >= _start, \"slice_overflow\");\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n\n                //zero out the 32 bytes slice we are about to return\n                //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    function slice(bytes memory _bytes, uint256 _start) internal pure returns (bytes memory) {\n        if (_start >= _bytes.length) {\n            return bytes(\"\");\n        }\n\n        return slice(_bytes, _start, _bytes.length - _start);\n    }\n\n    function toBytes32(bytes memory _bytes) internal pure returns (bytes32) {\n        if (_bytes.length < 32) {\n            bytes32 ret;\n            assembly {\n                ret := mload(add(_bytes, 32))\n            }\n            return ret;\n        }\n\n        return abi.decode(_bytes, (bytes32)); // will truncate if input length > 32 bytes\n    }\n\n    function toUint256(bytes memory _bytes) internal pure returns (uint256) {\n        return uint256(toBytes32(_bytes));\n    }\n\n    function toNibbles(bytes memory _bytes) internal pure returns (bytes memory) {\n        bytes memory nibbles = new bytes(_bytes.length * 2);\n\n        for (uint256 i = 0; i < _bytes.length; i++) {\n            nibbles[i * 2] = _bytes[i] >> 4;\n            nibbles[i * 2 + 1] = bytes1(uint8(_bytes[i]) % 16);\n        }\n\n        return nibbles;\n    }\n\n    function fromNibbles(bytes memory _bytes) internal pure returns (bytes memory) {\n        bytes memory ret = new bytes(_bytes.length / 2);\n\n        for (uint256 i = 0; i < ret.length; i++) {\n            ret[i] = (_bytes[i * 2] << 4) | (_bytes[i * 2 + 1]);\n        }\n\n        return ret;\n    }\n\n    function equal(bytes memory _bytes, bytes memory _other) internal pure returns (bool) {\n        return keccak256(_bytes) == keccak256(_other);\n    }\n}\n"
    },
    "@eth-optimism/contracts/libraries/utils/Lib_Bytes32Utils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/**\n * @title Lib_Byte32Utils\n */\nlibrary Lib_Bytes32Utils {\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /**\n     * Converts a bytes32 value to a boolean. Anything non-zero will be converted to \"true.\"\n     * @param _in Input bytes32 value.\n     * @return Bytes32 as a boolean.\n     */\n    function toBool(bytes32 _in) internal pure returns (bool) {\n        return _in != 0;\n    }\n\n    /**\n     * Converts a boolean to a bytes32 value.\n     * @param _in Input boolean value.\n     * @return Boolean as a bytes32.\n     */\n    function fromBool(bool _in) internal pure returns (bytes32) {\n        return bytes32(uint256(_in ? 1 : 0));\n    }\n\n    /**\n     * Converts a bytes32 value to an address. Takes the *last* 20 bytes.\n     * @param _in Input bytes32 value.\n     * @return Bytes32 as an address.\n     */\n    function toAddress(bytes32 _in) internal pure returns (address) {\n        return address(uint160(uint256(_in)));\n    }\n\n    /**\n     * Converts an address to a bytes32.\n     * @param _in Input address value.\n     * @return Address as a bytes32.\n     */\n    function fromAddress(address _in) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(_in)));\n    }\n}\n"
    },
    "src/v0.8/tests/vendor/MockOVMCrossDomainMessenger.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.7.6 <0.9.0;\n\nimport \"../../dev/vendor/openzeppelin-solidity/v4.3.1/contracts/utils/Address.sol\";\n\n/**\n * @title iOVM_CrossDomainMessenger\n */\ninterface iOVM_CrossDomainMessenger {\n  /**********\n   * Events *\n   **********/\n\n  event SentMessage(bytes message);\n  event RelayedMessage(bytes32 msgHash);\n  event FailedRelayedMessage(bytes32 msgHash);\n\n  /*************\n   * Variables *\n   *************/\n\n  function xDomainMessageSender() external view returns (address);\n\n  /********************\n   * Public Functions *\n   ********************/\n\n  /**\n   * Sends a cross domain message to the target messenger.\n   * @param _target Target contract address.\n   * @param _message Message to send to the target.\n   * @param _gasLimit Gas limit for the provided message.\n   */\n  function sendMessage(\n    address _target,\n    bytes calldata _message,\n    uint32 _gasLimit\n  ) external;\n}\n\ncontract MockOVMCrossDomainMessenger is iOVM_CrossDomainMessenger{\n  address internal mockMessageSender;\n\n  constructor(address sender) {\n    mockMessageSender = sender;\n  }\n\n  function xDomainMessageSender() external view override returns (address) {\n    return mockMessageSender;\n  }\n\n  function _setMockMessageSender(address sender) external {\n      mockMessageSender = sender;\n  }\n\n  /********************\n   * Public Functions *\n   ********************/\n\n  /**\n   * Sends a cross domain message to the target messenger.\n   * @param _target Target contract address.\n   * @param _message Message to send to the target.\n   * @param _gasLimit Gas limit for the provided message.\n   */\n  function sendMessage(\n    address _target,\n    bytes calldata _message,\n    uint32 _gasLimit\n  ) external override {\n    Address.functionCall(_target, _message, \"sendMessage reverted\");\n  }\n}\n"
    },
    "src/v0.8/dev/OptimismCrossDomainGovernor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./interfaces/DelegateForwarderInterface.sol\";\nimport \"./vendor/@eth-optimism/contracts/0.4.7/contracts/optimistic-ethereum/iOVM/bridge/messaging/iOVM_CrossDomainMessenger.sol\";\nimport \"./vendor/openzeppelin-solidity/v4.3.1/contracts/utils/Address.sol\";\nimport \"./OptimismCrossDomainForwarder.sol\";\n\n/**\n * @title OptimismCrossDomainGovernor - L1 xDomain account representation (with delegatecall support) for Optimism\n * @notice L2 Contract which receives messages from a specific L1 address and transparently forwards them to the destination.\n * @dev Any other L2 contract which uses this contract's address as a privileged position,\n *   can be considered to be simultaneously owned by the `l1Owner` and L2 `owner`\n */\ncontract OptimismCrossDomainGovernor is DelegateForwarderInterface, OptimismCrossDomainForwarder {\n  /**\n   * @notice creates a new Optimism xDomain Forwarder contract\n   * @param crossDomainMessengerAddr the xDomain bridge messenger (Optimism bridge L2) contract address\n   * @param l1OwnerAddr the L1 owner address that will be allowed to call the forward fn\n   * @dev Empty constructor required due to inheriting from abstract contract CrossDomainForwarder\n   */\n  constructor(iOVM_CrossDomainMessenger crossDomainMessengerAddr, address l1OwnerAddr)\n    OptimismCrossDomainForwarder(crossDomainMessengerAddr, l1OwnerAddr)\n  {}\n\n  /**\n   * @notice versions:\n   *\n   * - OptimismCrossDomainForwarder 1.0.0: initial release\n   *\n   * @inheritdoc TypeAndVersionInterface\n   */\n  function typeAndVersion() external pure virtual override returns (string memory) {\n    return \"OptimismCrossDomainGovernor 1.0.0\";\n  }\n\n  /**\n   * @dev forwarded only if L2 Messenger calls with `msg.sender` being the L1 owner address, or called by the L2 owner\n   * @inheritdoc ForwarderInterface\n   */\n  function forward(address target, bytes memory data) external override onlyLocalOrCrossDomainOwner {\n    Address.functionCall(target, data, \"Governor call reverted\");\n  }\n\n  /**\n   * @dev forwarded only if L2 Messenger calls with `msg.sender` being the L1 owner address, or called by the L2 owner\n   * @inheritdoc DelegateForwarderInterface\n   */\n  function forwardDelegate(address target, bytes memory data) external override onlyLocalOrCrossDomainOwner {\n    Address.functionDelegateCall(target, data, \"Governor delegatecall reverted\");\n  }\n\n  /**\n   * @notice The call MUST come from either the L1 owner (via cross-chain message) or the L2 owner. Reverts otherwise.\n   */\n  modifier onlyLocalOrCrossDomainOwner() {\n    address messenger = crossDomainMessenger();\n    // 1. The delegatecall MUST come from either the L1 owner (via cross-chain message) or the L2 owner\n    require(msg.sender == messenger || msg.sender == owner(), \"Sender is not the L2 messenger or owner\");\n    // 2. The L2 Messenger's caller MUST be the L1 Owner\n    if (msg.sender == messenger) {\n      require(\n        iOVM_CrossDomainMessenger(messenger).xDomainMessageSender() == l1Owner(),\n        \"xDomain sender is not the L1 owner\"\n      );\n    }\n    _;\n  }\n}\n"
    },
    "src/v0.8/dev/interfaces/DelegateForwarderInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title DelegateForwarderInterface - forwards a delegatecall to a target, under some conditions\ninterface DelegateForwarderInterface {\n  /**\n   * @notice forward delegatecalls the `target` with `data`\n   * @param target contract address to be delegatecalled\n   * @param data to send to target contract\n   */\n  function forwardDelegate(address target, bytes memory data) external;\n}\n"
    },
    "src/v0.8/dev/vendor/@eth-optimism/contracts/0.4.7/contracts/optimistic-ethereum/iOVM/bridge/messaging/iOVM_CrossDomainMessenger.sol": {
      "content": "pragma solidity >=0.7.6 <0.9.0;\n\n/**\n * @title iOVM_CrossDomainMessenger\n */\ninterface iOVM_CrossDomainMessenger {\n  /**********\n   * Events *\n   **********/\n\n  event SentMessage(bytes message);\n  event RelayedMessage(bytes32 msgHash);\n  event FailedRelayedMessage(bytes32 msgHash);\n\n  /*************\n   * Variables *\n   *************/\n\n  function xDomainMessageSender() external view returns (address);\n\n  /********************\n   * Public Functions *\n   ********************/\n\n  /**\n   * Sends a cross domain message to the target messenger.\n   * @param _target Target contract address.\n   * @param _message Message to send to the target.\n   * @param _gasLimit Gas limit for the provided message.\n   */\n  function sendMessage(\n    address _target,\n    bytes calldata _message,\n    uint32 _gasLimit\n  ) external;\n}\n"
    },
    "src/v0.8/dev/OptimismCrossDomainForwarder.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../interfaces/TypeAndVersionInterface.sol\";\n\n/* ./dev dependencies - to be moved from ./dev after audit */\nimport \"./CrossDomainForwarder.sol\";\nimport \"./vendor/@eth-optimism/contracts/0.4.7/contracts/optimistic-ethereum/iOVM/bridge/messaging/iOVM_CrossDomainMessenger.sol\";\nimport \"./vendor/openzeppelin-solidity/v4.3.1/contracts/utils/Address.sol\";\n\n/**\n * @title OptimismCrossDomainForwarder - L1 xDomain account representation\n * @notice L2 Contract which receives messages from a specific L1 address and transparently forwards them to the destination.\n * @dev Any other L2 contract which uses this contract's address as a privileged position,\n *   can be considered to be owned by the `l1Owner`\n */\ncontract OptimismCrossDomainForwarder is TypeAndVersionInterface, CrossDomainForwarder {\n  // OVM_L2CrossDomainMessenger is a precompile usually deployed to 0x4200000000000000000000000000000000000007\n  iOVM_CrossDomainMessenger private immutable OVM_CROSS_DOMAIN_MESSENGER;\n\n  /**\n   * @notice creates a new Optimism xDomain Forwarder contract\n   * @param crossDomainMessengerAddr the xDomain bridge messenger (Optimism bridge L2) contract address\n   * @param l1OwnerAddr the L1 owner address that will be allowed to call the forward fn\n   */\n  constructor(iOVM_CrossDomainMessenger crossDomainMessengerAddr, address l1OwnerAddr) CrossDomainOwnable(l1OwnerAddr) {\n    require(address(crossDomainMessengerAddr) != address(0), \"Invalid xDomain Messenger address\");\n    OVM_CROSS_DOMAIN_MESSENGER = crossDomainMessengerAddr;\n  }\n\n  /**\n   * @notice versions:\n   *\n   * - OptimismCrossDomainForwarder 0.1.0: initial release\n   * - OptimismCrossDomainForwarder 1.0.0: Use OZ Address, CrossDomainOwnable\n   *\n   * @inheritdoc TypeAndVersionInterface\n   */\n  function typeAndVersion() external pure virtual override returns (string memory) {\n    return \"OptimismCrossDomainForwarder 1.0.0\";\n  }\n\n  /**\n   * @dev forwarded only if L2 Messenger calls with `xDomainMessageSender` being the L1 owner address\n   * @inheritdoc ForwarderInterface\n   */\n  function forward(address target, bytes memory data) external virtual override onlyL1Owner {\n    Address.functionCall(target, data, \"Forwarder call reverted\");\n  }\n\n  /**\n   * @notice This is always the address of the OVM_L2CrossDomainMessenger contract\n   */\n  function crossDomainMessenger() public view returns (address) {\n    return address(OVM_CROSS_DOMAIN_MESSENGER);\n  }\n\n  /**\n   * @notice The call MUST come from the L1 owner (via cross-chain message.) Reverts otherwise.\n   */\n  modifier onlyL1Owner() override {\n    require(msg.sender == crossDomainMessenger(), \"Sender is not the L2 messenger\");\n    require(\n      iOVM_CrossDomainMessenger(crossDomainMessenger()).xDomainMessageSender() == l1Owner(),\n      \"xDomain sender is not the L1 owner\"\n    );\n    _;\n  }\n\n  /**\n   * @notice The call MUST come from the proposed L1 owner (via cross-chain message.) Reverts otherwise.\n   */\n  modifier onlyProposedL1Owner() override {\n    address messenger = crossDomainMessenger();\n    require(msg.sender == messenger, \"Sender is not the L2 messenger\");\n    require(\n      iOVM_CrossDomainMessenger(messenger).xDomainMessageSender() == s_l1PendingOwner,\n      \"Must be proposed L1 owner\"\n    );\n    _;\n  }\n}\n"
    },
    "src/v0.8/dev/CrossDomainForwarder.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./CrossDomainOwnable.sol\";\nimport \"./interfaces/ForwarderInterface.sol\";\n\n/**\n * @title CrossDomainForwarder - L1 xDomain account representation\n * @notice L2 Contract which receives messages from a specific L1 address and transparently forwards them to the destination.\n * @dev Any other L2 contract which uses this contract's address as a privileged position,\n *   can consider that position to be held by the `l1Owner`\n */\nabstract contract CrossDomainForwarder is ForwarderInterface, CrossDomainOwnable {\n\n}\n"
    },
    "src/v0.8/dev/CrossDomainOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../ConfirmedOwner.sol\";\nimport \"./interfaces/CrossDomainOwnableInterface.sol\";\n\n/**\n * @title The CrossDomainOwnable contract\n * @notice A contract with helpers for cross-domain contract ownership.\n */\ncontract CrossDomainOwnable is CrossDomainOwnableInterface, ConfirmedOwner {\n  address internal s_l1Owner;\n  address internal s_l1PendingOwner;\n\n  constructor(address newl1Owner) ConfirmedOwner(msg.sender) {\n    _setL1Owner(newl1Owner);\n  }\n\n  /**\n   * @notice transfer ownership of this account to a new L1 owner\n   * @param to new L1 owner that will be allowed to call the forward fn\n   */\n  function transferL1Ownership(address to) public virtual override onlyL1Owner {\n    _transferL1Ownership(to);\n  }\n\n  /**\n   * @notice accept ownership of this account to a new L1 owner\n   */\n  function acceptL1Ownership() public virtual override onlyProposedL1Owner {\n    _setL1Owner(s_l1PendingOwner);\n  }\n\n  /**\n   * @notice Get the current owner\n   */\n  function l1Owner() public view override returns (address) {\n    return s_l1Owner;\n  }\n\n  /**\n   * @notice validate, transfer ownership, and emit relevant events\n   */\n  function _transferL1Ownership(address to) internal {\n    require(to != msg.sender, \"Cannot transfer to self\");\n\n    s_l1PendingOwner = to;\n\n    emit L1OwnershipTransferRequested(s_l1Owner, to);\n  }\n\n  /**\n   * @notice set ownership, emit relevant events. Used in acceptOwnership()\n   */\n  function _setL1Owner(address to) internal {\n    address oldOwner = s_l1Owner;\n    s_l1Owner = to;\n    s_l1PendingOwner = address(0);\n\n    emit L1OwnershipTransferred(oldOwner, to);\n  }\n\n  /**\n   * @notice Reverts if called by anyone other than the L1 owner.\n   */\n  modifier onlyL1Owner() virtual {\n    require(msg.sender == s_l1Owner, \"Only callable by L1 owner\");\n    _;\n  }\n\n  /**\n   * @notice Reverts if called by anyone other than the L1 owner.\n   */\n  modifier onlyProposedL1Owner() virtual {\n    require(msg.sender == s_l1PendingOwner, \"Only callable by proposed L1 owner\");\n    _;\n  }\n}\n"
    },
    "src/v0.8/dev/interfaces/CrossDomainOwnableInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title CrossDomainOwnableInterface - A contract with helpers for cross-domain contract ownership\ninterface CrossDomainOwnableInterface {\n  event L1OwnershipTransferRequested(address indexed from, address indexed to);\n\n  event L1OwnershipTransferred(address indexed from, address indexed to);\n\n  function l1Owner() external returns (address);\n\n  function transferL1Ownership(address recipient) external;\n\n  function acceptL1Ownership() external;\n}\n"
    },
    "src/v0.8/dev/CrossDomainDelegateForwarder.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./CrossDomainForwarder.sol\";\nimport \"./interfaces/ForwarderInterface.sol\";\nimport \"./interfaces/DelegateForwarderInterface.sol\";\n\n/**\n * @title CrossDomainDelegateForwarder - L1 xDomain account representation (with delegatecall support)\n * @notice L2 Contract which receives messages from a specific L1 address and transparently forwards them to the destination.\n * @dev Any other L2 contract which uses this contract's address as a privileged position,\n *   can consider that position to be held by the `l1Owner`\n */\nabstract contract CrossDomainDelegateForwarder is DelegateForwarderInterface, CrossDomainOwnable {\n\n}\n"
    },
    "src/v0.8/dev/ArbitrumCrossDomainGovernor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./interfaces/DelegateForwarderInterface.sol\";\nimport \"./vendor/arb-bridge-eth/v0.8.0-custom/contracts/libraries/AddressAliasHelper.sol\";\nimport \"./vendor/openzeppelin-solidity/v4.3.1/contracts/utils/Address.sol\";\nimport \"./ArbitrumCrossDomainForwarder.sol\";\n\n/**\n * @title ArbitrumCrossDomainGovernor - L1 xDomain account representation (with delegatecall support) for Arbitrum\n * @notice L2 Contract which receives messages from a specific L1 address and transparently forwards them to the destination.\n * @dev Any other L2 contract which uses this contract's address as a privileged position,\n *   can be considered to be simultaneously owned by the `l1Owner` and L2 `owner`\n */\ncontract ArbitrumCrossDomainGovernor is DelegateForwarderInterface, ArbitrumCrossDomainForwarder {\n  /**\n   * @notice creates a new Arbitrum xDomain Forwarder contract\n   * @param l1OwnerAddr the L1 owner address that will be allowed to call the forward fn\n   * @dev Empty constructor required due to inheriting from abstract contract CrossDomainForwarder\n   */\n  constructor(address l1OwnerAddr) ArbitrumCrossDomainForwarder(l1OwnerAddr) {}\n\n  /**\n   * @notice versions:\n   *\n   * - ArbitrumCrossDomainGovernor 1.0.0: initial release\n   *\n   * @inheritdoc TypeAndVersionInterface\n   */\n  function typeAndVersion() external pure virtual override returns (string memory) {\n    return \"ArbitrumCrossDomainGovernor 1.0.0\";\n  }\n\n  /**\n   * @dev forwarded only if L2 Messenger calls with `msg.sender` being the L1 owner address, or called by the L2 owner\n   * @inheritdoc ForwarderInterface\n   */\n  function forward(address target, bytes memory data) external override onlyLocalOrCrossDomainOwner {\n    Address.functionCall(target, data, \"Governor call reverted\");\n  }\n\n  /**\n   * @dev forwarded only if L2 Messenger calls with `msg.sender` being the L1 owner address, or called by the L2 owner\n   * @inheritdoc DelegateForwarderInterface\n   */\n  function forwardDelegate(address target, bytes memory data) external override onlyLocalOrCrossDomainOwner {\n    Address.functionDelegateCall(target, data, \"Governor delegatecall reverted\");\n  }\n\n  /**\n   * @notice The call MUST come from either the L1 owner (via cross-chain message) or the L2 owner. Reverts otherwise.\n   */\n  modifier onlyLocalOrCrossDomainOwner() {\n    require(msg.sender == crossDomainMessenger() || msg.sender == owner(), \"Sender is not the L2 messenger or owner\");\n    _;\n  }\n}\n"
    },
    "src/v0.8/dev/vendor/arb-bridge-eth/v0.8.0-custom/contracts/libraries/AddressAliasHelper.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2019-2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// NOTICE: pragma change from original (^0.6.11)\npragma solidity ^0.8.0;\n\nlibrary AddressAliasHelper {\n  uint160 constant offset = uint160(0x1111000000000000000000000000000000001111);\n\n  /// @notice Utility function that converts the msg.sender viewed in the L2 to the\n  /// address in the L1 that submitted a tx to the inbox\n  /// @param l1Address L2 address as viewed in msg.sender\n  /// @return l2Address the address in the L1 that triggered the tx to L2\n  function applyL1ToL2Alias(address l1Address) internal pure returns (address l2Address) {\n    unchecked {\n      l2Address = address(uint160(l1Address) + offset);\n    }\n  }\n\n  /// @notice Utility function that converts the msg.sender viewed in the L2 to the\n  /// address in the L1 that submitted a tx to the inbox\n  /// @param l2Address L2 address as viewed in msg.sender\n  /// @return l1Address the address in the L1 that triggered the tx to L2\n  function undoL1ToL2Alias(address l2Address) internal pure returns (address l1Address) {\n    unchecked {\n      l1Address = address(uint160(l2Address) - offset);\n    }\n  }\n}\n"
    },
    "src/v0.8/dev/ArbitrumCrossDomainForwarder.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../interfaces/TypeAndVersionInterface.sol\";\nimport \"./vendor/arb-bridge-eth/v0.8.0-custom/contracts/libraries/AddressAliasHelper.sol\";\nimport \"./vendor/openzeppelin-solidity/v4.3.1/contracts/utils/Address.sol\";\nimport \"./CrossDomainForwarder.sol\";\n\n/**\n * @title ArbitrumCrossDomainForwarder - L1 xDomain account representation\n * @notice L2 Contract which receives messages from a specific L1 address and transparently forwards them to the destination.\n * @dev Any other L2 contract which uses this contract's address as a privileged position,\n *   can be considered to be owned by the `l1Owner`\n */\ncontract ArbitrumCrossDomainForwarder is TypeAndVersionInterface, CrossDomainForwarder {\n  /**\n   * @notice creates a new Arbitrum xDomain Forwarder contract\n   * @param l1OwnerAddr the L1 owner address that will be allowed to call the forward fn\n   * @dev Empty constructor required due to inheriting from abstract contract CrossDomainForwarder\n   */\n  constructor(address l1OwnerAddr) CrossDomainOwnable(l1OwnerAddr) {}\n\n  /**\n   * @notice versions:\n   *\n   * - ArbitrumCrossDomainForwarder 0.1.0: initial release\n   * - ArbitrumCrossDomainForwarder 1.0.0: Use OZ Address, CrossDomainOwnable\n   *\n   * @inheritdoc TypeAndVersionInterface\n   */\n  function typeAndVersion() external pure virtual override returns (string memory) {\n    return \"ArbitrumCrossDomainForwarder 1.0.0\";\n  }\n\n  /**\n   * @notice The L2 xDomain `msg.sender`, generated from L1 sender address\n   */\n  function crossDomainMessenger() public view returns (address) {\n    return AddressAliasHelper.applyL1ToL2Alias(l1Owner());\n  }\n\n  /**\n   * @dev forwarded only if L2 Messenger calls with `xDomainMessageSender` being the L1 owner address\n   * @inheritdoc ForwarderInterface\n   */\n  function forward(address target, bytes memory data) external virtual override onlyL1Owner {\n    Address.functionCall(target, data, \"Forwarder call reverted\");\n  }\n\n  /**\n   * @notice The call MUST come from the L1 owner (via cross-chain message.) Reverts otherwise.\n   */\n  modifier onlyL1Owner() override {\n    require(msg.sender == crossDomainMessenger(), \"Sender is not the L2 messenger\");\n    _;\n  }\n\n  /**\n   * @notice The call MUST come from the proposed L1 owner (via cross-chain message.) Reverts otherwise.\n   */\n  modifier onlyProposedL1Owner() override {\n    require(msg.sender == AddressAliasHelper.applyL1ToL2Alias(s_l1PendingOwner), \"Must be proposed L1 owner\");\n    _;\n  }\n}\n"
    },
    "src/v0.8/dev/ArbitrumValidator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../interfaces/AggregatorValidatorInterface.sol\";\nimport \"../interfaces/TypeAndVersionInterface.sol\";\nimport \"../interfaces/AccessControllerInterface.sol\";\nimport \"../interfaces/AggregatorV3Interface.sol\";\nimport \"../SimpleWriteAccessController.sol\";\n\n/* ./dev dependencies - to be moved from ./dev after audit */\nimport \"./interfaces/ArbitrumSequencerUptimeFeedInterface.sol\";\nimport \"./interfaces/FlagsInterface.sol\";\nimport \"./vendor/arb-bridge-eth/v0.8.0-custom/contracts/bridge/interfaces/IInbox.sol\";\nimport \"./vendor/arb-bridge-eth/v0.8.0-custom/contracts/libraries/AddressAliasHelper.sol\";\nimport \"./vendor/arb-os/e8d9696f21/contracts/arbos/builtin/ArbSys.sol\";\nimport \"./vendor/openzeppelin-solidity/v4.3.1/contracts/utils/Address.sol\";\n\n/**\n * @title ArbitrumValidator - makes xDomain L2 Flags contract call (using L2 xDomain Forwarder contract)\n * @notice Allows to raise and lower Flags on the Arbitrum L2 network through L1 bridge\n *  - The internal AccessController controls the access of the validate method\n *  - Gas configuration is controlled by a configurable external SimpleWriteAccessController\n *  - Funds on the contract are managed by the owner\n */\ncontract ArbitrumValidator is TypeAndVersionInterface, AggregatorValidatorInterface, SimpleWriteAccessController {\n  enum PaymentStrategy {\n    L1,\n    L2\n  }\n  // Config for L1 -> L2 Arbitrum retryable ticket message\n  struct GasConfig {\n    uint256 maxGas;\n    uint256 gasPriceBid;\n    address gasPriceL1FeedAddr;\n  }\n\n  /// @dev Precompiled contract that exists in every Arbitrum chain at address(100). Exposes a variety of system-level functionality.\n  address constant ARBSYS_ADDR = address(0x0000000000000000000000000000000000000064);\n\n  int256 private constant ANSWER_SEQ_OFFLINE = 1;\n\n  address public immutable CROSS_DOMAIN_MESSENGER;\n  address public immutable L2_SEQ_STATUS_RECORDER;\n  // L2 xDomain alias address of this contract\n  address public immutable L2_ALIAS = AddressAliasHelper.applyL1ToL2Alias(address(this));\n\n  PaymentStrategy private s_paymentStrategy;\n  GasConfig private s_gasConfig;\n  AccessControllerInterface private s_configAC;\n\n  /**\n   * @notice emitted when a new payment strategy is set\n   * @param paymentStrategy strategy describing how the contract pays for xDomain calls\n   */\n  event PaymentStrategySet(PaymentStrategy indexed paymentStrategy);\n\n  /**\n   * @notice emitted when a new gas configuration is set\n   * @param maxGas gas limit for immediate L2 execution attempt.\n   * @param gasPriceBid maximum L2 gas price to pay\n   * @param gasPriceL1FeedAddr address of the L1 gas price feed (used to approximate Arbitrum retryable ticket submission cost)\n   */\n  event GasConfigSet(uint256 maxGas, uint256 gasPriceBid, address indexed gasPriceL1FeedAddr);\n\n  /**\n   * @notice emitted when a new gas access-control contract is set\n   * @param previous the address prior to the current setting\n   * @param current the address of the new access-control contract\n   */\n  event ConfigACSet(address indexed previous, address indexed current);\n\n  /**\n   * @notice emitted when a new ETH withdrawal from L2 was requested\n   * @param id unique id of the published retryable transaction (keccak256(requestID, uint(0))\n   * @param amount of funds to withdraw\n   */\n  event L2WithdrawalRequested(uint256 indexed id, uint256 amount, address indexed refundAddr);\n\n  /**\n   * @param crossDomainMessengerAddr address the xDomain bridge messenger (Arbitrum Inbox L1) contract address\n   * @param l2ArbitrumSequencerUptimeFeedAddr the L2 Flags contract address\n   * @param configACAddr address of the access controller for managing gas price on Arbitrum\n   * @param maxGas gas limit for immediate L2 execution attempt. A value around 1M should be sufficient\n   * @param gasPriceBid maximum L2 gas price to pay\n   * @param gasPriceL1FeedAddr address of the L1 gas price feed (used to approximate Arbitrum retryable ticket submission cost)\n   * @param paymentStrategy strategy describing how the contract pays for xDomain calls\n   */\n  constructor(\n    address crossDomainMessengerAddr,\n    address l2ArbitrumSequencerUptimeFeedAddr,\n    address configACAddr,\n    uint256 maxGas,\n    uint256 gasPriceBid,\n    address gasPriceL1FeedAddr,\n    PaymentStrategy paymentStrategy\n  ) {\n    require(crossDomainMessengerAddr != address(0), \"Invalid xDomain Messenger address\");\n    require(l2ArbitrumSequencerUptimeFeedAddr != address(0), \"Invalid ArbitrumSequencerUptimeFeed contract address\");\n    CROSS_DOMAIN_MESSENGER = crossDomainMessengerAddr;\n    L2_SEQ_STATUS_RECORDER = l2ArbitrumSequencerUptimeFeedAddr;\n    // Additional L2 payment configuration\n    _setConfigAC(configACAddr);\n    _setGasConfig(maxGas, gasPriceBid, gasPriceL1FeedAddr);\n    _setPaymentStrategy(paymentStrategy);\n  }\n\n  /**\n   * @notice versions:\n   *\n   * - ArbitrumValidator 0.1.0: initial release\n   * - ArbitrumValidator 0.2.0: critical Arbitrum network update\n   *   - xDomain `msg.sender` backwards incompatible change (now an alias address)\n   *   - new `withdrawFundsFromL2` fn that withdraws from L2 xDomain alias address\n   *   - approximation of `maxSubmissionCost` using a L1 gas price feed\n   * - ArbitrumValidator 1.0.0: change target of L2 sequencer status update\n   *   - now calls `updateStatus` on an L2 ArbitrumSequencerUptimeFeed contract instead of\n   *     directly calling the Flags contract\n   *\n   * @inheritdoc TypeAndVersionInterface\n   */\n  function typeAndVersion() external pure virtual override returns (string memory) {\n    return \"ArbitrumValidator 1.0.0\";\n  }\n\n  /// @return stored PaymentStrategy\n  function paymentStrategy() external view virtual returns (PaymentStrategy) {\n    return s_paymentStrategy;\n  }\n\n  /// @return stored GasConfig\n  function gasConfig() external view virtual returns (GasConfig memory) {\n    return s_gasConfig;\n  }\n\n  /// @return config AccessControllerInterface contract address\n  function configAC() external view virtual returns (address) {\n    return address(s_configAC);\n  }\n\n  /**\n   * @notice makes this contract payable\n   * @dev receives funds:\n   *  - to use them (if configured) to pay for L2 execution on L1\n   *  - when withdrawing funds from L2 xDomain alias address (pay for L2 execution on L2)\n   */\n  receive() external payable {}\n\n  /**\n   * @notice withdraws all funds available in this contract to the msg.sender\n   * @dev only owner can call this\n   */\n  function withdrawFunds() external onlyOwner {\n    address payable recipient = payable(msg.sender);\n    uint256 amount = address(this).balance;\n    Address.sendValue(recipient, amount);\n  }\n\n  /**\n   * @notice withdraws all funds available in this contract to the address specified\n   * @dev only owner can call this\n   * @param recipient address where to send the funds\n   */\n  function withdrawFundsTo(address payable recipient) external onlyOwner {\n    uint256 amount = address(this).balance;\n    Address.sendValue(recipient, amount);\n  }\n\n  /**\n   * @notice withdraws funds from L2 xDomain alias address (representing this L1 contract)\n   * @dev only owner can call this\n   * @param amount of funds to withdraws\n   * @param refundAddr address where gas excess on L2 will be sent\n   *   WARNING: `refundAddr` is not aliased! Make sure you can recover the refunded funds on L2.\n   * @return id unique id of the published retryable transaction (keccak256(requestID, uint(0))\n   */\n  function withdrawFundsFromL2(uint256 amount, address refundAddr) external onlyOwner returns (uint256 id) {\n    // Build an xDomain message to trigger the ArbSys precompile, which will create a L2 -> L1 tx transferring `amount`\n    bytes memory message = abi.encodeWithSelector(ArbSys.withdrawEth.selector, address(this));\n    // Make the xDomain call\n    // NOTICE: We approximate the max submission cost of sending a retryable tx with specific calldata length.\n    uint256 maxSubmissionCost = _approximateMaxSubmissionCost(message.length);\n    uint256 maxGas = 120_000; // static `maxGas` for L2 -> L1 transfer\n    uint256 gasPriceBid = s_gasConfig.gasPriceBid;\n    uint256 l1PaymentValue = s_paymentStrategy == PaymentStrategy.L1\n      ? _maxRetryableTicketCost(maxSubmissionCost, maxGas, gasPriceBid)\n      : 0;\n    // NOTICE: In the case of PaymentStrategy.L2 the L2 xDomain alias address needs to be funded, as it will be paying the fee.\n    id = IInbox(CROSS_DOMAIN_MESSENGER).createRetryableTicketNoRefundAliasRewrite{value: l1PaymentValue}(\n      ARBSYS_ADDR, // target\n      amount, // L2 call value (requested)\n      maxSubmissionCost,\n      refundAddr, // excessFeeRefundAddress\n      refundAddr, // callValueRefundAddress\n      maxGas,\n      gasPriceBid,\n      message\n    );\n    emit L2WithdrawalRequested(id, amount, refundAddr);\n  }\n\n  /**\n   * @notice sets config AccessControllerInterface contract\n   * @dev only owner can call this\n   * @param accessController new AccessControllerInterface contract address\n   */\n  function setConfigAC(address accessController) external onlyOwner {\n    _setConfigAC(accessController);\n  }\n\n  /**\n   * @notice sets Arbitrum gas configuration\n   * @dev access control provided by `configAC`\n   * @param maxGas gas limit for immediate L2 execution attempt. A value around 1M should be sufficient\n   * @param gasPriceBid maximum L2 gas price to pay\n   * @param gasPriceL1FeedAddr address of the L1 gas price feed (used to approximate Arbitrum retryable ticket submission cost)\n   */\n  function setGasConfig(\n    uint256 maxGas,\n    uint256 gasPriceBid,\n    address gasPriceL1FeedAddr\n  ) external onlyOwnerOrConfigAccess {\n    _setGasConfig(maxGas, gasPriceBid, gasPriceL1FeedAddr);\n  }\n\n  /**\n   * @notice sets the payment strategy\n   * @dev access control provided by `configAC`\n   * @param paymentStrategy strategy describing how the contract pays for xDomain calls\n   */\n  function setPaymentStrategy(PaymentStrategy paymentStrategy) external onlyOwnerOrConfigAccess {\n    _setPaymentStrategy(paymentStrategy);\n  }\n\n  /**\n   * @notice validate method sends an xDomain L2 tx to update Flags contract, in case of change from `previousAnswer`.\n   * @dev A retryable ticket is created on the Arbitrum L1 Inbox contract. The tx gas fee can be paid from this\n   *   contract providing a value, or if no L1 value is sent with the xDomain message the gas will be paid by\n   *   the L2 xDomain alias account (generated from `address(this)`). This method is accessed controlled.\n   * @param previousAnswer previous aggregator answer\n   * @param currentAnswer new aggregator answer - value of 1 considers the service offline.\n   */\n  function validate(\n    uint256, /* previousRoundId */\n    int256 previousAnswer,\n    uint256, /* currentRoundId */\n    int256 currentAnswer\n  ) external override checkAccess returns (bool) {\n    // Avoids resending to L2 the same tx on every call\n    if (previousAnswer == currentAnswer) {\n      return true;\n    }\n\n    // Excess gas on L2 will be sent to the L2 xDomain alias address of this contract\n    address refundAddr = L2_ALIAS;\n    // Encode the ArbitrumSequencerUptimeFeed call\n    bytes4 selector = ArbitrumSequencerUptimeFeedInterface.updateStatus.selector;\n    bool status = currentAnswer == ANSWER_SEQ_OFFLINE;\n    uint64 timestamp = uint64(block.timestamp);\n    // Encode `status` and `timestamp`\n    bytes memory message = abi.encodeWithSelector(selector, status, timestamp);\n    // Make the xDomain call\n    // NOTICE: We approximate the max submission cost of sending a retryable tx with specific calldata length.\n    uint256 maxSubmissionCost = _approximateMaxSubmissionCost(message.length);\n    uint256 maxGas = s_gasConfig.maxGas;\n    uint256 gasPriceBid = s_gasConfig.gasPriceBid;\n    uint256 l1PaymentValue = s_paymentStrategy == PaymentStrategy.L1\n      ? _maxRetryableTicketCost(maxSubmissionCost, maxGas, gasPriceBid)\n      : 0;\n    // NOTICE: In the case of PaymentStrategy.L2 the L2 xDomain alias address needs to be funded, as it will be paying the fee.\n    // We also ignore the returned msg number, that can be queried via the `InboxMessageDelivered` event.\n    IInbox(CROSS_DOMAIN_MESSENGER).createRetryableTicketNoRefundAliasRewrite{value: l1PaymentValue}(\n      L2_SEQ_STATUS_RECORDER, // target\n      0, // L2 call value\n      maxSubmissionCost,\n      refundAddr, // excessFeeRefundAddress\n      refundAddr, // callValueRefundAddress\n      maxGas,\n      gasPriceBid,\n      message\n    );\n    // return success\n    return true;\n  }\n\n  /// @notice internal method that stores the payment strategy\n  function _setPaymentStrategy(PaymentStrategy paymentStrategy) internal {\n    s_paymentStrategy = paymentStrategy;\n    emit PaymentStrategySet(paymentStrategy);\n  }\n\n  /// @notice internal method that stores the gas configuration\n  function _setGasConfig(\n    uint256 maxGas,\n    uint256 gasPriceBid,\n    address gasPriceL1FeedAddr\n  ) internal {\n    require(maxGas > 0, \"Max gas is zero\");\n    require(gasPriceBid > 0, \"Gas price bid is zero\");\n    require(gasPriceL1FeedAddr != address(0), \"Gas price Aggregator is zero address\");\n    s_gasConfig = GasConfig(maxGas, gasPriceBid, gasPriceL1FeedAddr);\n    emit GasConfigSet(maxGas, gasPriceBid, gasPriceL1FeedAddr);\n  }\n\n  /// @notice Internal method that stores the configuration access controller\n  function _setConfigAC(address accessController) internal {\n    address previousAccessController = address(s_configAC);\n    if (accessController != previousAccessController) {\n      s_configAC = AccessControllerInterface(accessController);\n      emit ConfigACSet(previousAccessController, accessController);\n    }\n  }\n\n  /**\n   * @notice Internal method that approximates the `maxSubmissionCost` (using the L1 gas price feed)\n   * @dev On L2 this info is available via `ArbRetryableTx.getSubmissionPrice`.\n   * @param calldataSizeInBytes xDomain message size in bytes\n   */\n  function _approximateMaxSubmissionCost(uint256 calldataSizeInBytes) internal view returns (uint256) {\n    (, int256 l1GasPriceInWei, , , ) = AggregatorV3Interface(s_gasConfig.gasPriceL1FeedAddr).latestRoundData();\n    uint256 l1GasPriceEstimate = uint256(l1GasPriceInWei) * 3; // add 200% buffer (price volatility error margin)\n    return (l1GasPriceEstimate * calldataSizeInBytes) / 256 + l1GasPriceEstimate;\n  }\n\n  /// @notice Internal helper method that calculates the total cost of the xDomain retryable ticket call\n  function _maxRetryableTicketCost(\n    uint256 maxSubmissionCost,\n    uint256 maxGas,\n    uint256 gasPriceBid\n  ) internal pure returns (uint256) {\n    return maxSubmissionCost + maxGas * gasPriceBid;\n  }\n\n  /// @dev reverts if the caller does not have access to change the configuration\n  modifier onlyOwnerOrConfigAccess() {\n    require(\n      msg.sender == owner() || (address(s_configAC) != address(0) && s_configAC.hasAccess(msg.sender, msg.data)),\n      \"No access\"\n    );\n    _;\n  }\n}\n"
    },
    "src/v0.8/dev/interfaces/ArbitrumSequencerUptimeFeedInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ArbitrumSequencerUptimeFeedInterface {\n  function updateStatus(bool status, uint64 timestamp) external;\n}\n"
    },
    "src/v0.8/dev/vendor/arb-bridge-eth/v0.8.0-custom/contracts/bridge/interfaces/IInbox.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// NOTICE: pragma change from original (^0.6.11)\npragma solidity ^0.8.0;\n\nimport \"./IBridge.sol\";\nimport \"./IMessageProvider.sol\";\n\ninterface IInbox is IMessageProvider {\n  function sendL2Message(bytes calldata messageData) external returns (uint256);\n\n  function sendUnsignedTransaction(\n    uint256 maxGas,\n    uint256 gasPriceBid,\n    uint256 nonce,\n    address destAddr,\n    uint256 amount,\n    bytes calldata data\n  ) external returns (uint256);\n\n  function sendContractTransaction(\n    uint256 maxGas,\n    uint256 gasPriceBid,\n    address destAddr,\n    uint256 amount,\n    bytes calldata data\n  ) external returns (uint256);\n\n  function sendL1FundedUnsignedTransaction(\n    uint256 maxGas,\n    uint256 gasPriceBid,\n    uint256 nonce,\n    address destAddr,\n    bytes calldata data\n  ) external payable returns (uint256);\n\n  function sendL1FundedContractTransaction(\n    uint256 maxGas,\n    uint256 gasPriceBid,\n    address destAddr,\n    bytes calldata data\n  ) external payable returns (uint256);\n\n  function createRetryableTicketNoRefundAliasRewrite(\n    address destAddr,\n    uint256 arbTxCallValue,\n    uint256 maxSubmissionCost,\n    address submissionRefundAddress,\n    address valueRefundAddress,\n    uint256 maxGas,\n    uint256 gasPriceBid,\n    bytes calldata data\n  ) external payable returns (uint256);\n\n  function createRetryableTicket(\n    address destAddr,\n    uint256 arbTxCallValue,\n    uint256 maxSubmissionCost,\n    address submissionRefundAddress,\n    address valueRefundAddress,\n    uint256 maxGas,\n    uint256 gasPriceBid,\n    bytes calldata data\n  ) external payable returns (uint256);\n\n  function depositEth(address destAddr) external payable returns (uint256);\n\n  function depositEthRetryable(\n    address destAddr,\n    uint256 maxSubmissionCost,\n    uint256 maxGas,\n    uint256 maxGasPrice\n  ) external payable returns (uint256);\n\n  function bridge() external view returns (IBridge);\n}\n"
    },
    "src/v0.8/dev/vendor/arb-os/e8d9696f21/contracts/arbos/builtin/ArbSys.sol": {
      "content": "// NOTICE: pragma change from original (>=0.4.21 <0.7.0)\npragma solidity >=0.4.21 <0.9.0;\n\n/**\n * @title Precompiled contract that exists in every Arbitrum chain at address(100), 0x0000000000000000000000000000000000000064. Exposes a variety of system-level functionality.\n */\ninterface ArbSys {\n  /**\n   * @notice Get internal version number identifying an ArbOS build\n   * @return version number as int\n   */\n  function arbOSVersion() external pure returns (uint256);\n\n  function arbChainID() external view returns (uint256);\n\n  /**\n   * @notice Get Arbitrum block number (distinct from L1 block number; Arbitrum genesis block has block number 0)\n   * @return block number as int\n   */\n  function arbBlockNumber() external view returns (uint256);\n\n  /**\n   * @notice Send given amount of Eth to dest from sender.\n   * This is a convenience function, which is equivalent to calling sendTxToL1 with empty calldataForL1.\n   * @param destination recipient address on L1\n   * @return unique identifier for this L2-to-L1 transaction.\n   */\n  function withdrawEth(address destination) external payable returns (uint256);\n\n  /**\n   * @notice Send a transaction to L1\n   * @param destination recipient address on L1\n   * @param calldataForL1 (optional) calldata for L1 contract call\n   * @return a unique identifier for this L2-to-L1 transaction.\n   */\n  function sendTxToL1(address destination, bytes calldata calldataForL1) external payable returns (uint256);\n\n  /**\n   * @notice get the number of transactions issued by the given external account or the account sequence number of the given contract\n   * @param account target account\n   * @return the number of transactions issued by the given external account or the account sequence number of the given contract\n   */\n  function getTransactionCount(address account) external view returns (uint256);\n\n  /**\n   * @notice get the value of target L2 storage slot\n   * This function is only callable from address 0 to prevent contracts from being able to call it\n   * @param account target account\n   * @param index target index of storage slot\n   * @return stotage value for the given account at the given index\n   */\n  function getStorageAt(address account, uint256 index) external view returns (uint256);\n\n  /**\n   * @notice check if current call is coming from l1\n   * @return true if the caller of this was called directly from L1\n   */\n  function isTopLevelCall() external view returns (bool);\n\n  event L2ToL1Transaction(\n    address caller,\n    address indexed destination,\n    uint256 indexed uniqueId,\n    uint256 indexed batchNumber,\n    uint256 indexInBatch,\n    uint256 arbBlockNum,\n    uint256 ethBlockNum,\n    uint256 timestamp,\n    uint256 callvalue,\n    bytes data\n  );\n}\n"
    },
    "src/v0.8/dev/vendor/arb-bridge-eth/v0.8.0-custom/contracts/bridge/interfaces/IBridge.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// NOTICE: pragma change from original (^0.6.11)\npragma solidity ^0.8.0;\n\ninterface IBridge {\n  event MessageDelivered(\n    uint256 indexed messageIndex,\n    bytes32 indexed beforeInboxAcc,\n    address inbox,\n    uint8 kind,\n    address sender,\n    bytes32 messageDataHash\n  );\n\n  function deliverMessageToInbox(\n    uint8 kind,\n    address sender,\n    bytes32 messageDataHash\n  ) external payable returns (uint256);\n\n  function executeCall(\n    address destAddr,\n    uint256 amount,\n    bytes calldata data\n  ) external returns (bool success, bytes memory returnData);\n\n  // These are only callable by the admin\n  function setInbox(address inbox, bool enabled) external;\n\n  function setOutbox(address inbox, bool enabled) external;\n\n  // View functions\n\n  function activeOutbox() external view returns (address);\n\n  function allowedInboxes(address inbox) external view returns (bool);\n\n  function allowedOutboxes(address outbox) external view returns (bool);\n\n  function inboxAccs(uint256 index) external view returns (bytes32);\n\n  function messageCount() external view returns (uint256);\n}\n"
    },
    "src/v0.8/dev/vendor/arb-bridge-eth/v0.8.0-custom/contracts/bridge/interfaces/IMessageProvider.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * Copyright 2021, Offchain Labs, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// NOTICE: pragma change from original (^0.6.11)\npragma solidity ^0.8.0;\n\ninterface IMessageProvider {\n  event InboxMessageDelivered(uint256 indexed messageNum, bytes data);\n\n  event InboxMessageDeliveredFromOrigin(uint256 indexed messageNum);\n}\n"
    },
    "src/v0.8/tests/MockArbitrumInbox.sol": {
      "content": "import {IInbox} from \"../dev/vendor/arb-bridge-eth/v0.8.0-custom/contracts/bridge/interfaces/IInbox.sol\";\nimport {IBridge} from \"../dev/vendor/arb-bridge-eth/v0.8.0-custom/contracts/bridge/interfaces/IBridge.sol\";\n\ncontract MockArbitrumInbox is IInbox {\n  event RetryableTicketNoRefundAliasRewriteCreated(\n    address destAddr,\n    uint256 arbTxCallValue,\n    uint256 maxSubmissionCost,\n    address submissionRefundAddress,\n    address valueRefundAddress,\n    uint256 maxGas,\n    uint256 gasPriceBid,\n    bytes data\n  );\n\n  function sendL2Message(bytes calldata messageData) external override returns (uint256) {\n    return 0;\n  }\n\n  function sendUnsignedTransaction(\n    uint256 maxGas,\n    uint256 gasPriceBid,\n    uint256 nonce,\n    address destAddr,\n    uint256 amount,\n    bytes calldata data\n  ) external override returns (uint256) {\n    return 0;\n  }\n\n  function sendContractTransaction(\n    uint256 maxGas,\n    uint256 gasPriceBid,\n    address destAddr,\n    uint256 amount,\n    bytes calldata data\n  ) external override returns (uint256) {\n    return 0;\n  }\n\n  function sendL1FundedUnsignedTransaction(\n    uint256 maxGas,\n    uint256 gasPriceBid,\n    uint256 nonce,\n    address destAddr,\n    bytes calldata data\n  ) external payable override returns (uint256) {\n    return 0;\n  }\n\n  function sendL1FundedContractTransaction(\n    uint256 maxGas,\n    uint256 gasPriceBid,\n    address destAddr,\n    bytes calldata data\n  ) external payable override returns (uint256) {\n    return 0;\n  }\n\n  function createRetryableTicketNoRefundAliasRewrite(\n    address destAddr,\n    uint256 arbTxCallValue,\n    uint256 maxSubmissionCost,\n    address submissionRefundAddress,\n    address valueRefundAddress,\n    uint256 maxGas,\n    uint256 gasPriceBid,\n    bytes calldata data\n  ) external payable override returns (uint256) {\n    emit RetryableTicketNoRefundAliasRewriteCreated(\n      destAddr,\n      arbTxCallValue,\n      maxSubmissionCost,\n      submissionRefundAddress,\n      valueRefundAddress,\n      maxGas,\n      gasPriceBid,\n      data\n    );\n    return 42;\n  }\n\n  function createRetryableTicket(\n    address destAddr,\n    uint256 arbTxCallValue,\n    uint256 maxSubmissionCost,\n    address submissionRefundAddress,\n    address valueRefundAddress,\n    uint256 maxGas,\n    uint256 gasPriceBid,\n    bytes calldata data\n  ) external payable override returns (uint256) {\n    return 0;\n  }\n\n  function depositEth(address destAddr) external payable override returns (uint256) {\n    return 0;\n  }\n\n  function depositEthRetryable(\n    address destAddr,\n    uint256 maxSubmissionCost,\n    uint256 maxGas,\n    uint256 maxGasPrice\n  ) external payable override returns (uint256) {\n    return 0;\n  }\n\n  function bridge() external view override returns (IBridge) {\n    return IBridge(address(0));\n  }\n}\n"
    },
    "src/v0.8/dev/OptimismSequencerUptimeFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {ForwarderInterface} from \"./interfaces/ForwarderInterface.sol\";\nimport {AggregatorInterface} from \"../interfaces/AggregatorInterface.sol\";\nimport {AggregatorV3Interface} from \"../interfaces/AggregatorV3Interface.sol\";\nimport {AggregatorV2V3Interface} from \"../interfaces/AggregatorV2V3Interface.sol\";\nimport {TypeAndVersionInterface} from \"../interfaces/TypeAndVersionInterface.sol\";\nimport {FlagsInterface} from \"./interfaces/FlagsInterface.sol\";\nimport {OptimismSequencerUptimeFeedInterface} from \"./interfaces/OptimismSequencerUptimeFeedInterface.sol\";\nimport {SimpleReadAccessController} from \"../SimpleReadAccessController.sol\";\nimport {ConfirmedOwner} from \"../ConfirmedOwner.sol\";\nimport {IL2CrossDomainMessenger} from \"@eth-optimism/contracts/L2/messaging/IL2CrossDomainMessenger.sol\";\n\n/**\n * @title OptimismSequencerUptimeFeed - L2 sequencer uptime status aggregator\n * @notice L2 contract that receives status updates from a specific L1 address,\n *  records a new answer if the status changed, and raises or lowers the flag on the\n *   stored Flags contract.\n */\ncontract OptimismSequencerUptimeFeed is\n  AggregatorV2V3Interface,\n  OptimismSequencerUptimeFeedInterface,\n  TypeAndVersionInterface,\n  SimpleReadAccessController\n{\n  /// @dev Round info (for uptime history)\n  struct Round {\n    bool status;\n    uint64 timestamp;\n  }\n\n  /// @dev Packed state struct to save sloads\n  struct FeedState {\n    uint80 latestRoundId;\n    bool latestStatus;\n    uint64 latestTimestamp;\n  }\n\n  /// @notice Contract is not yet initialized\n  error Uninitialized();\n  /// @notice Contract is already initialized\n  error AlreadyInitialized();\n  /// @notice Sender is not the L2 messenger\n  error InvalidSender();\n  /// @notice Replacement for AggregatorV3Interface \"No data present\"\n  error NoDataPresent();\n\n  event Initialized();\n  event L1SenderTransferred(address indexed from, address indexed to);\n  /// @dev Emitted when an `updateStatus` call is ignored due to unchanged status or stale timestamp\n  event UpdateIgnored(bool latestStatus, uint64 latestTimestamp, bool incomingStatus, uint64 incomingTimestamp);\n\n  /// @dev Follows: https://eips.ethereum.org/EIPS/eip-1967\n  address public constant FLAG_L2_SEQ_OFFLINE =\n    address(bytes20(bytes32(uint256(keccak256(\"chainlink.flags.optimism-seq-offline\")) - 1)));\n\n  uint8 public constant override decimals = 0;\n  string public constant override description = \"L2 Sequencer Uptime Status Feed\";\n  uint256 public constant override version = 1;\n\n  /// @dev Flags contract to raise/lower flags on, during status transitions\n  FlagsInterface public immutable FLAGS;\n  /// @dev L1 address\n  address private s_l1Sender;\n  /// @dev s_latestRoundId == 0 means this contract is uninitialized.\n  FeedState private s_feedState = FeedState({latestRoundId: 0, latestStatus: false, latestTimestamp: 0});\n  mapping(uint80 => Round) private s_rounds;\n\n  IL2CrossDomainMessenger private s_l2CrossDomainMessenger;\n\n  /**\n   * @param flagsAddress Address of the Flags contract on L2\n   * @param l1SenderAddress Address of the L1 contract that is permissioned to call this contract\n   */\n  constructor(\n    address flagsAddress,\n    address l1SenderAddress,\n    address l2CrossDomainMessengerAddr\n  ) {\n    setL1Sender(l1SenderAddress);\n    s_l2CrossDomainMessenger = IL2CrossDomainMessenger(l2CrossDomainMessengerAddr);\n    FLAGS = FlagsInterface(flagsAddress);\n  }\n\n  /**\n   * @notice Check if a roundId is valid in this current contract state\n   * @dev Mainly used for AggregatorV2V3Interface functions\n   * @param roundId Round ID to check\n   */\n  function isValidRound(uint256 roundId) private view returns (bool) {\n    return roundId > 0 && roundId <= type(uint80).max && s_feedState.latestRoundId >= roundId;\n  }\n\n  /// @notice Check that this contract is initialised, otherwise throw\n  function requireInitialized(uint80 latestRoundId) private pure {\n    if (latestRoundId == 0) {\n      revert Uninitialized();\n    }\n  }\n\n  /**\n   * @notice Initialise the first round. Can't be done in the constructor,\n   *    because this contract's address must be permissioned by the the Flags contract\n   *    (The Flags contract itself is a SimpleReadAccessController).\n   */\n  function initialize() external onlyOwner {\n    FeedState memory feedState = s_feedState;\n    if (feedState.latestRoundId != 0) {\n      revert AlreadyInitialized();\n    }\n\n    uint64 timestamp = uint64(block.timestamp);\n    bool currentStatus = FLAGS.getFlag(FLAG_L2_SEQ_OFFLINE);\n\n    // Initialise roundId == 1 as the first round\n    recordRound(1, currentStatus, timestamp);\n\n    emit Initialized();\n  }\n\n  /**\n   * @notice versions:\n   *\n   * - OptimismSequencerUptimeFeed 1.0.0: initial release\n   *\n   * @inheritdoc TypeAndVersionInterface\n   */\n  function typeAndVersion() external pure virtual override returns (string memory) {\n    return \"OptimismSequencerUptimeFeed 1.0.0\";\n  }\n\n  /// @return L1 sender address\n  function l1Sender() public view virtual returns (address) {\n    return s_l1Sender;\n  }\n\n  /**\n   * @notice Set the allowed L1 sender for this contract to a new L1 sender\n   * @dev Can be disabled by setting the L1 sender as `address(0)`. Accessible only by owner.\n   * @param to new L1 sender that will be allowed to call `updateStatus` on this contract\n   */\n  function transferL1Sender(address to) external virtual onlyOwner {\n    setL1Sender(to);\n  }\n\n  /// @notice internal method that stores the L1 sender\n  function setL1Sender(address to) private {\n    address from = s_l1Sender;\n    if (from != to) {\n      s_l1Sender = to;\n      emit L1SenderTransferred(from, to);\n    }\n  }\n\n  /**\n   * @dev Returns an AggregatorV2V3Interface compatible answer from status flag\n   *\n   * @param status The status flag to convert to an aggregator-compatible answer\n   */\n  function getStatusAnswer(bool status) private pure returns (int256) {\n    return status ? int256(1) : int256(0);\n  }\n\n  /**\n   * @notice Raise or lower the flag on the stored Flags contract.\n   */\n  function forwardStatusToFlags(bool status) private {\n    if (status) {\n      FLAGS.raiseFlag(FLAG_L2_SEQ_OFFLINE);\n    } else {\n      FLAGS.lowerFlag(FLAG_L2_SEQ_OFFLINE);\n    }\n  }\n\n  /**\n   * @notice Helper function to record a round and set the latest feed state.\n   *\n   * @param roundId The round ID to record\n   * @param status Sequencer status\n   * @param timestamp Block timestamp of status update\n   */\n  function recordRound(\n    uint80 roundId,\n    bool status,\n    uint64 timestamp\n  ) private {\n    Round memory nextRound = Round(status, timestamp);\n    FeedState memory feedState = FeedState(roundId, status, timestamp);\n\n    s_rounds[roundId] = nextRound;\n    s_feedState = feedState;\n\n    emit NewRound(roundId, msg.sender, timestamp);\n    emit AnswerUpdated(getStatusAnswer(status), roundId, timestamp);\n  }\n\n  /**\n   * @notice Record a new status and timestamp if it has changed since the last round.\n   * @dev This function will revert if not called from `l1Sender` via the L1->L2 messenger.\n   *\n   * @param status Sequencer status\n   * @param timestamp Block timestamp of status update\n   */\n  function updateStatus(bool status, uint64 timestamp) external override {\n    FeedState memory feedState = s_feedState;\n    requireInitialized(feedState.latestRoundId);\n    if (\n      msg.sender != address(s_l2CrossDomainMessenger) ||\n      s_l2CrossDomainMessenger.xDomainMessageSender() != s_l1Sender\n    ) {\n      revert InvalidSender();\n    }\n\n    // Ignore if status did not change or latest recorded timestamp is newer\n    if (feedState.latestStatus == status || feedState.latestTimestamp > timestamp) {\n      emit UpdateIgnored(feedState.latestStatus, feedState.latestTimestamp, status, timestamp);\n      return;\n    }\n\n    // Prepare a new round with updated status\n    feedState.latestRoundId += 1;\n    recordRound(feedState.latestRoundId, status, timestamp);\n\n    forwardStatusToFlags(status);\n  }\n\n  /// @inheritdoc AggregatorInterface\n  function latestAnswer() external view override checkAccess returns (int256) {\n    FeedState memory feedState = s_feedState;\n    requireInitialized(feedState.latestRoundId);\n    return getStatusAnswer(feedState.latestStatus);\n  }\n\n  /// @inheritdoc AggregatorInterface\n  function latestTimestamp() external view override checkAccess returns (uint256) {\n    FeedState memory feedState = s_feedState;\n    requireInitialized(feedState.latestRoundId);\n    return feedState.latestTimestamp;\n  }\n\n  /// @inheritdoc AggregatorInterface\n  function latestRound() external view override checkAccess returns (uint256) {\n    FeedState memory feedState = s_feedState;\n    requireInitialized(feedState.latestRoundId);\n    return feedState.latestRoundId;\n  }\n\n  /// @inheritdoc AggregatorInterface\n  function getAnswer(uint256 roundId) external view override checkAccess returns (int256) {\n    requireInitialized(s_feedState.latestRoundId);\n    if (isValidRound(roundId)) {\n      return getStatusAnswer(s_rounds[uint80(roundId)].status);\n    }\n\n    return 0;\n  }\n\n  /// @inheritdoc AggregatorInterface\n  function getTimestamp(uint256 roundId) external view override checkAccess returns (uint256) {\n    requireInitialized(s_feedState.latestRoundId);\n    if (isValidRound(roundId)) {\n      return s_rounds[uint80(roundId)].timestamp;\n    }\n\n    return 0;\n  }\n\n  /// @inheritdoc AggregatorV3Interface\n  function getRoundData(uint80 _roundId)\n    public\n    view\n    override\n    checkAccess\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    )\n  {\n    requireInitialized(s_feedState.latestRoundId);\n\n    if (isValidRound(_roundId)) {\n      Round memory round = s_rounds[_roundId];\n      answer = getStatusAnswer(round.status);\n      startedAt = uint256(round.timestamp);\n    } else {\n      answer = 0;\n      startedAt = 0;\n    }\n    roundId = _roundId;\n    updatedAt = startedAt;\n    answeredInRound = roundId;\n  }\n\n  /// @inheritdoc AggregatorV3Interface\n  function latestRoundData()\n    external\n    view\n    override\n    checkAccess\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    )\n  {\n    FeedState memory feedState = s_feedState;\n    requireInitialized(feedState.latestRoundId);\n\n    roundId = feedState.latestRoundId;\n    answer = getStatusAnswer(feedState.latestStatus);\n    startedAt = feedState.latestTimestamp;\n    updatedAt = startedAt;\n    answeredInRound = roundId;\n  }\n}\n"
    },
    "src/v0.8/interfaces/AggregatorInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorInterface {\n  function latestAnswer() external view returns (int256);\n\n  function latestTimestamp() external view returns (uint256);\n\n  function latestRound() external view returns (uint256);\n\n  function getAnswer(uint256 roundId) external view returns (int256);\n\n  function getTimestamp(uint256 roundId) external view returns (uint256);\n\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);\n\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\n}\n"
    },
    "src/v0.8/interfaces/AggregatorV2V3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./AggregatorInterface.sol\";\nimport \"./AggregatorV3Interface.sol\";\n\ninterface AggregatorV2V3Interface is AggregatorInterface, AggregatorV3Interface {}\n"
    },
    "src/v0.8/SimpleReadAccessController.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./SimpleWriteAccessController.sol\";\n\n/**\n * @title SimpleReadAccessController\n * @notice Gives access to:\n * - any externally owned account (note that off-chain actors can always read\n * any contract storage regardless of on-chain access control measures, so this\n * does not weaken the access control while improving usability)\n * - accounts explicitly added to an access list\n * @dev SimpleReadAccessController is not suitable for access controlling writes\n * since it grants any externally owned account access! See\n * SimpleWriteAccessController for that.\n */\ncontract SimpleReadAccessController is SimpleWriteAccessController {\n  /**\n   * @notice Returns the access of an address\n   * @param _user The address to query\n   */\n  function hasAccess(address _user, bytes memory _calldata) public view virtual override returns (bool) {\n    return super.hasAccess(_user, _calldata) || _user == tx.origin;\n  }\n}\n"
    },
    "@eth-optimism/contracts/L2/messaging/IL2CrossDomainMessenger.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/* Interface Imports */\nimport { ICrossDomainMessenger } from \"../../libraries/bridge/ICrossDomainMessenger.sol\";\n\n/**\n * @title IL2CrossDomainMessenger\n */\ninterface IL2CrossDomainMessenger is ICrossDomainMessenger {\n    /********************\n     * Public Functions *\n     ********************/\n\n    /**\n     * Relays a cross domain message to a contract.\n     * @param _target Target contract address.\n     * @param _sender Message sender address.\n     * @param _message Message to send to the target.\n     * @param _messageNonce Nonce for the provided message.\n     */\n    function relayMessage(\n        address _target,\n        address _sender,\n        bytes memory _message,\n        uint256 _messageNonce\n    ) external;\n}\n"
    },
    "src/v0.8/tests/MockOptimismL2CrossDomainMessenger.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/* Interface Imports */\nimport {IL2CrossDomainMessenger} from \"@eth-optimism/contracts/L2/messaging/IL2CrossDomainMessenger.sol\";\n\ncontract MockOptimismL2CrossDomainMessenger is IL2CrossDomainMessenger {\n  uint256 private s_nonce;\n  address private s_sender;\n\n  // slither-disable-next-line external-function\n  function xDomainMessageSender() public view returns (address) {\n    return s_sender;\n  }\n\n  function setSender(address newSender) external {\n    s_sender = newSender;\n  }\n\n  function sendMessage(\n    address _target,\n    bytes memory _message,\n    uint32 _gasLimit\n  ) public {\n    emit SentMessage(_target, msg.sender, _message, s_nonce, _gasLimit);\n    s_nonce++;\n  }\n\n  function relayMessage(\n    address _target,\n    address _sender,\n    bytes memory _message,\n    uint256 _messageNonce\n  ) external {}\n\n  receive() external payable {}\n}\n"
    },
    "src/v0.8/tests/MockOptimismL1CrossDomainMessenger.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/* Interface Imports */\nimport {IL1CrossDomainMessenger} from \"@eth-optimism/contracts/L1/messaging/IL1CrossDomainMessenger.sol\";\n\ncontract MockOptimismL1CrossDomainMessenger is IL1CrossDomainMessenger {\n  uint256 private s_nonce;\n\n  // slither-disable-next-line external-function\n  function xDomainMessageSender() public view returns (address) {\n    return address(0);\n  }\n\n  function sendMessage(\n    address _target,\n    bytes memory _message,\n    uint32 _gasLimit\n  ) public {\n    emit SentMessage(_target, msg.sender, _message, s_nonce, _gasLimit);\n    s_nonce++;\n  }\n\n  /**\n   * Relays a cross domain message to a contract.\n   * @inheritdoc IL1CrossDomainMessenger\n   */\n  // slither-disable-next-line external-function\n  function relayMessage(\n    address _target,\n    address _sender,\n    bytes memory _message,\n    uint256 _messageNonce,\n    L2MessageInclusionProof memory _proof\n  ) public {}\n\n  function replayMessage(\n    address _target,\n    address _sender,\n    bytes memory _message,\n    uint256 _queueIndex,\n    uint32 _oldGasLimit,\n    uint32 _newGasLimit\n  ) public {}\n}\n"
    },
    "src/v0.8/Flags.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./SimpleReadAccessController.sol\";\nimport \"./interfaces/AccessControllerInterface.sol\";\nimport \"./interfaces/FlagsInterface.sol\";\n\n/**\n * @title The Flags contract\n * @notice Allows flags to signal to any reader on the access control list.\n * The owner can set flags, or designate other addresses to set flags. The\n * owner must turn the flags off, other setters cannot. An expected pattern is\n * to allow addresses to raise flags on themselves, so if you are subscribing to\n * FlagOn events you should filter for addresses you care about.\n */\ncontract Flags is FlagsInterface, SimpleReadAccessController {\n  AccessControllerInterface public raisingAccessController;\n\n  mapping(address => bool) private flags;\n\n  event FlagRaised(address indexed subject);\n  event FlagLowered(address indexed subject);\n  event RaisingAccessControllerUpdated(address indexed previous, address indexed current);\n\n  /**\n   * @param racAddress address for the raising access controller.\n   */\n  constructor(address racAddress) {\n    setRaisingAccessController(racAddress);\n  }\n\n  /**\n   * @notice read the warning flag status of a contract address.\n   * @param subject The contract address being checked for a flag.\n   * @return A true value indicates that a flag was raised and a\n   * false value indicates that no flag was raised.\n   */\n  function getFlag(address subject) external view override checkAccess returns (bool) {\n    return flags[subject];\n  }\n\n  /**\n   * @notice read the warning flag status of a contract address.\n   * @param subjects An array of addresses being checked for a flag.\n   * @return An array of bools where a true value for any flag indicates that\n   * a flag was raised and a false value indicates that no flag was raised.\n   */\n  function getFlags(address[] calldata subjects) external view override checkAccess returns (bool[] memory) {\n    bool[] memory responses = new bool[](subjects.length);\n    for (uint256 i = 0; i < subjects.length; i++) {\n      responses[i] = flags[subjects[i]];\n    }\n    return responses;\n  }\n\n  /**\n   * @notice enable the warning flag for an address.\n   * Access is controlled by raisingAccessController, except for owner\n   * who always has access.\n   * @param subject The contract address whose flag is being raised\n   */\n  function raiseFlag(address subject) external override {\n    require(allowedToRaiseFlags(), \"Not allowed to raise flags\");\n\n    tryToRaiseFlag(subject);\n  }\n\n  /**\n   * @notice enable the warning flags for multiple addresses.\n   * Access is controlled by raisingAccessController, except for owner\n   * who always has access.\n   * @param subjects List of the contract addresses whose flag is being raised\n   */\n  function raiseFlags(address[] calldata subjects) external override {\n    require(allowedToRaiseFlags(), \"Not allowed to raise flags\");\n\n    for (uint256 i = 0; i < subjects.length; i++) {\n      tryToRaiseFlag(subjects[i]);\n    }\n  }\n\n  /**\n   * @notice allows owner to disable the warning flags for multiple addresses.\n   * @param subjects List of the contract addresses whose flag is being lowered\n   */\n  function lowerFlags(address[] calldata subjects) external override onlyOwner {\n    for (uint256 i = 0; i < subjects.length; i++) {\n      address subject = subjects[i];\n\n      if (flags[subject]) {\n        flags[subject] = false;\n        emit FlagLowered(subject);\n      }\n    }\n  }\n\n  /**\n   * @notice allows owner to change the access controller for raising flags.\n   * @param racAddress new address for the raising access controller.\n   */\n  function setRaisingAccessController(address racAddress) public override onlyOwner {\n    address previous = address(raisingAccessController);\n\n    if (previous != racAddress) {\n      raisingAccessController = AccessControllerInterface(racAddress);\n\n      emit RaisingAccessControllerUpdated(previous, racAddress);\n    }\n  }\n\n  // PRIVATE\n\n  function allowedToRaiseFlags() private view returns (bool) {\n    return msg.sender == owner() || raisingAccessController.hasAccess(msg.sender, msg.data);\n  }\n\n  function tryToRaiseFlag(address subject) private {\n    if (!flags[subject]) {\n      flags[subject] = true;\n      emit FlagRaised(subject);\n    }\n  }\n}\n"
    },
    "src/v0.8/interfaces/FlagsInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface FlagsInterface {\n  function getFlag(address) external view returns (bool);\n\n  function getFlags(address[] calldata) external view returns (bool[] memory);\n\n  function raiseFlag(address) external;\n\n  function raiseFlags(address[] calldata) external;\n\n  function lowerFlags(address[] calldata) external;\n\n  function setRaisingAccessController(address) external;\n}\n"
    },
    "src/v0.8/tests/FlagsTestHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../Flags.sol\";\n\ncontract FlagsTestHelper {\n  Flags public flags;\n\n  constructor(address flagsContract) {\n    flags = Flags(flagsContract);\n  }\n\n  function getFlag(address subject) external view returns (bool) {\n    return flags.getFlag(subject);\n  }\n\n  function getFlags(address[] calldata subjects) external view returns (bool[] memory) {\n    return flags.getFlags(subjects);\n  }\n}\n"
    },
    "src/v0.8/dev/Flags.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\nimport \"../SimpleReadAccessController.sol\";\nimport \"../interfaces/AccessControllerInterface.sol\";\nimport \"../interfaces/TypeAndVersionInterface.sol\";\n\n/* dev dependencies - to be re/moved after audit */\nimport \"./interfaces/FlagsInterface.sol\";\n\n/**\n * @title The Flags contract\n * @notice Allows flags to signal to any reader on the access control list.\n * The owner can set flags, or designate other addresses to set flags.\n * Raise flag actions are controlled by its own access controller.\n * Lower flag actions are controlled by its own access controller.\n * An expected pattern is to allow addresses to raise flags on themselves, so if you are subscribing to\n * FlagOn events you should filter for addresses you care about.\n */\ncontract Flags is TypeAndVersionInterface, FlagsInterface, SimpleReadAccessController {\n  AccessControllerInterface public raisingAccessController;\n  AccessControllerInterface public loweringAccessController;\n\n  mapping(address => bool) private flags;\n\n  event FlagRaised(address indexed subject);\n  event FlagLowered(address indexed subject);\n  event RaisingAccessControllerUpdated(address indexed previous, address indexed current);\n  event LoweringAccessControllerUpdated(address indexed previous, address indexed current);\n\n  /**\n   * @param racAddress address for the raising access controller.\n   * @param lacAddress address for the lowering access controller.\n   */\n  constructor(address racAddress, address lacAddress) {\n    setRaisingAccessController(racAddress);\n    setLoweringAccessController(lacAddress);\n  }\n\n  /**\n   * @notice versions:\n   *\n   * - Flags 1.1.0: upgraded to solc 0.8, added lowering access controller\n   * - Flags 1.0.0: initial release\n   *\n   * @inheritdoc TypeAndVersionInterface\n   */\n  function typeAndVersion() external pure virtual override returns (string memory) {\n    return \"Flags 1.1.0\";\n  }\n\n  /**\n   * @notice read the warning flag status of a contract address.\n   * @param subject The contract address being checked for a flag.\n   * @return A true value indicates that a flag was raised and a\n   * false value indicates that no flag was raised.\n   */\n  function getFlag(address subject) external view override checkAccess returns (bool) {\n    return flags[subject];\n  }\n\n  /**\n   * @notice read the warning flag status of a contract address.\n   * @param subjects An array of addresses being checked for a flag.\n   * @return An array of bools where a true value for any flag indicates that\n   * a flag was raised and a false value indicates that no flag was raised.\n   */\n  function getFlags(address[] calldata subjects) external view override checkAccess returns (bool[] memory) {\n    bool[] memory responses = new bool[](subjects.length);\n    for (uint256 i = 0; i < subjects.length; i++) {\n      responses[i] = flags[subjects[i]];\n    }\n    return responses;\n  }\n\n  /**\n   * @notice enable the warning flag for an address.\n   * Access is controlled by raisingAccessController, except for owner\n   * who always has access.\n   * @param subject The contract address whose flag is being raised\n   */\n  function raiseFlag(address subject) external override {\n    require(_allowedToRaiseFlags(), \"Not allowed to raise flags\");\n\n    _tryToRaiseFlag(subject);\n  }\n\n  /**\n   * @notice enable the warning flags for multiple addresses.\n   * Access is controlled by raisingAccessController, except for owner\n   * who always has access.\n   * @param subjects List of the contract addresses whose flag is being raised\n   */\n  function raiseFlags(address[] calldata subjects) external override {\n    require(_allowedToRaiseFlags(), \"Not allowed to raise flags\");\n\n    for (uint256 i = 0; i < subjects.length; i++) {\n      _tryToRaiseFlag(subjects[i]);\n    }\n  }\n\n  /**\n   * @notice allows owner to disable the warning flags for an addresses.\n   * Access is controlled by loweringAccessController, except for owner\n   * who always has access.\n   * @param subject The contract address whose flag is being lowered\n   */\n  function lowerFlag(address subject) external override {\n    require(_allowedToLowerFlags(), \"Not allowed to lower flags\");\n\n    _tryToLowerFlag(subject);\n  }\n\n  /**\n   * @notice allows owner to disable the warning flags for multiple addresses.\n   * Access is controlled by loweringAccessController, except for owner\n   * who always has access.\n   * @param subjects List of the contract addresses whose flag is being lowered\n   */\n  function lowerFlags(address[] calldata subjects) external override {\n    require(_allowedToLowerFlags(), \"Not allowed to lower flags\");\n\n    for (uint256 i = 0; i < subjects.length; i++) {\n      address subject = subjects[i];\n\n      _tryToLowerFlag(subject);\n    }\n  }\n\n  /**\n   * @notice allows owner to change the access controller for raising flags.\n   * @param racAddress new address for the raising access controller.\n   */\n  function setRaisingAccessController(address racAddress) public override onlyOwner {\n    address previous = address(raisingAccessController);\n\n    if (previous != racAddress) {\n      raisingAccessController = AccessControllerInterface(racAddress);\n\n      emit RaisingAccessControllerUpdated(previous, racAddress);\n    }\n  }\n\n  function setLoweringAccessController(address lacAddress) public override onlyOwner {\n    address previous = address(loweringAccessController);\n\n    if (previous != lacAddress) {\n      loweringAccessController = AccessControllerInterface(lacAddress);\n\n      emit LoweringAccessControllerUpdated(previous, lacAddress);\n    }\n  }\n\n  // PRIVATE\n  function _allowedToRaiseFlags() private view returns (bool) {\n    return msg.sender == owner() || raisingAccessController.hasAccess(msg.sender, msg.data);\n  }\n\n  function _allowedToLowerFlags() private view returns (bool) {\n    return msg.sender == owner() || loweringAccessController.hasAccess(msg.sender, msg.data);\n  }\n\n  function _tryToRaiseFlag(address subject) private {\n    if (!flags[subject]) {\n      flags[subject] = true;\n      emit FlagRaised(subject);\n    }\n  }\n\n  function _tryToLowerFlag(address subject) private {\n    if (flags[subject]) {\n      flags[subject] = false;\n      emit FlagLowered(subject);\n    }\n  }\n}\n"
    },
    "src/v0.8/dev/ArbitrumSequencerUptimeFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {AddressAliasHelper} from \"./vendor/arb-bridge-eth/v0.8.0-custom/contracts/libraries/AddressAliasHelper.sol\";\nimport {ForwarderInterface} from \"./interfaces/ForwarderInterface.sol\";\nimport {AggregatorInterface} from \"../interfaces/AggregatorInterface.sol\";\nimport {AggregatorV3Interface} from \"../interfaces/AggregatorV3Interface.sol\";\nimport {AggregatorV2V3Interface} from \"../interfaces/AggregatorV2V3Interface.sol\";\nimport {TypeAndVersionInterface} from \"../interfaces/TypeAndVersionInterface.sol\";\nimport {FlagsInterface} from \"./interfaces/FlagsInterface.sol\";\nimport {ArbitrumSequencerUptimeFeedInterface} from \"./interfaces/ArbitrumSequencerUptimeFeedInterface.sol\";\nimport {SimpleReadAccessController} from \"../SimpleReadAccessController.sol\";\nimport {ConfirmedOwner} from \"../ConfirmedOwner.sol\";\n\n/**\n * @title ArbitrumSequencerUptimeFeed - L2 sequencer uptime status aggregator\n * @notice L2 contract that receives status updates from a specific L1 address,\n *  records a new answer if the status changed, and raises or lowers the flag on the\n *   stored Flags contract.\n */\ncontract ArbitrumSequencerUptimeFeed is\n  AggregatorV2V3Interface,\n  ArbitrumSequencerUptimeFeedInterface,\n  TypeAndVersionInterface,\n  SimpleReadAccessController\n{\n  /// @dev Round info (for uptime history)\n  struct Round {\n    bool status;\n    uint64 timestamp;\n  }\n\n  /// @dev Packed state struct to save sloads\n  struct FeedState {\n    uint80 latestRoundId;\n    bool latestStatus;\n    uint64 latestTimestamp;\n  }\n\n  /// @notice Contract is not yet initialized\n  error Uninitialized();\n  /// @notice Contract is already initialized\n  error AlreadyInitialized();\n  /// @notice Sender is not the L2 messenger\n  error InvalidSender();\n  /// @notice Replacement for AggregatorV3Interface \"No data present\"\n  error NoDataPresent();\n\n  event Initialized();\n  event L1SenderTransferred(address indexed from, address indexed to);\n  /// @dev Emitted when an `updateStatus` call is ignored due to unchanged status or stale timestamp\n  event UpdateIgnored(bool latestStatus, uint64 latestTimestamp, bool incomingStatus, uint64 incomingTimestamp);\n\n  /// @dev Follows: https://eips.ethereum.org/EIPS/eip-1967\n  address public constant FLAG_L2_SEQ_OFFLINE =\n    address(bytes20(bytes32(uint256(keccak256(\"chainlink.flags.arbitrum-seq-offline\")) - 1)));\n\n  uint8 public constant override decimals = 0;\n  string public constant override description = \"L2 Sequencer Uptime Status Feed\";\n  uint256 public constant override version = 1;\n\n  /// @dev Flags contract to raise/lower flags on, during status transitions\n  FlagsInterface public immutable FLAGS;\n  /// @dev L1 address\n  address private s_l1Sender;\n  /// @dev s_latestRoundId == 0 means this contract is uninitialized.\n  FeedState private s_feedState = FeedState({latestRoundId: 0, latestStatus: false, latestTimestamp: 0});\n  mapping(uint80 => Round) private s_rounds;\n\n  /**\n   * @param flagsAddress Address of the Flags contract on L2\n   * @param l1SenderAddress Address of the L1 contract that is permissioned to call this contract\n   */\n  constructor(address flagsAddress, address l1SenderAddress) {\n    setL1Sender(l1SenderAddress);\n\n    FLAGS = FlagsInterface(flagsAddress);\n  }\n\n  /**\n   * @notice Check if a roundId is valid in this current contract state\n   * @dev Mainly used for AggregatorV2V3Interface functions\n   * @param roundId Round ID to check\n   */\n  function isValidRound(uint256 roundId) private view returns (bool) {\n    return roundId > 0 && roundId <= type(uint80).max && s_feedState.latestRoundId >= roundId;\n  }\n\n  /// @notice Check that this contract is initialised, otherwise throw\n  function requireInitialized(uint80 latestRoundId) private pure {\n    if (latestRoundId == 0) {\n      revert Uninitialized();\n    }\n  }\n\n  /**\n   * @notice Initialise the first round. Can't be done in the constructor,\n   *    because this contract's address must be permissioned by the the Flags contract\n   *    (The Flags contract itself is a SimpleReadAccessController).\n   */\n  function initialize() external onlyOwner {\n    FeedState memory feedState = s_feedState;\n    if (feedState.latestRoundId != 0) {\n      revert AlreadyInitialized();\n    }\n\n    uint64 timestamp = uint64(block.timestamp);\n    bool currentStatus = FLAGS.getFlag(FLAG_L2_SEQ_OFFLINE);\n\n    // Initialise roundId == 1 as the first round\n    recordRound(1, currentStatus, timestamp);\n\n    emit Initialized();\n  }\n\n  /**\n   * @notice versions:\n   *\n   * - ArbitrumSequencerUptimeFeed 1.0.0: initial release\n   *\n   * @inheritdoc TypeAndVersionInterface\n   */\n  function typeAndVersion() external pure virtual override returns (string memory) {\n    return \"ArbitrumSequencerUptimeFeed 1.0.0\";\n  }\n\n  /// @return L1 sender address\n  function l1Sender() public view virtual returns (address) {\n    return s_l1Sender;\n  }\n\n  /**\n   * @notice Set the allowed L1 sender for this contract to a new L1 sender\n   * @dev Can be disabled by setting the L1 sender as `address(0)`. Accessible only by owner.\n   * @param to new L1 sender that will be allowed to call `updateStatus` on this contract\n   */\n  function transferL1Sender(address to) external virtual onlyOwner {\n    setL1Sender(to);\n  }\n\n  /// @notice internal method that stores the L1 sender\n  function setL1Sender(address to) private {\n    address from = s_l1Sender;\n    if (from != to) {\n      s_l1Sender = to;\n      emit L1SenderTransferred(from, to);\n    }\n  }\n\n  /**\n   * @notice Messages sent by the stored L1 sender will arrive on L2 with this\n   *  address as the `msg.sender`\n   * @return L2-aliased form of the L1 sender address\n   */\n  function aliasedL1MessageSender() public view returns (address) {\n    return AddressAliasHelper.applyL1ToL2Alias(l1Sender());\n  }\n\n  /**\n   * @dev Returns an AggregatorV2V3Interface compatible answer from status flag\n   *\n   * @param status The status flag to convert to an aggregator-compatible answer\n   */\n  function getStatusAnswer(bool status) private pure returns (int256) {\n    return status ? int256(1) : int256(0);\n  }\n\n  /**\n   * @notice Raise or lower the flag on the stored Flags contract.\n   */\n  function forwardStatusToFlags(bool status) private {\n    if (status) {\n      FLAGS.raiseFlag(FLAG_L2_SEQ_OFFLINE);\n    } else {\n      FLAGS.lowerFlag(FLAG_L2_SEQ_OFFLINE);\n    }\n  }\n\n  /**\n   * @notice Helper function to record a round and set the latest feed state.\n   *\n   * @param roundId The round ID to record\n   * @param status Sequencer status\n   * @param timestamp Block timestamp of status update\n   */\n  function recordRound(\n    uint80 roundId,\n    bool status,\n    uint64 timestamp\n  ) private {\n    Round memory nextRound = Round(status, timestamp);\n    FeedState memory feedState = FeedState(roundId, status, timestamp);\n\n    s_rounds[roundId] = nextRound;\n    s_feedState = feedState;\n\n    emit NewRound(roundId, msg.sender, timestamp);\n    emit AnswerUpdated(getStatusAnswer(status), roundId, timestamp);\n  }\n\n  /**\n   * @notice Record a new status and timestamp if it has changed since the last round.\n   * @dev This function will revert if not called from `l1Sender` via the L1->L2 messenger.\n   *\n   * @param status Sequencer status\n   * @param timestamp Block timestamp of status update\n   */\n  function updateStatus(bool status, uint64 timestamp) external override {\n    FeedState memory feedState = s_feedState;\n    requireInitialized(feedState.latestRoundId);\n    if (msg.sender != aliasedL1MessageSender()) {\n      revert InvalidSender();\n    }\n\n    // Ignore if status did not change or latest recorded timestamp is newer\n    if (feedState.latestStatus == status || feedState.latestTimestamp > timestamp) {\n      emit UpdateIgnored(feedState.latestStatus, feedState.latestTimestamp, status, timestamp);\n      return;\n    }\n\n    // Prepare a new round with updated status\n    feedState.latestRoundId += 1;\n    recordRound(feedState.latestRoundId, status, timestamp);\n\n    forwardStatusToFlags(status);\n  }\n\n  /// @inheritdoc AggregatorInterface\n  function latestAnswer() external view override checkAccess returns (int256) {\n    FeedState memory feedState = s_feedState;\n    requireInitialized(feedState.latestRoundId);\n    return getStatusAnswer(feedState.latestStatus);\n  }\n\n  /// @inheritdoc AggregatorInterface\n  function latestTimestamp() external view override checkAccess returns (uint256) {\n    FeedState memory feedState = s_feedState;\n    requireInitialized(feedState.latestRoundId);\n    return feedState.latestTimestamp;\n  }\n\n  /// @inheritdoc AggregatorInterface\n  function latestRound() external view override checkAccess returns (uint256) {\n    FeedState memory feedState = s_feedState;\n    requireInitialized(feedState.latestRoundId);\n    return feedState.latestRoundId;\n  }\n\n  /// @inheritdoc AggregatorInterface\n  function getAnswer(uint256 roundId) external view override checkAccess returns (int256) {\n    requireInitialized(s_feedState.latestRoundId);\n    if (isValidRound(roundId)) {\n      return getStatusAnswer(s_rounds[uint80(roundId)].status);\n    }\n\n    return 0;\n  }\n\n  /// @inheritdoc AggregatorInterface\n  function getTimestamp(uint256 roundId) external view override checkAccess returns (uint256) {\n    requireInitialized(s_feedState.latestRoundId);\n    if (isValidRound(roundId)) {\n      return s_rounds[uint80(roundId)].timestamp;\n    }\n\n    return 0;\n  }\n\n  /// @inheritdoc AggregatorV3Interface\n  function getRoundData(uint80 _roundId)\n    public\n    view\n    override\n    checkAccess\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    )\n  {\n    requireInitialized(s_feedState.latestRoundId);\n\n    if (isValidRound(_roundId)) {\n      Round memory round = s_rounds[_roundId];\n      answer = getStatusAnswer(round.status);\n      startedAt = uint256(round.timestamp);\n    } else {\n      answer = 0;\n      startedAt = 0;\n    }\n    roundId = _roundId;\n    updatedAt = startedAt;\n    answeredInRound = roundId;\n  }\n\n  /// @inheritdoc AggregatorV3Interface\n  function latestRoundData()\n    external\n    view\n    override\n    checkAccess\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    )\n  {\n    FeedState memory feedState = s_feedState;\n    requireInitialized(feedState.latestRoundId);\n\n    roundId = feedState.latestRoundId;\n    answer = getStatusAnswer(feedState.latestStatus);\n    startedAt = feedState.latestTimestamp;\n    updatedAt = startedAt;\n    answeredInRound = roundId;\n  }\n}\n"
    },
    "src/v0.8/tests/MockV3Aggregator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../interfaces/AggregatorV2V3Interface.sol\";\n\n/**\n * @title MockV3Aggregator\n * @notice Based on the FluxAggregator contract\n * @notice Use this contract when you need to test\n * other contract's ability to read data from an\n * aggregator contract, but how the aggregator got\n * its answer is unimportant\n */\ncontract MockV3Aggregator is AggregatorV2V3Interface {\n  uint256 public constant override version = 0;\n\n  uint8 public override decimals;\n  int256 public override latestAnswer;\n  uint256 public override latestTimestamp;\n  uint256 public override latestRound;\n\n  mapping(uint256 => int256) public override getAnswer;\n  mapping(uint256 => uint256) public override getTimestamp;\n  mapping(uint256 => uint256) private getStartedAt;\n\n  constructor(uint8 _decimals, int256 _initialAnswer) {\n    decimals = _decimals;\n    updateAnswer(_initialAnswer);\n  }\n\n  function updateAnswer(int256 _answer) public {\n    latestAnswer = _answer;\n    latestTimestamp = block.timestamp;\n    latestRound++;\n    getAnswer[latestRound] = _answer;\n    getTimestamp[latestRound] = block.timestamp;\n    getStartedAt[latestRound] = block.timestamp;\n  }\n\n  function updateRoundData(\n    uint80 _roundId,\n    int256 _answer,\n    uint256 _timestamp,\n    uint256 _startedAt\n  ) public {\n    latestRound = _roundId;\n    latestAnswer = _answer;\n    latestTimestamp = _timestamp;\n    getAnswer[latestRound] = _answer;\n    getTimestamp[latestRound] = _timestamp;\n    getStartedAt[latestRound] = _startedAt;\n  }\n\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    override\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    )\n  {\n    return (_roundId, getAnswer[_roundId], getStartedAt[_roundId], getTimestamp[_roundId], _roundId);\n  }\n\n  function latestRoundData()\n    external\n    view\n    override\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    )\n  {\n    return (\n      uint80(latestRound),\n      getAnswer[latestRound],\n      getStartedAt[latestRound],\n      getTimestamp[latestRound],\n      uint80(latestRound)\n    );\n  }\n\n  function description() external pure override returns (string memory) {\n    return \"v0.8/tests/MockV3Aggregator.sol\";\n  }\n}\n"
    },
    "src/v0.8/tests/FeedConsumer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {AggregatorV2V3Interface} from \"../interfaces/AggregatorV2V3Interface.sol\";\n\ncontract FeedConsumer {\n  AggregatorV2V3Interface public immutable AGGREGATOR;\n\n  constructor(address feedAddress) {\n    AGGREGATOR = AggregatorV2V3Interface(feedAddress);\n  }\n\n  function latestAnswer() external view returns (int256 answer) {\n    return AGGREGATOR.latestAnswer();\n  }\n\n  function latestTimestamp() external view returns (uint256) {\n    return AGGREGATOR.latestTimestamp();\n  }\n\n  function latestRound() external view returns (uint256) {\n    return AGGREGATOR.latestRound();\n  }\n\n  function getAnswer(uint256 roundId) external view returns (int256) {\n    return AGGREGATOR.getAnswer(roundId);\n  }\n\n  function getTimestamp(uint256 roundId) external view returns (uint256) {\n    return AGGREGATOR.getTimestamp(roundId);\n  }\n\n  function decimals() external view returns (uint8) {\n    return AGGREGATOR.decimals();\n  }\n\n  function description() external view returns (string memory) {\n    return AGGREGATOR.description();\n  }\n\n  function version() external view returns (uint256) {\n    return AGGREGATOR.version();\n  }\n\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    )\n  {\n    return AGGREGATOR.getRoundData(_roundId);\n  }\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    )\n  {\n    return AGGREGATOR.latestRoundData();\n  }\n}\n"
    },
    "src/v0.8/interfaces/FeedRegistryInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\npragma abicoder v2;\n\nimport \"./AggregatorV2V3Interface.sol\";\n\ninterface FeedRegistryInterface {\n  struct Phase {\n    uint16 phaseId;\n    uint80 startingAggregatorRoundId;\n    uint80 endingAggregatorRoundId;\n  }\n\n  event FeedProposed(\n    address indexed asset,\n    address indexed denomination,\n    address indexed proposedAggregator,\n    address currentAggregator,\n    address sender\n  );\n  event FeedConfirmed(\n    address indexed asset,\n    address indexed denomination,\n    address indexed latestAggregator,\n    address previousAggregator,\n    uint16 nextPhaseId,\n    address sender\n  );\n\n  // V3 AggregatorV3Interface\n\n  function decimals(address base, address quote) external view returns (uint8);\n\n  function description(address base, address quote) external view returns (string memory);\n\n  function version(address base, address quote) external view returns (uint256);\n\n  function latestRoundData(address base, address quote)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function getRoundData(\n    address base,\n    address quote,\n    uint80 _roundId\n  )\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  // V2 AggregatorInterface\n\n  function latestAnswer(address base, address quote) external view returns (int256 answer);\n\n  function latestTimestamp(address base, address quote) external view returns (uint256 timestamp);\n\n  function latestRound(address base, address quote) external view returns (uint256 roundId);\n\n  function getAnswer(\n    address base,\n    address quote,\n    uint256 roundId\n  ) external view returns (int256 answer);\n\n  function getTimestamp(\n    address base,\n    address quote,\n    uint256 roundId\n  ) external view returns (uint256 timestamp);\n\n  // Registry getters\n\n  function getFeed(address base, address quote) external view returns (AggregatorV2V3Interface aggregator);\n\n  function getPhaseFeed(\n    address base,\n    address quote,\n    uint16 phaseId\n  ) external view returns (AggregatorV2V3Interface aggregator);\n\n  function isFeedEnabled(address aggregator) external view returns (bool);\n\n  function getPhase(\n    address base,\n    address quote,\n    uint16 phaseId\n  ) external view returns (Phase memory phase);\n\n  // Round helpers\n\n  function getRoundFeed(\n    address base,\n    address quote,\n    uint80 roundId\n  ) external view returns (AggregatorV2V3Interface aggregator);\n\n  function getPhaseRange(\n    address base,\n    address quote,\n    uint16 phaseId\n  ) external view returns (uint80 startingRoundId, uint80 endingRoundId);\n\n  function getPreviousRoundId(\n    address base,\n    address quote,\n    uint80 roundId\n  ) external view returns (uint80 previousRoundId);\n\n  function getNextRoundId(\n    address base,\n    address quote,\n    uint80 roundId\n  ) external view returns (uint80 nextRoundId);\n\n  // Feed management\n\n  function proposeFeed(\n    address base,\n    address quote,\n    address aggregator\n  ) external;\n\n  function confirmFeed(\n    address base,\n    address quote,\n    address aggregator\n  ) external;\n\n  // Proposed aggregator\n\n  function getProposedFeed(address base, address quote)\n    external\n    view\n    returns (AggregatorV2V3Interface proposedAggregator);\n\n  function proposedGetRoundData(\n    address base,\n    address quote,\n    uint80 roundId\n  )\n    external\n    view\n    returns (\n      uint80 id,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function proposedLatestRoundData(address base, address quote)\n    external\n    view\n    returns (\n      uint80 id,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  // Phases\n  function getCurrentPhaseId(address base, address quote) external view returns (uint16 currentPhaseId);\n}\n"
    },
    "src/v0.8/mocks/MockAggregatorValidator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../interfaces/AggregatorValidatorInterface.sol\";\n\ncontract MockAggregatorValidator is AggregatorValidatorInterface {\n  uint8 immutable id;\n\n  constructor(uint8 id_) {\n    id = id_;\n  }\n\n  event ValidateCalled(\n    uint8 id,\n    uint256 previousRoundId,\n    int256 previousAnswer,\n    uint256 currentRoundId,\n    int256 currentAnswer\n  );\n\n  function validate(\n    uint256 previousRoundId,\n    int256 previousAnswer,\n    uint256 currentRoundId,\n    int256 currentAnswer\n  ) external override returns (bool) {\n    emit ValidateCalled(id, previousRoundId, previousAnswer, currentRoundId, currentAnswer);\n    return true;\n  }\n}\n"
    },
    "src/v0.8/dev/DerivedPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\nimport \"../interfaces/AggregatorV3Interface.sol\";\n\n/**\n * Network: Fantom Testnet\n * Base: LINK/USD\n * Base Address: 0x6d5689Ad4C1806D1BA0c70Ab95ebe0Da6B204fC5\n * Quote: FTM/USD\n * Quote Address: 0xe04676B9A9A2973BCb0D1478b5E1E9098BBB7f3D\n * Decimals: 18\n *\n * Network: AVAX Testnet\n * Base: LINK/USD\n * Base Address: 0x34C4c526902d88a3Aa98DB8a9b802603EB1E3470\n * Quote: AVAX/USD\n * Quote Address: 0x5498BB86BC934c8D34FDA08E81D444153d0D06aD\n * Decimals: 18\n *\n * Chainlink Data Feeds can be used in combination to derive denominated price pairs in other\n * currencies.\n *\n * If you require a denomination other than what is provided, you can use two data feeds to derive\n * the pair that you need.\n *\n * For example, if you needed a LINK / FTM price, you could take the LINK / USD feed and the\n * FTM / USD feed and derive LINK / FTM using division.\n * (LINK/USD)/(FTM/USD) = LINK/FTM\n */\ncontract DerivedPriceFeed is AggregatorV3Interface {\n  uint256 public constant override version = 0;\n\n  AggregatorV3Interface public immutable BASE;\n  AggregatorV3Interface public immutable QUOTE;\n  uint8 public immutable DECIMALS;\n\n  constructor(\n    address _base,\n    address _quote,\n    uint8 _decimals\n  ) {\n    require(_decimals > uint8(0) && _decimals <= uint8(18), \"Invalid _decimals\");\n    DECIMALS = _decimals;\n    BASE = AggregatorV3Interface(_base);\n    QUOTE = AggregatorV3Interface(_quote);\n  }\n\n  function decimals() external view override returns (uint8) {\n    return DECIMALS;\n  }\n\n  function getRoundData(uint80)\n    external\n    pure\n    override\n    returns (\n      uint80,\n      int256,\n      uint256,\n      uint256,\n      uint80\n    )\n  {\n    revert(\"not implemented - use latestRoundData()\");\n  }\n\n  function description() external pure override returns (string memory) {\n    return \"DerivedPriceFeed.sol\";\n  }\n\n  function latestRoundData()\n    external\n    view\n    override\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    )\n  {\n    return (uint80(0), getDerivedPrice(), block.timestamp, block.timestamp, uint80(0));\n  }\n\n  // https://docs.chain.link/docs/get-the-latest-price/#getting-a-different-price-denomination\n  function getDerivedPrice() internal view returns (int256) {\n    (, int256 basePrice, , , ) = BASE.latestRoundData();\n    uint8 baseDecimals = BASE.decimals();\n    basePrice = scalePrice(basePrice, baseDecimals, DECIMALS);\n\n    (, int256 quotePrice, , , ) = QUOTE.latestRoundData();\n    uint8 quoteDecimals = QUOTE.decimals();\n    quotePrice = scalePrice(quotePrice, quoteDecimals, DECIMALS);\n\n    return (basePrice * int256(10**uint256(DECIMALS))) / quotePrice;\n  }\n\n  function scalePrice(\n    int256 _price,\n    uint8 _priceDecimals,\n    uint8 _decimals\n  ) internal pure returns (int256) {\n    if (_priceDecimals < _decimals) {\n      return _price * int256(10**uint256(_decimals - _priceDecimals));\n    } else if (_priceDecimals > _decimals) {\n      return _price / int256(10**uint256(_priceDecimals - _decimals));\n    }\n    return _price;\n  }\n}\n"
    },
    "src/v0.8/vendor/DateTime.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// sourced from https://github.com/pipermerriam/ethereum-datetime\n\npragma solidity ^0.8.0;\n\nlibrary DateTime {\n  /*\n   *  Date and Time utilities for ethereum contracts\n   *\n   */\n  struct _DateTime {\n    uint16 year;\n    uint8 month;\n    uint8 day;\n    uint8 hour;\n    uint8 minute;\n    uint8 second;\n    uint8 weekday;\n  }\n\n  uint256 constant DAY_IN_SECONDS = 86400;\n  uint256 constant YEAR_IN_SECONDS = 31536000;\n  uint256 constant LEAP_YEAR_IN_SECONDS = 31622400;\n\n  uint256 constant HOUR_IN_SECONDS = 3600;\n  uint256 constant MINUTE_IN_SECONDS = 60;\n\n  uint16 constant ORIGIN_YEAR = 1970;\n\n  function isLeapYear(uint16 year) internal pure returns (bool) {\n    if (year % 4 != 0) {\n      return false;\n    }\n    if (year % 100 != 0) {\n      return true;\n    }\n    if (year % 400 != 0) {\n      return false;\n    }\n    return true;\n  }\n\n  function leapYearsBefore(uint256 year) internal pure returns (uint256) {\n    year -= 1;\n    return year / 4 - year / 100 + year / 400;\n  }\n\n  function getDaysInMonth(uint8 month, uint16 year)\n    internal\n    pure\n    returns (uint8)\n  {\n    if (\n      month == 1 ||\n      month == 3 ||\n      month == 5 ||\n      month == 7 ||\n      month == 8 ||\n      month == 10 ||\n      month == 12\n    ) {\n      return 31;\n    } else if (month == 4 || month == 6 || month == 9 || month == 11) {\n      return 30;\n    } else if (isLeapYear(year)) {\n      return 29;\n    } else {\n      return 28;\n    }\n  }\n\n  function parseTimestamp(uint256 timestamp)\n    internal\n    pure\n    returns (_DateTime memory dt)\n  {\n    uint256 secondsAccountedFor = 0;\n    uint256 buf;\n    uint8 i;\n\n    // Year\n    dt.year = getYear(timestamp);\n    buf = leapYearsBefore(dt.year) - leapYearsBefore(ORIGIN_YEAR);\n\n    secondsAccountedFor += LEAP_YEAR_IN_SECONDS * buf;\n    secondsAccountedFor += YEAR_IN_SECONDS * (dt.year - ORIGIN_YEAR - buf);\n\n    // Month\n    uint256 secondsInMonth;\n    for (i = 1; i <= 12; i++) {\n      secondsInMonth = DAY_IN_SECONDS * getDaysInMonth(i, dt.year);\n      if (secondsInMonth + secondsAccountedFor > timestamp) {\n        dt.month = i;\n        break;\n      }\n      secondsAccountedFor += secondsInMonth;\n    }\n\n    // Day\n    for (i = 1; i <= getDaysInMonth(dt.month, dt.year); i++) {\n      if (DAY_IN_SECONDS + secondsAccountedFor > timestamp) {\n        dt.day = i;\n        break;\n      }\n      secondsAccountedFor += DAY_IN_SECONDS;\n    }\n\n    // Hour\n    dt.hour = getHour(timestamp);\n\n    // Minute\n    dt.minute = getMinute(timestamp);\n\n    // Second\n    dt.second = getSecond(timestamp);\n\n    // Day of week.\n    dt.weekday = getWeekday(timestamp);\n  }\n\n  function getYear(uint256 timestamp) internal pure returns (uint16) {\n    uint256 secondsAccountedFor = 0;\n    uint16 year;\n    uint256 numLeapYears;\n\n    // Year\n    year = uint16(ORIGIN_YEAR + timestamp / YEAR_IN_SECONDS);\n    numLeapYears = leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR);\n\n    secondsAccountedFor += LEAP_YEAR_IN_SECONDS * numLeapYears;\n    secondsAccountedFor +=\n      YEAR_IN_SECONDS *\n      (year - ORIGIN_YEAR - numLeapYears);\n\n    while (secondsAccountedFor > timestamp) {\n      if (isLeapYear(uint16(year - 1))) {\n        secondsAccountedFor -= LEAP_YEAR_IN_SECONDS;\n      } else {\n        secondsAccountedFor -= YEAR_IN_SECONDS;\n      }\n      year -= 1;\n    }\n    return year;\n  }\n\n  function getMonth(uint256 timestamp) internal pure returns (uint8) {\n    return parseTimestamp(timestamp).month;\n  }\n\n  function getDay(uint256 timestamp) internal pure returns (uint8) {\n    return parseTimestamp(timestamp).day;\n  }\n\n  function getHour(uint256 timestamp) internal pure returns (uint8) {\n    return uint8((timestamp / 60 / 60) % 24);\n  }\n\n  function getMinute(uint256 timestamp) internal pure returns (uint8) {\n    return uint8((timestamp / 60) % 60);\n  }\n\n  function getSecond(uint256 timestamp) internal pure returns (uint8) {\n    return uint8(timestamp % 60);\n  }\n\n  function getWeekday(uint256 timestamp) internal pure returns (uint8) {\n    return uint8((timestamp / DAY_IN_SECONDS + 4) % 7);\n  }\n\n  function toTimestamp(\n    uint16 year,\n    uint8 month,\n    uint8 day\n  ) internal pure returns (uint256 timestamp) {\n    return toTimestamp(year, month, day, 0, 0, 0);\n  }\n\n  function toTimestamp(\n    uint16 year,\n    uint8 month,\n    uint8 day,\n    uint8 hour\n  ) internal pure returns (uint256 timestamp) {\n    return toTimestamp(year, month, day, hour, 0, 0);\n  }\n\n  function toTimestamp(\n    uint16 year,\n    uint8 month,\n    uint8 day,\n    uint8 hour,\n    uint8 minute\n  ) internal pure returns (uint256 timestamp) {\n    return toTimestamp(year, month, day, hour, minute, 0);\n  }\n\n  function toTimestamp(\n    uint16 year,\n    uint8 month,\n    uint8 day,\n    uint8 hour,\n    uint8 minute,\n    uint8 second\n  ) internal pure returns (uint256 timestamp) {\n    uint16 i;\n\n    // Year\n    for (i = ORIGIN_YEAR; i < year; i++) {\n      if (isLeapYear(i)) {\n        timestamp += LEAP_YEAR_IN_SECONDS;\n      } else {\n        timestamp += YEAR_IN_SECONDS;\n      }\n    }\n\n    // Month\n    uint8[12] memory monthDayCounts;\n    monthDayCounts[0] = 31;\n    if (isLeapYear(year)) {\n      monthDayCounts[1] = 29;\n    } else {\n      monthDayCounts[1] = 28;\n    }\n    monthDayCounts[2] = 31;\n    monthDayCounts[3] = 30;\n    monthDayCounts[4] = 31;\n    monthDayCounts[5] = 30;\n    monthDayCounts[6] = 31;\n    monthDayCounts[7] = 31;\n    monthDayCounts[8] = 30;\n    monthDayCounts[9] = 31;\n    monthDayCounts[10] = 30;\n    monthDayCounts[11] = 31;\n\n    for (i = 1; i < month; i++) {\n      timestamp += DAY_IN_SECONDS * monthDayCounts[i - 1];\n    }\n\n    // Day\n    timestamp += DAY_IN_SECONDS * (day - 1);\n\n    // Hour\n    timestamp += HOUR_IN_SECONDS * (hour);\n\n    // Minute\n    timestamp += MINUTE_IN_SECONDS * (minute);\n\n    // Second\n    timestamp += second;\n\n    return timestamp;\n  }\n}\n"
    },
    "src/v0.8/vendor/Strings.sol": {
      "content": "// SPDX-License-Identifier: Apache 2.0\n\n/*\n * @title String & slice utility library for Solidity contracts.\n * @author Nick Johnson <arachnid@notdot.net>\n *\n * @dev Functionality in this library is largely implemented using an\n *      abstraction called a 'slice'. A slice represents a part of a string -\n *      anything from the entire string to a single character, or even no\n *      characters at all (a 0-length slice). Since a slice only has to specify\n *      an offset and a length, copying and manipulating slices is a lot less\n *      expensive than copying and manipulating the strings they reference.\n *\n *      To further reduce gas costs, most functions on slice that need to return\n *      a slice modify the original one instead of allocating a new one; for\n *      instance, `s.split(\".\")` will return the text up to the first '.',\n *      modifying s to only contain the remainder of the string after the '.'.\n *      In situations where you do not want to modify the original slice, you\n *      can make a copy first with `.copy()`, for example:\n *      `s.copy().split(\".\")`. Try and avoid using this idiom in loops; since\n *      Solidity has no memory management, it will result in allocating many\n *      short-lived slices that are later discarded.\n *\n *      Functions that return two slices come in two versions: a non-allocating\n *      version that takes the second slice as an argument, modifying it in\n *      place, and an allocating version that allocates and returns the second\n *      slice; see `nextRune` for example.\n *\n *      Functions that have to copy string data will return strings rather than\n *      slices; these can be cast back to slices for further processing if\n *      required.\n *\n *      For convenience, some functions are provided with non-modifying\n *      variants that create a new slice and return both; for instance,\n *      `s.splitNew('.')` leaves s unmodified, and returns two values\n *      corresponding to the left and right parts of the string.\n */\n\npragma solidity ^0.8.0;\n\nlibrary strings {\n  struct slice {\n    uint256 _len;\n    uint256 _ptr;\n  }\n\n  function memcpy(\n    uint256 dest,\n    uint256 src,\n    uint256 len\n  ) private pure {\n    // Copy word-length chunks while possible\n    for (; len >= 32; len -= 32) {\n      assembly {\n        mstore(dest, mload(src))\n      }\n      dest += 32;\n      src += 32;\n    }\n\n    // Copy remaining bytes\n    uint256 mask = type(uint256).max;\n    if (len > 0) {\n      mask = 256**(32 - len) - 1;\n    }\n    assembly {\n      let srcpart := and(mload(src), not(mask))\n      let destpart := and(mload(dest), mask)\n      mstore(dest, or(destpart, srcpart))\n    }\n  }\n\n  /*\n   * @dev Returns a slice containing the entire string.\n   * @param self The string to make a slice from.\n   * @return A newly allocated slice containing the entire string.\n   */\n  function toSlice(string memory self) internal pure returns (slice memory) {\n    uint256 ptr;\n    assembly {\n      ptr := add(self, 0x20)\n    }\n    return slice(bytes(self).length, ptr);\n  }\n\n  /*\n   * @dev Returns the length of a null-terminated bytes32 string.\n   * @param self The value to find the length of.\n   * @return The length of the string, from 0 to 32.\n   */\n  function len(bytes32 self) internal pure returns (uint256) {\n    uint256 ret;\n    if (self == 0) return 0;\n    if (uint256(self) & type(uint128).max == 0) {\n      ret += 16;\n      self = bytes32(uint256(self) / 0x100000000000000000000000000000000);\n    }\n    if (uint256(self) & type(uint64).max == 0) {\n      ret += 8;\n      self = bytes32(uint256(self) / 0x10000000000000000);\n    }\n    if (uint256(self) & type(uint32).max == 0) {\n      ret += 4;\n      self = bytes32(uint256(self) / 0x100000000);\n    }\n    if (uint256(self) & type(uint16).max == 0) {\n      ret += 2;\n      self = bytes32(uint256(self) / 0x10000);\n    }\n    if (uint256(self) & type(uint8).max == 0) {\n      ret += 1;\n    }\n    return 32 - ret;\n  }\n\n  /*\n   * @dev Returns a slice containing the entire bytes32, interpreted as a\n   *      null-terminated utf-8 string.\n   * @param self The bytes32 value to convert to a slice.\n   * @return A new slice containing the value of the input argument up to the\n   *         first null.\n   */\n  function toSliceB32(bytes32 self) internal pure returns (slice memory ret) {\n    // Allocate space for `self` in memory, copy it there, and point ret at it\n    assembly {\n      let ptr := mload(0x40)\n      mstore(0x40, add(ptr, 0x20))\n      mstore(ptr, self)\n      mstore(add(ret, 0x20), ptr)\n    }\n    ret._len = len(self);\n  }\n\n  /*\n   * @dev Returns a new slice containing the same data as the current slice.\n   * @param self The slice to copy.\n   * @return A new slice containing the same data as `self`.\n   */\n  function copy(slice memory self) internal pure returns (slice memory) {\n    return slice(self._len, self._ptr);\n  }\n\n  /*\n   * @dev Copies a slice to a new string.\n   * @param self The slice to copy.\n   * @return A newly allocated string containing the slice's text.\n   */\n  function toString(slice memory self) internal pure returns (string memory) {\n    string memory ret = new string(self._len);\n    uint256 retptr;\n    assembly {\n      retptr := add(ret, 32)\n    }\n\n    memcpy(retptr, self._ptr, self._len);\n    return ret;\n  }\n\n  /*\n   * @dev Returns the length in runes of the slice. Note that this operation\n   *      takes time proportional to the length of the slice; avoid using it\n   *      in loops, and call `slice.empty()` if you only need to know whether\n   *      the slice is empty or not.\n   * @param self The slice to operate on.\n   * @return The length of the slice in runes.\n   */\n  function len(slice memory self) internal pure returns (uint256 l) {\n    // Starting at ptr-31 means the LSB will be the byte we care about\n    uint256 ptr = self._ptr - 31;\n    uint256 end = ptr + self._len;\n    for (l = 0; ptr < end; l++) {\n      uint8 b;\n      assembly {\n        b := and(mload(ptr), 0xFF)\n      }\n      if (b < 0x80) {\n        ptr += 1;\n      } else if (b < 0xE0) {\n        ptr += 2;\n      } else if (b < 0xF0) {\n        ptr += 3;\n      } else if (b < 0xF8) {\n        ptr += 4;\n      } else if (b < 0xFC) {\n        ptr += 5;\n      } else {\n        ptr += 6;\n      }\n    }\n  }\n\n  /*\n   * @dev Returns true if the slice is empty (has a length of 0).\n   * @param self The slice to operate on.\n   * @return True if the slice is empty, False otherwise.\n   */\n  function empty(slice memory self) internal pure returns (bool) {\n    return self._len == 0;\n  }\n\n  /*\n   * @dev Returns a positive number if `other` comes lexicographically after\n   *      `self`, a negative number if it comes before, or zero if the\n   *      contents of the two slices are equal. Comparison is done per-rune,\n   *      on unicode codepoints.\n   * @param self The first slice to compare.\n   * @param other The second slice to compare.\n   * @return The result of the comparison.\n   */\n  function compare(slice memory self, slice memory other)\n    internal\n    pure\n    returns (int256)\n  {\n    uint256 shortest = self._len;\n    if (other._len < self._len) shortest = other._len;\n\n    uint256 selfptr = self._ptr;\n    uint256 otherptr = other._ptr;\n    for (uint256 idx = 0; idx < shortest; idx += 32) {\n      uint256 a;\n      uint256 b;\n      assembly {\n        a := mload(selfptr)\n        b := mload(otherptr)\n      }\n      if (a != b) {\n        // Mask out irrelevant bytes and check again\n        uint256 mask = type(uint256).max; // 0xffff...\n        if (shortest < 32) {\n          mask = ~(2**(8 * (32 - shortest + idx)) - 1);\n        }\n        unchecked {\n          uint256 diff = (a & mask) - (b & mask);\n          if (diff != 0) return int256(diff);\n        }\n      }\n      selfptr += 32;\n      otherptr += 32;\n    }\n    return int256(self._len) - int256(other._len);\n  }\n\n  /*\n   * @dev Returns true if the two slices contain the same text.\n   * @param self The first slice to compare.\n   * @param self The second slice to compare.\n   * @return True if the slices are equal, false otherwise.\n   */\n  function equals(slice memory self, slice memory other)\n    internal\n    pure\n    returns (bool)\n  {\n    return compare(self, other) == 0;\n  }\n\n  /*\n   * @dev Extracts the first rune in the slice into `rune`, advancing the\n   *      slice to point to the next rune and returning `self`.\n   * @param self The slice to operate on.\n   * @param rune The slice that will contain the first rune.\n   * @return `rune`.\n   */\n  function nextRune(slice memory self, slice memory rune)\n    internal\n    pure\n    returns (slice memory)\n  {\n    rune._ptr = self._ptr;\n\n    if (self._len == 0) {\n      rune._len = 0;\n      return rune;\n    }\n\n    uint256 l;\n    uint256 b;\n    // Load the first byte of the rune into the LSBs of b\n    assembly {\n      b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF)\n    }\n    if (b < 0x80) {\n      l = 1;\n    } else if (b < 0xE0) {\n      l = 2;\n    } else if (b < 0xF0) {\n      l = 3;\n    } else {\n      l = 4;\n    }\n\n    // Check for truncated codepoints\n    if (l > self._len) {\n      rune._len = self._len;\n      self._ptr += self._len;\n      self._len = 0;\n      return rune;\n    }\n\n    self._ptr += l;\n    self._len -= l;\n    rune._len = l;\n    return rune;\n  }\n\n  /*\n   * @dev Returns the first rune in the slice, advancing the slice to point\n   *      to the next rune.\n   * @param self The slice to operate on.\n   * @return A slice containing only the first rune from `self`.\n   */\n  function nextRune(slice memory self)\n    internal\n    pure\n    returns (slice memory ret)\n  {\n    nextRune(self, ret);\n  }\n\n  /*\n   * @dev Returns the number of the first codepoint in the slice.\n   * @param self The slice to operate on.\n   * @return The number of the first codepoint in the slice.\n   */\n  function ord(slice memory self) internal pure returns (uint256 ret) {\n    if (self._len == 0) {\n      return 0;\n    }\n\n    uint256 word;\n    uint256 length;\n    uint256 divisor = 2**248;\n\n    // Load the rune into the MSBs of b\n    assembly {\n      word := mload(mload(add(self, 32)))\n    }\n    uint256 b = word / divisor;\n    if (b < 0x80) {\n      ret = b;\n      length = 1;\n    } else if (b < 0xE0) {\n      ret = b & 0x1F;\n      length = 2;\n    } else if (b < 0xF0) {\n      ret = b & 0x0F;\n      length = 3;\n    } else {\n      ret = b & 0x07;\n      length = 4;\n    }\n\n    // Check for truncated codepoints\n    if (length > self._len) {\n      return 0;\n    }\n\n    for (uint256 i = 1; i < length; i++) {\n      divisor = divisor / 256;\n      b = (word / divisor) & 0xFF;\n      if (b & 0xC0 != 0x80) {\n        // Invalid UTF-8 sequence\n        return 0;\n      }\n      ret = (ret * 64) | (b & 0x3F);\n    }\n\n    return ret;\n  }\n\n  /*\n   * @dev Returns the keccak-256 hash of the slice.\n   * @param self The slice to hash.\n   * @return The hash of the slice.\n   */\n  function keccak(slice memory self) internal pure returns (bytes32 ret) {\n    assembly {\n      ret := keccak256(mload(add(self, 32)), mload(self))\n    }\n  }\n\n  /*\n   * @dev Returns true if `self` starts with `needle`.\n   * @param self The slice to operate on.\n   * @param needle The slice to search for.\n   * @return True if the slice starts with the provided text, false otherwise.\n   */\n  function startsWith(slice memory self, slice memory needle)\n    internal\n    pure\n    returns (bool)\n  {\n    if (self._len < needle._len) {\n      return false;\n    }\n\n    if (self._ptr == needle._ptr) {\n      return true;\n    }\n\n    bool equal;\n    assembly {\n      let length := mload(needle)\n      let selfptr := mload(add(self, 0x20))\n      let needleptr := mload(add(needle, 0x20))\n      equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n    }\n    return equal;\n  }\n\n  /*\n   * @dev If `self` starts with `needle`, `needle` is removed from the\n   *      beginning of `self`. Otherwise, `self` is unmodified.\n   * @param self The slice to operate on.\n   * @param needle The slice to search for.\n   * @return `self`\n   */\n  function beyond(slice memory self, slice memory needle)\n    internal\n    pure\n    returns (slice memory)\n  {\n    if (self._len < needle._len) {\n      return self;\n    }\n\n    bool equal = true;\n    if (self._ptr != needle._ptr) {\n      assembly {\n        let length := mload(needle)\n        let selfptr := mload(add(self, 0x20))\n        let needleptr := mload(add(needle, 0x20))\n        equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n      }\n    }\n\n    if (equal) {\n      self._len -= needle._len;\n      self._ptr += needle._len;\n    }\n\n    return self;\n  }\n\n  /*\n   * @dev Returns true if the slice ends with `needle`.\n   * @param self The slice to operate on.\n   * @param needle The slice to search for.\n   * @return True if the slice starts with the provided text, false otherwise.\n   */\n  function endsWith(slice memory self, slice memory needle)\n    internal\n    pure\n    returns (bool)\n  {\n    if (self._len < needle._len) {\n      return false;\n    }\n\n    uint256 selfptr = self._ptr + self._len - needle._len;\n\n    if (selfptr == needle._ptr) {\n      return true;\n    }\n\n    bool equal;\n    assembly {\n      let length := mload(needle)\n      let needleptr := mload(add(needle, 0x20))\n      equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n    }\n\n    return equal;\n  }\n\n  /*\n   * @dev If `self` ends with `needle`, `needle` is removed from the\n   *      end of `self`. Otherwise, `self` is unmodified.\n   * @param self The slice to operate on.\n   * @param needle The slice to search for.\n   * @return `self`\n   */\n  function until(slice memory self, slice memory needle)\n    internal\n    pure\n    returns (slice memory)\n  {\n    if (self._len < needle._len) {\n      return self;\n    }\n\n    uint256 selfptr = self._ptr + self._len - needle._len;\n    bool equal = true;\n    if (selfptr != needle._ptr) {\n      assembly {\n        let length := mload(needle)\n        let needleptr := mload(add(needle, 0x20))\n        equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\n      }\n    }\n\n    if (equal) {\n      self._len -= needle._len;\n    }\n\n    return self;\n  }\n\n  // Returns the memory address of the first byte of the first occurrence of\n  // `needle` in `self`, or the first byte after `self` if not found.\n  function findPtr(\n    uint256 selflen,\n    uint256 selfptr,\n    uint256 needlelen,\n    uint256 needleptr\n  ) private pure returns (uint256) {\n    uint256 ptr = selfptr;\n    uint256 idx;\n\n    if (needlelen <= selflen) {\n      if (needlelen <= 32) {\n        bytes32 mask;\n        if (needlelen > 0) {\n          mask = bytes32(~(2**(8 * (32 - needlelen)) - 1));\n        }\n\n        bytes32 needledata;\n        assembly {\n          needledata := and(mload(needleptr), mask)\n        }\n\n        uint256 end = selfptr + selflen - needlelen;\n        bytes32 ptrdata;\n        assembly {\n          ptrdata := and(mload(ptr), mask)\n        }\n\n        while (ptrdata != needledata) {\n          if (ptr >= end) return selfptr + selflen;\n          ptr++;\n          assembly {\n            ptrdata := and(mload(ptr), mask)\n          }\n        }\n        return ptr;\n      } else {\n        // For long needles, use hashing\n        bytes32 hash;\n        assembly {\n          hash := keccak256(needleptr, needlelen)\n        }\n\n        for (idx = 0; idx <= selflen - needlelen; idx++) {\n          bytes32 testHash;\n          assembly {\n            testHash := keccak256(ptr, needlelen)\n          }\n          if (hash == testHash) return ptr;\n          ptr += 1;\n        }\n      }\n    }\n    return selfptr + selflen;\n  }\n\n  // Returns the memory address of the first byte after the last occurrence of\n  // `needle` in `self`, or the address of `self` if not found.\n  function rfindPtr(\n    uint256 selflen,\n    uint256 selfptr,\n    uint256 needlelen,\n    uint256 needleptr\n  ) private pure returns (uint256) {\n    uint256 ptr;\n\n    if (needlelen <= selflen) {\n      if (needlelen <= 32) {\n        bytes32 mask;\n        if (needlelen > 0) {\n          mask = bytes32(~(2**(8 * (32 - needlelen)) - 1));\n        }\n\n        bytes32 needledata;\n        assembly {\n          needledata := and(mload(needleptr), mask)\n        }\n\n        ptr = selfptr + selflen - needlelen;\n        bytes32 ptrdata;\n        assembly {\n          ptrdata := and(mload(ptr), mask)\n        }\n\n        while (ptrdata != needledata) {\n          if (ptr <= selfptr) return selfptr;\n          ptr--;\n          assembly {\n            ptrdata := and(mload(ptr), mask)\n          }\n        }\n        return ptr + needlelen;\n      } else {\n        // For long needles, use hashing\n        bytes32 hash;\n        assembly {\n          hash := keccak256(needleptr, needlelen)\n        }\n        ptr = selfptr + (selflen - needlelen);\n        while (ptr >= selfptr) {\n          bytes32 testHash;\n          assembly {\n            testHash := keccak256(ptr, needlelen)\n          }\n          if (hash == testHash) return ptr + needlelen;\n          ptr -= 1;\n        }\n      }\n    }\n    return selfptr;\n  }\n\n  /*\n   * @dev Modifies `self` to contain everything from the first occurrence of\n   *      `needle` to the end of the slice. `self` is set to the empty slice\n   *      if `needle` is not found.\n   * @param self The slice to search and modify.\n   * @param needle The text to search for.\n   * @return `self`.\n   */\n  function find(slice memory self, slice memory needle)\n    internal\n    pure\n    returns (slice memory)\n  {\n    uint256 ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\n    self._len -= ptr - self._ptr;\n    self._ptr = ptr;\n    return self;\n  }\n\n  /*\n   * @dev Modifies `self` to contain the part of the string from the start of\n   *      `self` to the end of the first occurrence of `needle`. If `needle`\n   *      is not found, `self` is set to the empty slice.\n   * @param self The slice to search and modify.\n   * @param needle The text to search for.\n   * @return `self`.\n   */\n  function rfind(slice memory self, slice memory needle)\n    internal\n    pure\n    returns (slice memory)\n  {\n    uint256 ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\n    self._len = ptr - self._ptr;\n    return self;\n  }\n\n  /*\n   * @dev Splits the slice, setting `self` to everything after the first\n   *      occurrence of `needle`, and `token` to everything before it. If\n   *      `needle` does not occur in `self`, `self` is set to the empty slice,\n   *      and `token` is set to the entirety of `self`.\n   * @param self The slice to split.\n   * @param needle The text to search for in `self`.\n   * @param token An output parameter to which the first token is written.\n   * @return `token`.\n   */\n  function split(\n    slice memory self,\n    slice memory needle,\n    slice memory token\n  ) internal pure returns (slice memory) {\n    uint256 ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\n    token._ptr = self._ptr;\n    token._len = ptr - self._ptr;\n    if (ptr == self._ptr + self._len) {\n      // Not found\n      self._len = 0;\n    } else {\n      self._len -= token._len + needle._len;\n      self._ptr = ptr + needle._len;\n    }\n    return token;\n  }\n\n  /*\n   * @dev Splits the slice, setting `self` to everything after the first\n   *      occurrence of `needle`, and returning everything before it. If\n   *      `needle` does not occur in `self`, `self` is set to the empty slice,\n   *      and the entirety of `self` is returned.\n   * @param self The slice to split.\n   * @param needle The text to search for in `self`.\n   * @return The part of `self` up to the first occurrence of `delim`.\n   */\n  function split(slice memory self, slice memory needle)\n    internal\n    pure\n    returns (slice memory token)\n  {\n    split(self, needle, token);\n  }\n\n  /*\n   * @dev Splits the slice, setting `self` to everything before the last\n   *      occurrence of `needle`, and `token` to everything after it. If\n   *      `needle` does not occur in `self`, `self` is set to the empty slice,\n   *      and `token` is set to the entirety of `self`.\n   * @param self The slice to split.\n   * @param needle The text to search for in `self`.\n   * @param token An output parameter to which the first token is written.\n   * @return `token`.\n   */\n  function rsplit(\n    slice memory self,\n    slice memory needle,\n    slice memory token\n  ) internal pure returns (slice memory) {\n    uint256 ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\n    token._ptr = ptr;\n    token._len = self._len - (ptr - self._ptr);\n    if (ptr == self._ptr) {\n      // Not found\n      self._len = 0;\n    } else {\n      self._len -= token._len + needle._len;\n    }\n    return token;\n  }\n\n  /*\n   * @dev Splits the slice, setting `self` to everything before the last\n   *      occurrence of `needle`, and returning everything after it. If\n   *      `needle` does not occur in `self`, `self` is set to the empty slice,\n   *      and the entirety of `self` is returned.\n   * @param self The slice to split.\n   * @param needle The text to search for in `self`.\n   * @return The part of `self` after the last occurrence of `delim`.\n   */\n  function rsplit(slice memory self, slice memory needle)\n    internal\n    pure\n    returns (slice memory token)\n  {\n    rsplit(self, needle, token);\n  }\n\n  /*\n   * @dev Counts the number of nonoverlapping occurrences of `needle` in `self`.\n   * @param self The slice to search.\n   * @param needle The text to search for in `self`.\n   * @return The number of occurrences of `needle` found in `self`.\n   */\n  function count(slice memory self, slice memory needle)\n    internal\n    pure\n    returns (uint256 cnt)\n  {\n    uint256 ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr) +\n      needle._len;\n    while (ptr <= self._ptr + self._len) {\n      cnt++;\n      ptr =\n        findPtr(self._len - (ptr - self._ptr), ptr, needle._len, needle._ptr) +\n        needle._len;\n    }\n  }\n\n  /*\n   * @dev Returns True if `self` contains `needle`.\n   * @param self The slice to search.\n   * @param needle The text to search for in `self`.\n   * @return True if `needle` is found in `self`, false otherwise.\n   */\n  function contains(slice memory self, slice memory needle)\n    internal\n    pure\n    returns (bool)\n  {\n    return\n      rfindPtr(self._len, self._ptr, needle._len, needle._ptr) != self._ptr;\n  }\n\n  /*\n   * @dev Returns a newly allocated string containing the concatenation of\n   *      `self` and `other`.\n   * @param self The first slice to concatenate.\n   * @param other The second slice to concatenate.\n   * @return The concatenation of the two strings.\n   */\n  function concat(slice memory self, slice memory other)\n    internal\n    pure\n    returns (string memory)\n  {\n    string memory ret = new string(self._len + other._len);\n    uint256 retptr;\n    assembly {\n      retptr := add(ret, 32)\n    }\n    memcpy(retptr, self._ptr, self._len);\n    memcpy(retptr + self._len, other._ptr, other._len);\n    return ret;\n  }\n\n  /*\n   * @dev Joins an array of slices, using `self` as a delimiter, returning a\n   *      newly allocated string.\n   * @param self The delimiter to use.\n   * @param parts A list of slices to join.\n   * @return A newly allocated string containing all the slices in `parts`,\n   *         joined with `self`.\n   */\n  function join(slice memory self, slice[] memory parts)\n    internal\n    pure\n    returns (string memory)\n  {\n    if (parts.length == 0) return \"\";\n\n    uint256 length = self._len * (parts.length - 1);\n    for (uint256 i = 0; i < parts.length; i++) length += parts[i]._len;\n\n    string memory ret = new string(length);\n    uint256 retptr;\n    assembly {\n      retptr := add(ret, 32)\n    }\n\n    for (uint256 i = 0; i < parts.length; i++) {\n      memcpy(retptr, parts[i]._ptr, parts[i]._len);\n      retptr += parts[i]._len;\n      if (i < parts.length - 1) {\n        memcpy(retptr, self._ptr, self._len);\n        retptr += self._len;\n      }\n    }\n\n    return ret;\n  }\n}\n"
    },
    "src/v0.8/utils/utils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @notice getRevertMsg extracts a revert reason from a failed contract call\n */\nfunction getRevertMsg(bytes memory payload) pure returns (string memory) {\n  if (payload.length < 68) return \"transaction reverted silently\";\n  assembly {\n    payload := add(payload, 0x04)\n  }\n  return abi.decode(payload, (string));\n}\n"
    },
    "src/v0.8/KeeperCompatible.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./KeeperBase.sol\";\nimport \"./interfaces/KeeperCompatibleInterface.sol\";\n\nabstract contract KeeperCompatible is KeeperBase, KeeperCompatibleInterface {}\n"
    },
    "src/v0.8/tests/KeeperCompatibleTestHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../KeeperCompatible.sol\";\n\ncontract KeeperCompatibleTestHelper is KeeperCompatible {\n  function checkUpkeep(bytes calldata) external override returns (bool, bytes memory) {}\n\n  function performUpkeep(bytes calldata) external override {}\n\n  function testCannotExecute() public view cannotExecute {}\n}\n"
    },
    "src/v0.8/dev/KeepersVRFConsumer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport \"../KeeperCompatible.sol\";\nimport \"../VRFConsumerBaseV2.sol\";\nimport \"../interfaces/VRFCoordinatorV2Interface.sol\";\n\n/**\n * @title KeepersVRFConsumer\n * @notice KeepersVRFConsumer is a Chainlink Keepers compatible contract that also acts as a\n * VRF V2 requester and consumer. In particular, a random words request is made when `performUpkeep`\n * is called in a cadence provided by the upkeep interval.\n */\ncontract KeepersVRFConsumer is KeeperCompatibleInterface, VRFConsumerBaseV2 {\n  // Upkeep interval in seconds. This contract's performUpkeep method will\n  // be called by the Keepers network roughly every UPKEEP_INTERVAL seconds.\n  uint256 public immutable UPKEEP_INTERVAL;\n\n  // VRF V2 information, provided upon contract construction.\n  VRFCoordinatorV2Interface public immutable COORDINATOR;\n  uint64 public immutable SUBSCRIPTION_ID;\n  uint16 public immutable REQUEST_CONFIRMATIONS;\n  bytes32 public immutable KEY_HASH;\n\n  // Contract state, updated in performUpkeep and fulfillRandomWords.\n  uint256 public s_lastTimeStamp;\n  uint256 public s_vrfRequestCounter;\n  uint256 public s_vrfResponseCounter;\n\n  struct RequestRecord {\n    uint256 requestId;\n    bool fulfilled;\n    uint32 callbackGasLimit;\n    uint256 randomness;\n  }\n  mapping(uint256 => RequestRecord) public s_requests; /* request ID */ /* request record */\n\n  constructor(\n    address vrfCoordinator,\n    uint64 subscriptionId,\n    bytes32 keyHash,\n    uint16 requestConfirmations,\n    uint256 upkeepInterval\n  ) VRFConsumerBaseV2(vrfCoordinator) {\n    COORDINATOR = VRFCoordinatorV2Interface(vrfCoordinator);\n    SUBSCRIPTION_ID = subscriptionId;\n    REQUEST_CONFIRMATIONS = requestConfirmations;\n    KEY_HASH = keyHash;\n    UPKEEP_INTERVAL = upkeepInterval;\n\n    s_lastTimeStamp = block.timestamp;\n    s_vrfRequestCounter = 0;\n    s_vrfResponseCounter = 0;\n  }\n\n  /**\n   * @notice Returns true if and only if at least UPKEEP_INTERVAL seconds have elapsed\n   * since the last upkeep or since construction of the contract.\n   * @return upkeepNeeded true if and only if at least UPKEEP_INTERVAL seconds have elapsed since the last upkeep or since construction\n   * of the contract.\n   */\n  function checkUpkeep(\n    bytes calldata /* checkData */\n  )\n    external\n    view\n    override\n    returns (\n      bool upkeepNeeded,\n      bytes memory /* performData */\n    )\n  {\n    upkeepNeeded = (block.timestamp - s_lastTimeStamp) > UPKEEP_INTERVAL;\n  }\n\n  /**\n   * @notice Requests random words from the VRF coordinator if UPKEEP_INTERVAL seconds have elapsed\n   * since the last upkeep or since construction of the contract.\n   */\n  function performUpkeep(\n    bytes calldata /* performData */\n  ) external override {\n    if ((block.timestamp - s_lastTimeStamp) > UPKEEP_INTERVAL) {\n      s_lastTimeStamp = block.timestamp;\n\n      requestRandomWords();\n    }\n  }\n\n  /**\n   * @notice VRF callback implementation\n   * @param requestId the VRF V2 request ID, provided at request time.\n   * @param randomWords the randomness provided by Chainlink VRF.\n   */\n  function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal override {\n    // Check that the request exists. If not, revert.\n    RequestRecord memory record = s_requests[requestId];\n    require(record.requestId == requestId, \"request ID not found in map\");\n\n    // Update the randomness in the record, and increment the response counter.\n    s_requests[requestId].randomness = randomWords[0];\n    s_vrfResponseCounter++;\n  }\n\n  /**\n   * @notice Requests random words from Chainlink VRF.\n   */\n  function requestRandomWords() internal {\n    uint256 requestId = COORDINATOR.requestRandomWords(\n      KEY_HASH,\n      SUBSCRIPTION_ID,\n      REQUEST_CONFIRMATIONS,\n      150000, // callback gas limit\n      1 // num words\n    );\n    s_requests[requestId] = RequestRecord({\n      requestId: requestId,\n      fulfilled: false,\n      callbackGasLimit: 150000,\n      randomness: 0\n    });\n    s_vrfRequestCounter++;\n  }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overriden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
    },
    "src/v0.8/PermissionedForwardProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"./ConfirmedOwner.sol\";\n\n/**\n * @title PermissionedForwardProxy\n * @notice This proxy is used to forward calls from sender to target. It maintains\n * a permission list to check which sender is allowed to call which target\n */\ncontract PermissionedForwardProxy is ConfirmedOwner {\n  using Address for address;\n\n  error PermissionNotSet();\n\n  event PermissionSet(address indexed sender, address target);\n  event PermissionRemoved(address indexed sender);\n\n  mapping(address => address) private s_forwardPermissionList;\n\n  constructor() ConfirmedOwner(msg.sender) {}\n\n  /**\n   * @notice Verifies if msg.sender has permission to forward to target address and then forwards the handler\n   * @param target address of the contract to forward the handler to\n   * @param handler bytes to be passed to target in call data\n   */\n  function forward(address target, bytes calldata handler) external {\n    if (s_forwardPermissionList[msg.sender] != target) {\n      revert PermissionNotSet();\n    }\n    target.functionCall(handler);\n  }\n\n  /**\n   * @notice Adds permission for sender to forward calls to target via this proxy.\n   * Note that it allows to overwrite an existing permission\n   * @param sender The address who will use this proxy to forward calls\n   * @param target The address where sender will be allowed to forward calls\n   */\n  function setPermission(address sender, address target) external onlyOwner {\n    s_forwardPermissionList[sender] = target;\n\n    emit PermissionSet(sender, target);\n  }\n\n  /**\n   * @notice Removes permission for sender to forward calls via this proxy\n   * @param sender The address who will use this proxy to forward calls\n   */\n  function removePermission(address sender) external onlyOwner {\n    delete s_forwardPermissionList[sender];\n\n    emit PermissionRemoved(sender);\n  }\n\n  /**\n   * @notice Returns the target address that the sender can use this proxy for\n   * @param sender The address to fetch the permissioned target for\n   */\n  function getPermission(address sender) external view returns (address) {\n    return s_forwardPermissionList[sender];\n  }\n}\n"
    },
    "src/v0.8/tests/Greeter.sol": {
      "content": "pragma solidity ^0.8.0;\n\nimport \"../ConfirmedOwner.sol\";\n\ncontract Greeter is ConfirmedOwner {\n  string public greeting;\n\n  constructor(address owner) ConfirmedOwner(owner) {}\n\n  function setGreeting(string calldata _greeting) external onlyOwner {\n    require(bytes(_greeting).length > 0, \"Invalid greeting length\");\n    greeting = _greeting;\n  }\n\n  function triggerRevert() external pure {\n    require(false, \"Greeter: revert triggered\");\n  }\n}\n"
    },
    "src/v0.8/tests/VRFExternalSubOwnerExample.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../interfaces/LinkTokenInterface.sol\";\nimport \"../interfaces/VRFCoordinatorV2Interface.sol\";\nimport \"../VRFConsumerBaseV2.sol\";\n\ncontract VRFExternalSubOwnerExample is VRFConsumerBaseV2 {\n  VRFCoordinatorV2Interface COORDINATOR;\n  LinkTokenInterface LINKTOKEN;\n\n  uint256[] public s_randomWords;\n  uint256 public s_requestId;\n  address s_owner;\n\n  constructor(address vrfCoordinator, address link) VRFConsumerBaseV2(vrfCoordinator) {\n    COORDINATOR = VRFCoordinatorV2Interface(vrfCoordinator);\n    LINKTOKEN = LinkTokenInterface(link);\n    s_owner = msg.sender;\n  }\n\n  function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal override {\n    require(requestId == s_requestId, \"request ID is incorrect\");\n    s_randomWords = randomWords;\n  }\n\n  function requestRandomWords(\n    uint64 subId,\n    uint32 callbackGasLimit,\n    uint16 requestConfirmations,\n    uint32 numWords,\n    bytes32 keyHash\n  ) external onlyOwner {\n    // Will revert if subscription is not funded.\n    s_requestId = COORDINATOR.requestRandomWords(keyHash, subId, requestConfirmations, callbackGasLimit, numWords);\n  }\n\n  function transferOwnership(address newOwner) external onlyOwner {\n    s_owner = newOwner;\n  }\n\n  modifier onlyOwner() {\n    require(msg.sender == s_owner);\n    _;\n  }\n}\n"
    },
    "src/v0.8/tests/VRFConsumerV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../interfaces/LinkTokenInterface.sol\";\nimport \"../interfaces/VRFCoordinatorV2Interface.sol\";\nimport \"../VRFConsumerBaseV2.sol\";\n\ncontract VRFConsumerV2 is VRFConsumerBaseV2 {\n  uint256[] public s_randomWords;\n  uint256 public s_requestId;\n  VRFCoordinatorV2Interface COORDINATOR;\n  LinkTokenInterface LINKTOKEN;\n  uint64 public s_subId;\n  uint256 public s_gasAvailable;\n\n  constructor(address vrfCoordinator, address link) VRFConsumerBaseV2(vrfCoordinator) {\n    COORDINATOR = VRFCoordinatorV2Interface(vrfCoordinator);\n    LINKTOKEN = LinkTokenInterface(link);\n  }\n\n  function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal override {\n    require(requestId == s_requestId, \"request ID is incorrect\");\n\n    s_gasAvailable = gasleft();\n    s_randomWords = randomWords;\n  }\n\n  function testCreateSubscriptionAndFund(uint96 amount) external {\n    if (s_subId == 0) {\n      s_subId = COORDINATOR.createSubscription();\n      COORDINATOR.addConsumer(s_subId, address(this));\n    }\n    // Approve the link transfer.\n    LINKTOKEN.transferAndCall(address(COORDINATOR), amount, abi.encode(s_subId));\n  }\n\n  function topUpSubscription(uint96 amount) external {\n    require(s_subId != 0, \"sub not set\");\n    // Approve the link transfer.\n    LINKTOKEN.transferAndCall(address(COORDINATOR), amount, abi.encode(s_subId));\n  }\n\n  function updateSubscription(address[] memory consumers) external {\n    require(s_subId != 0, \"subID not set\");\n    for (uint256 i = 0; i < consumers.length; i++) {\n      COORDINATOR.addConsumer(s_subId, consumers[i]);\n    }\n  }\n\n  function testRequestRandomness(\n    bytes32 keyHash,\n    uint64 subId,\n    uint16 minReqConfs,\n    uint32 callbackGasLimit,\n    uint32 numWords\n  ) external returns (uint256) {\n    s_requestId = COORDINATOR.requestRandomWords(keyHash, subId, minReqConfs, callbackGasLimit, numWords);\n    return s_requestId;\n  }\n}\n"
    },
    "src/v0.8/mocks/VRFCoordinatorV2Mock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// A mock for testing code that relies on VRFCoordinatorV2.\npragma solidity ^0.8.4;\n\nimport \"../interfaces/LinkTokenInterface.sol\";\nimport \"../interfaces/VRFCoordinatorV2Interface.sol\";\nimport \"../VRFConsumerBaseV2.sol\";\n\ncontract VRFCoordinatorV2Mock is VRFCoordinatorV2Interface {\n  uint96 public immutable BASE_FEE;\n  uint96 public immutable GAS_PRICE_LINK;\n\n  error InvalidSubscription();\n  error InsufficientBalance();\n  error MustBeSubOwner(address owner);\n\n  event RandomWordsRequested(\n    bytes32 indexed keyHash,\n    uint256 requestId,\n    uint256 preSeed,\n    uint64 indexed subId,\n    uint16 minimumRequestConfirmations,\n    uint32 callbackGasLimit,\n    uint32 numWords,\n    address indexed sender\n  );\n  event RandomWordsFulfilled(uint256 indexed requestId, uint256 outputSeed, uint96 payment, bool success);\n  event SubscriptionCreated(uint64 indexed subId, address owner);\n  event SubscriptionFunded(uint64 indexed subId, uint256 oldBalance, uint256 newBalance);\n  event SubscriptionCanceled(uint64 indexed subId, address to, uint256 amount);\n\n  uint64 s_currentSubId;\n  uint256 s_nextRequestId = 1;\n  uint256 s_nextPreSeed = 100;\n  struct Subscription {\n    address owner;\n    uint96 balance;\n  }\n  mapping(uint64 => Subscription) s_subscriptions; /* subId */ /* subscription */\n\n  struct Request {\n    uint64 subId;\n    uint32 callbackGasLimit;\n    uint32 numWords;\n  }\n  mapping(uint256 => Request) s_requests; /* requestId */ /* request */\n\n  constructor(uint96 _baseFee, uint96 _gasPriceLink) {\n    BASE_FEE = _baseFee;\n    GAS_PRICE_LINK = _gasPriceLink;\n  }\n\n  /**\n   * @notice fulfillRandomWords fulfills the given request, sending the random words to the supplied\n   * @notice consumer.\n   *\n   * @dev This mock uses a simplified formula for calculating payment amount and gas usage, and does\n   * @dev not account for all edge cases handled in the real VRF coordinator. When making requests\n   * @dev against the real coordinator a small amount of additional LINK is required.\n   *\n   * @param _requestId the request to fulfill\n   * @param _consumer the VRF randomness consumer to send the result to\n   */\n  function fulfillRandomWords(uint256 _requestId, address _consumer) external {\n    uint256 startGas = gasleft();\n    if (s_requests[_requestId].subId == 0) {\n      revert(\"nonexistent request\");\n    }\n    Request memory req = s_requests[_requestId];\n\n    uint256[] memory words = new uint256[](req.numWords);\n    for (uint256 i = 0; i < req.numWords; i++) {\n      words[i] = uint256(keccak256(abi.encode(_requestId, i)));\n    }\n\n    VRFConsumerBaseV2 v;\n    bytes memory callReq = abi.encodeWithSelector(v.rawFulfillRandomWords.selector, _requestId, words);\n    (bool success, ) = _consumer.call{gas: req.callbackGasLimit}(callReq);\n\n    uint96 payment = uint96(BASE_FEE + ((startGas - gasleft()) * GAS_PRICE_LINK));\n    if (s_subscriptions[req.subId].balance < payment) {\n      revert InsufficientBalance();\n    }\n    s_subscriptions[req.subId].balance -= payment;\n    delete (s_requests[_requestId]);\n    emit RandomWordsFulfilled(_requestId, _requestId, payment, success);\n  }\n\n  /**\n   * @notice fundSubscription allows funding a subscription with an arbitrary amount for testing.\n   *\n   * @param _subId the subscription to fund\n   * @param _amount the amount to fund\n   */\n  function fundSubscription(uint64 _subId, uint96 _amount) public {\n    if (s_subscriptions[_subId].owner == address(0)) {\n      revert InvalidSubscription();\n    }\n    uint96 oldBalance = s_subscriptions[_subId].balance;\n    s_subscriptions[_subId].balance += _amount;\n    emit SubscriptionFunded(_subId, oldBalance, oldBalance + _amount);\n  }\n\n  function requestRandomWords(\n    bytes32 _keyHash,\n    uint64 _subId,\n    uint16 _minimumRequestConfirmations,\n    uint32 _callbackGasLimit,\n    uint32 _numWords\n  ) external override returns (uint256) {\n    if (s_subscriptions[_subId].owner == address(0)) {\n      revert InvalidSubscription();\n    }\n\n    uint256 requestId = s_nextRequestId++;\n    uint256 preSeed = s_nextPreSeed++;\n\n    s_requests[requestId] = Request({subId: _subId, callbackGasLimit: _callbackGasLimit, numWords: _numWords});\n\n    emit RandomWordsRequested(\n      _keyHash,\n      requestId,\n      preSeed,\n      _subId,\n      _minimumRequestConfirmations,\n      _callbackGasLimit,\n      _numWords,\n      msg.sender\n    );\n    return requestId;\n  }\n\n  function createSubscription() external override returns (uint64 _subId) {\n    s_currentSubId++;\n    s_subscriptions[s_currentSubId] = Subscription({owner: msg.sender, balance: 0});\n    emit SubscriptionCreated(s_currentSubId, msg.sender);\n    return s_currentSubId;\n  }\n\n  function getSubscription(uint64 _subId)\n    external\n    view\n    override\n    returns (\n      uint96 balance,\n      uint64 reqCount,\n      address owner,\n      address[] memory consumers\n    )\n  {\n    if (s_subscriptions[_subId].owner == address(0)) {\n      revert InvalidSubscription();\n    }\n    return (s_subscriptions[_subId].balance, 0, s_subscriptions[_subId].owner, new address[](0));\n  }\n\n  function cancelSubscription(uint64 _subId, address _to) external override onlySubOwner(_subId) {\n    emit SubscriptionCanceled(_subId, _to, s_subscriptions[_subId].balance);\n    delete (s_subscriptions[_subId]);\n  }\n\n  modifier onlySubOwner(uint64 _subId) {\n    address owner = s_subscriptions[_subId].owner;\n    if (owner == address(0)) {\n      revert InvalidSubscription();\n    }\n    if (msg.sender != owner) {\n      revert MustBeSubOwner(owner);\n    }\n    _;\n  }\n\n  function getRequestConfig()\n    external\n    pure\n    override\n    returns (\n      uint16,\n      uint32,\n      bytes32[] memory\n    )\n  {\n    return (3, 2000000, new bytes32[](0));\n  }\n\n  function addConsumer(uint64 _subId, address _consumer) external pure override {\n    revert(\"not implemented\");\n  }\n\n  function removeConsumer(uint64 _subId, address _consumer) external pure override {\n    revert(\"not implemented\");\n  }\n\n  function requestSubscriptionOwnerTransfer(uint64 _subId, address _newOwner) external pure override {\n    revert(\"not implemented\");\n  }\n\n  function acceptSubscriptionOwnerTransfer(uint64 _subId) external pure override {\n    revert(\"not implemented\");\n  }\n\n  function pendingRequestExists(uint64 subId) public view override returns (bool) {\n    revert(\"not implemented\");\n  }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000000
    },
    "metadata": {
      "bytecodeHash": "none"
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  }
}}