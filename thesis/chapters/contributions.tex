\chapter{Contributions} 
% \addcontentsline{toc}{chapter}{Contributions}

\section{A way to contribute}
\paragraph*{}
The most challenging part was building smart contracts that were not fully optimized by Solidity's compiler, i.e. the generated bytecode contained redundant bytecode. This mostly meant finding situations, edge cases in which the compiler was "fooled" by the high level code, making it impossible for various optimizations to be applied or simply ignored.

The first approach here was to experiment with Solidity and compile smart contracts until such an edge case was found. The challenge here is that it is very difficult and time consuming to analyze the generated bytecode and try to find an optimization opportunity, since assembly instructions are not "human readable".

The second approach was to reverse engineer Solidity's open-source codebase, get familiar with the internal optimizer structure and brain storm on edge cases that are not treated by the optimizer. While this is definitely a good approach, it requires a bit of experience with optimizers and some time to get familiar with Solidity's codebase.

What helped by a great margin was the usage of \textbf{YUL Intermediate Representation}, which can be analyzed in its optimized form, since it is the intermediate code used to generate the final bytecode. This way, it was much faster to analyse whether the generated bytecode would be optimal or not.

\section{Enhancement of optimization steps}
\paragraph*{}
Solidity's optimizer has \href{https://docs.soliditylang.org/en/v0.8.14/internals/optimizer.html#optimizer-steps}{32 documented optimization steps}, out of which this thesis focuses on two of them: \textbf{UnusedPruner} and \textbf{UnusedAssignmentEliminator}. One of the most straightforward way to speed up code computation is to run less code, which comes from generating the proper bytecode and from pruning "dead code", i.e. high level code that the user wrote but is unreachable. We'll also take a look at \textbf{StructuralSimplifier} and \textbf{DataFlowAnalyzer}, the latter being a core component of the optimizer that enhances static analysis.

In this thesis, I've managed to identify several edge cases that fool the optimizer, and by treating the respective edge cases, I've improved the functionality of the two optimization steps mentioned above. A few other observations are made throughout the thesis, which can easily transform into external contributions to ultimately generate a more efficient smart contract.

\section{Reducing gas usage of smart contracts}
\paragraph*{}
The quality of Solidity's compiler and optimizer is evaluated by the \textbf{gas usage} of the smart contract, both deployment on the network and the cost of running a function by its signature. With the optimizations mentioned above, the optimizer \textbf{generated code that requires less gas}, which means less ethereum, which means smaller costs for the user.

Multiply any small, seemly insignificant gas improvement by the millions of smart contracts on the Ethereum blockchain and you end up with a pretty significant cost reduction in code execution. Therefore, external contributions as these will sum up to bring a real difference in code quality\footnote[1]{We will dive deeper into which smart contracts will benefit from these optimizations and how optimization steps give more opportunities to other optimization steps in the latter chapters.}.
