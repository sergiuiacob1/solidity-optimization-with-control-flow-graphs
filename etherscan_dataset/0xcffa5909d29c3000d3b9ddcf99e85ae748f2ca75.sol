{{
  "language": "Solidity",
  "sources": {
    "project:/contracts/Bridge.sol": {
      "content": "pragma solidity 0.6.4;\npragma experimental ABIEncoderV2;\n\nimport \"./utils/Pausable.sol\";\nimport \"./utils/SafeMath.sol\";\nimport \"./utils/UpgradableOwnable.sol\";\nimport \"./interfaces/IDepositExecute.sol\";\nimport \"./interfaces/IBridge.sol\";\nimport \"./interfaces/IERCHandler.sol\";\n\n/**\n    @title Facilitates deposits, creation and votiing of deposit proposals, and deposit executions.\n */\ncontract Bridge is Pausable, SafeMathContract, UpgradableOwnable {\n    bytes8 public _chainID;\n    uint256 public _fee;\n    address public _backendSrvAddress;\n\n    enum ProposalStatus {\n        Inactive,\n        Active,\n        Passed,\n        Executed,\n        Cancelled\n    }\n\n    bytes32 public _nativeResourceID;\n\n    // destinationChainID => number of deposits\n    mapping(bytes8 => uint64) public _depositCounts;\n    // resourceID => handler address\n    mapping(bytes32 => address) public _resourceIDToHandlerAddress;\n    // depositNonce => destinationChainID => bytes\n    mapping(uint64 => mapping(bytes8 => bytes)) public _depositRecords;\n    // destinationChainID + depositNonce => dataHash => bool\n    mapping(bytes32 => mapping(bytes32 => bool)) public _executedProposals;\n\n    mapping(address => bool) public handlers;\n\n    event Deposit(\n        bytes8 originChainID,\n        bytes8 indexed destinationChainID,\n        bytes32 indexed resourceID,\n        uint64 indexed depositNonce,\n        address depositor,\n        address recipientAddress,\n        address tokenAddress,\n        uint256 amount,\n        bytes32 dataHash\n    );\n    event ProposalEvent(\n        bytes8 indexed originChainID,\n        bytes8 indexed destinationChainID,\n        address indexed recipientAddress,\n        uint256 amount,\n        uint64 depositNonce,\n        ProposalStatus status,\n        bytes32 resourceID,\n        bytes32 dataHash\n    );\n    event ExtraFeeSupplied(\n        bytes8 originChainID,\n        bytes8 destinationChainID,\n        uint64 depositNonce,\n        bytes32 resourceID,\n        address recipientAddress,\n        uint256 amount\n    );\n\n    modifier onlyBackendSrv() {\n        _onlyBackendSrv();\n        _;\n    }\n\n    function _onlyBackendSrv() private view {\n        require(\n            _backendSrvAddress == msg.sender,\n            \"sender is not a backend service\"\n        );\n    }\n\n    modifier onlyHandler() {\n        require(handlers[msg.sender], \"sender is not a handler\" );\n        _;\n    }\n\n    function setHandler(address _handler, bool value) external onlyBackendSrv {\n        handlers[_handler] = value;\n    }\n\n    /**\n        @notice Initializes Bridge, creates and grants {msg.sender} the admin role,\n        Sets deposit fee\n        @param chainID ID of chain the Bridge contract exists on.\n     */\n    function initialize(\n        bytes8 chainID,\n        uint256 fee,\n        address initBackendSrvAddress\n    ) public {\n        _chainID = chainID;\n        _fee = fee;\n        _backendSrvAddress = initBackendSrvAddress;\n        ownableInit(msg.sender);\n    }\n\n    /**\n        @notice sets new backend srv.\n        @notice Only callable by an address that currently has the admin role.\n        @param newBackendSrv Address of new backend srv.\n     */\n    function setBackendSrv(address newBackendSrv) external onlyBackendSrv {\n        _backendSrvAddress = newBackendSrv;\n    }\n\n    /**\n        @notice Pauses deposits, proposal creation and voting, and deposit executions.\n        @notice Only callable by an address that currently has the admin role.\n     */\n    function adminPauseTransfers() external onlyOwner {\n        _pause();\n    }\n\n    /**\n        @notice Unpauses deposits, proposal creation and voting, and deposit executions.\n        @notice Only callable by an address that currently has the admin role.\n     */\n    function adminUnpauseTransfers() external onlyOwner {\n        _unpause();\n    }\n\n    /**\n        @notice Sets a new resource for handler contracts that use the IERCHandler interface,\n        and maps the {handlerAddress} to {resourceID} in {_resourceIDToHandlerAddress}.\n        @notice Only callable by an address that currently has the admin role.\n        @param handlerAddress Address of handler resource will be set for.\n        @param resourceID ResourceID to be used when making deposits.\n        @param tokenAddress Address of contract to be called when a deposit is made and a deposited is executed.\n     */\n    function setResource(\n        address handlerAddress,\n        bytes32 resourceID,\n        address tokenAddress\n    ) external onlyBackendSrv {\n        _resourceIDToHandlerAddress[resourceID] = handlerAddress;\n        IERCHandler handler = IERCHandler(handlerAddress);\n        handler.setResource(resourceID, tokenAddress);\n        handlers[handlerAddress] = true;\n    }\n\n    /**\n        @notice sets resourceID for native token\n        @dev can only be called through admin address\n        @param resourceID resourceID for native token\n     */\n    function setNativeResourceID(bytes32 resourceID) external onlyBackendSrv {\n        _nativeResourceID = resourceID;\n    }\n\n    /**\n        @notice Sets a resource as burnable for handler contracts that use the IERCHandler interface.\n        @notice Only callable by an address that currently has the admin role.\n        @param handlerAddress Address of handler resource will be set for.\n        @param tokenAddress Address of contract to be called when a deposit is made and a deposited is executed.\n     */\n    function setBurnable(address handlerAddress, address tokenAddress)\n        external\n        onlyBackendSrv\n    {\n        IERCHandler handler = IERCHandler(handlerAddress);\n        handler.setBurnable(tokenAddress);\n    }\n\n    /**\n        @notice Changes deposit fee.\n        @notice Only callable by admin.\n        @param newFee Value {_fee} will be updated to.\n     */\n    function changeFee(uint256 newFee) external onlyBackendSrv {\n        require(_fee != newFee, \"Current fee is equal to new fee\");\n        _fee = newFee;\n    }\n\n    /**\n        @notice Used to manually withdraw funds from ERC safes.\n        @param handlerAddress Address of handler to withdraw from.\n        @param tokenAddress Address of token to withdraw.\n        @param recipient Address to withdraw tokens to.\n        @param amountOrTokenID Either the amount of ERC20 tokens or the ERC721 token ID to withdraw.\n     */\n    function adminWithdraw(\n        address handlerAddress,\n        address tokenAddress,\n        address recipient,\n        uint256 amountOrTokenID\n    ) external onlyOwner {\n        IERCHandler handler = IERCHandler(handlerAddress);\n        handler.withdraw(tokenAddress, recipient, amountOrTokenID);\n    }\n\n    /**\n        @notice Used to approve spending tokens by another handler.\n        @param resourceIDOwner ID of owner handler.\n        @param resourceIDSpender ID of spender handler.\n        @param amountOrTokenID Either the amount of ERC20 tokens or the ERC721 token ID to approve.\n     */\n    function approveSpending(\n        bytes32 resourceIDOwner,\n        bytes32 resourceIDSpender,\n        uint256 amountOrTokenID\n    ) external onlyBackendSrv {\n        address handlerOwner = _resourceIDToHandlerAddress[resourceIDOwner];\n        require(handlerOwner != address(0), \"resourceIDOwner not mapped to handler\");\n\n        address handlerSpender = _resourceIDToHandlerAddress[resourceIDSpender];\n        require(handlerSpender != address(0), \"resourceIDSpender not mapped to handler\");\n\n        IERCHandler handler = IERCHandler(handlerOwner);\n        handler.approve(resourceIDOwner, handlerSpender, amountOrTokenID);\n    }\n\n    /**\n        @notice Initiates a transfer using a specified handler contract.\n        @notice Only callable when Bridge is not paused.\n        @param destinationChainID ID of chain deposit will be bridged to.\n        @param resourceID ResourceID used to find address of handler to be used for deposit.\n        @param amountToLA to be converted to LA with bridge swap.\n        @notice Emits {Deposit} event.\n     */\n    function deposit(\n        bytes8 destinationChainID,\n        bytes32 resourceID,\n        uint256 amount,\n        address recipientAddress,\n        uint256 amountToLA,\n        bytes calldata params\n    ) external payable whenNotPaused {\n        uint64 depositNonce = ++_depositCounts[destinationChainID];\n        bytes memory data = abi.encode(amount, recipientAddress);\n        bytes32 dataHash = keccak256(abi.encode(resourceID, data));\n        _depositRecords[depositNonce][destinationChainID] = data;\n\n        address tokenAddress;\n        uint256 totalAmount = amount + amountToLA;\n        if (resourceID == _nativeResourceID) {\n            require(\n                msg.value >= (totalAmount + _fee),\n                \"Incorrect fee/amount supplied\"\n            );\n\n            tokenAddress = address(0);\n\n        } else {\n            require(msg.value >= _fee, \"Incorrect fee supplied\");\n\n            address handler = _resourceIDToHandlerAddress[resourceID];\n            require(handler != address(0), \"resourceID not mapped to handler\");\n\n            tokenAddress = IDepositExecute(handler).deposit(\n                resourceID,\n                destinationChainID,\n                depositNonce,\n                msg.sender,\n                recipientAddress,\n                totalAmount,\n                params\n            );\n        }\n            if (amountToLA > 0) {\n                emit ExtraFeeSupplied(\n                    _chainID,\n                    destinationChainID,\n                    depositNonce,\n                    resourceID,\n                    recipientAddress,\n                    amountToLA\n                );\n            }\n\n        uint256 stackAmount = amount;\n\n        emit Deposit(\n            _chainID,\n            destinationChainID,\n            resourceID,\n            depositNonce,\n            msg.sender,\n            recipientAddress,\n            tokenAddress,\n            stackAmount,\n            dataHash\n        );\n    }\n    \n    // Deposit for AAVE amTokens\n    function internalDeposit(\n        bytes8 destinationChainID,\n        bytes32 resourceID,\n        uint256 amount,\n        address recipientAddress\n    ) public whenNotPaused onlyHandler {\n        uint64 depositNonce = ++_depositCounts[destinationChainID];\n        bytes memory data = abi.encode(amount, recipientAddress);\n        bytes32 dataHash = keccak256(abi.encode(resourceID, data));\n        _depositRecords[depositNonce][destinationChainID] = data;\n\n        address handler = _resourceIDToHandlerAddress[resourceID];\n        address tokenAddress = IDepositExecute(handler).getAddressFromResourceId(resourceID);\n        \n        emit Deposit(\n            _chainID,\n            destinationChainID,\n            resourceID,\n            depositNonce,\n            msg.sender,\n            recipientAddress,\n            tokenAddress,\n            amount,\n            dataHash\n        );\n    }\n\n    /**\n        @notice Executes a deposit proposal that is considered passed using a specified handler contract.\n        @notice Only callable by relayers when Bridge is not paused.\n        @param destinationChainID ID of chain where proposal is executed.\n        @param resourceID ResourceID to be used when making deposits.\n        @param depositNonce ID of deposited generated by origin Bridge contract.\n        @notice Proposal must not have executed before.\n        @notice Emits {ProposalEvent} event with status {Executed}.\n     */\n    function executeProposal(\n        bytes8 originChainID,\n        bytes8 destinationChainID,\n        uint64 depositNonce,\n        bytes32 resourceID,\n        address payable recipientAddress,\n        uint256 amount,\n        bytes calldata params\n    ) external onlyBackendSrv whenNotPaused {\n        bytes memory data = abi.encode(amount, recipientAddress);\n        bytes32 nonceAndID = keccak256(\n            abi.encode(depositNonce, originChainID, destinationChainID)\n        );\n        bytes32 dataHash = keccak256(abi.encode(resourceID, data));\n\n        require(\n            !_executedProposals[nonceAndID][dataHash],\n            \"proposal already executed\"\n        );\n        require(destinationChainID == _chainID, \"ChainID Incorrect\");\n\n        _executedProposals[nonceAndID][dataHash] = true;\n\n        if (resourceID == _nativeResourceID) {\n            recipientAddress.transfer(amount);\n        } else {\n            address handler = _resourceIDToHandlerAddress[resourceID];\n            require(handler != address(0), \"resourceID not mapped to handler\");\n\n            IDepositExecute depositHandler = IDepositExecute(handler);\n            depositHandler.executeProposal(\n                resourceID,\n                recipientAddress,\n                amount,\n                params\n            );\n        }\n\n        emit ProposalEvent(\n            originChainID,\n            destinationChainID,\n            recipientAddress,\n            amount,\n            depositNonce,\n            ProposalStatus.Executed,\n            resourceID,\n            dataHash\n        );\n    }\n\n    /**\n        @notice to be called if owner wants to collect fees\n        @dev can only be called by owner\n        @param amount will be trasnfered to owner if contract balace is higher or equal to amount\n    */\n    function adminCollectFees(address payable recipient, uint256 amount) external onlyOwner {\n        uint256 amountToTransfer = amount < address(this).balance\n            ? amount\n            : address(this).balance;\n        recipient.transfer(amountToTransfer);\n    }\n\n    /** \n        @notice to deposit native token to the contract\n        @dev to be called by admin\n    */\n    function depositFunds() external payable onlyOwner {}\n}\n"
    },
    "project:/contracts/interfaces/IBridge.sol": {
      "content": "pragma solidity 0.6.4;\n\n/**\n    @title Interface for Bridge contract.\n    @author ChainSafe Systems.\n */\ninterface IBridge {\n    /**\n        @notice Exposing getter for {_chainID} instead of forcing the use of call.\n        @return uint8 The {_chainID} that is currently set for the Bridge contract.\n     */\n    function _chainID() external returns (uint8);\n\n    function internalDeposit(bytes8 destinationChainID,bytes32 resourceID,uint256 amount,address recipientAddress) external;\n}"
    },
    "project:/contracts/interfaces/IDepositExecute.sol": {
      "content": "pragma solidity 0.6.4;\n\n/**\n    @title Interface for handler contracts that support deposits and deposit executions.\n    @author ChainSafe Systems.\n */\ninterface IDepositExecute {\n    /**\n        @notice It is intended that deposit are made using the Bridge contract.\n        @param destinationChainID Chain ID deposit is expected to be bridged to.\n        @param depositNonce This value is generated as an ID by the Bridge contract.\n        @param depositer Address of account making the deposit in the Bridge contract.\n     */\n    function deposit(\n        bytes32 resourceID,\n        bytes8 destinationChainID,\n        uint64 depositNonce,\n        address depositer,\n        address recipientAddress,\n        uint256 amount,\n        bytes calldata params\n    ) external returns (address);\n\n    /**\n        @notice It is intended that proposals are executed by the Bridge contract.\n     */\n    function executeProposal(bytes32 resourceID, address recipientAddress, uint256 amount, bytes calldata params) external;\n    function getAddressFromResourceId(bytes32 resourceID) external view returns(address);\n}\n"
    },
    "project:/contracts/interfaces/IERCHandler.sol": {
      "content": "pragma solidity 0.6.4;\n\n/**\n    @title Interface to be used with handlers that support ERC20s and ERC721s.\n */\ninterface IERCHandler {\n    /**\n        @notice Correlates {resourceID} with {contractAddress}.\n        @param resourceID ResourceID to be used when making deposits.\n        @param contractAddress Address of contract to be called when a deposit is made and a deposited is executed.\n     */\n    function setResource(bytes32 resourceID, address contractAddress) external;\n    /**\n        @notice Marks {contractAddress} as mintable/burnable.\n        @param contractAddress Address of contract to be used when making or executing deposits.\n     */\n    function setBurnable(address contractAddress) external;\n    /**\n        @notice Used to manually release funds from ERC safes.\n        @param tokenAddress Address of token contract to release.\n        @param recipient Address to release tokens to.\n        @param amountOrTokenID Either the amount of ERC20 tokens or the ERC721 token ID to release.\n     */\n    function withdraw(address tokenAddress, address recipient, uint256 amountOrTokenID) external;\n\n    /**\n        @notice Used to approve spending tokens.\n        @param resourceID ResourceID to be used for approval.\n        @param spender Spender address.\n        @param amountOrTokenID Either the amount of ERC20 tokens or the ERC721 token ID to approve.\n     */\n    function approve(bytes32 resourceID, address spender, uint256 amountOrTokenID) external;\n}\n"
    },
    "project:/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "project:/contracts/utils/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This is a stripped down version of Open zeppelin's Pausable contract.\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/EnumerableSet.sol\n *\n */\ncontract Pausable {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _whenNotPaused();\n        _;\n    }\n\n    function _whenNotPaused() private view {\n        require(!_paused, \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenPaused() {\n        _whenPaused();\n        _;\n    }\n\n    function _whenPaused() private view {\n        require(_paused, \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(msg.sender);\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(msg.sender);\n    }\n}"
    },
    "project:/contracts/utils/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * note that this is a stripped down version of open zeppelin's safemath\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/SafeMath.sol\n */\n\ncontract SafeMathContract {\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) public pure returns (uint256) {\n        return _sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function _sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n}"
    },
    "project:/contracts/utils/UpgradableOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract UpgradableOwnable is Context {\n    address private _owner;\n    bool public _isInitialised;\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n     function ownableInit(address owner) public {\n       require(!_isInitialised);\n        _owner = owner;\n        _isInitialised = true;\n        emit OwnershipTransferred(address(0), owner);\n     }\n\n     modifier isInitisalised() {\n       require(_isInitialised);\n       _;\n     }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"sender should be owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner)\n        public\n        virtual\n        onlyOwner\n    {\n        require(newOwner != address(0));\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    }
  },
  "settings": {
    "remappings": [],
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "evmVersion": "istanbul",
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    }
  }
}}