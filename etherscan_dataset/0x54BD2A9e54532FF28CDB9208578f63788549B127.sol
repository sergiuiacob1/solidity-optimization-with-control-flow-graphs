{{
  "language": "Solidity",
  "sources": {
    "wstETHChainlinkAdapter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.7.0;\n\nimport \"SafeInt256.sol\";\nimport \"ChainlinkAdapter.sol\";\nimport \"IwstETH.sol\";\n\ncontract wstETHChainlinkAdapter is ChainlinkAdapter {\n    using SafeInt256 for int256;\n\n    int256 public constant wstDecimals = 10**18;\n    IwstETH public immutable wstETH;\n\n    constructor (\n        AggregatorV2V3Interface baseToUSDOracle_,\n        AggregatorV2V3Interface quoteToUSDOracle_,\n        string memory description_,\n        IwstETH wstETH_\n    ) ChainlinkAdapter(baseToUSDOracle_, quoteToUSDOracle_, description_) {\n        wstETH = wstETH_;\n    }\n\n    /// @notice stEthPerToken gets the amount of stETH for a one wstETH\n    function _convertAnswer(int256 answer) internal override view returns (int256) {\n        return answer.mul(SafeInt256.toInt(wstETH.stEthPerToken())).div(wstDecimals);\n    }\n}\n"
    },
    "SafeInt256.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.7.0;\n\nimport \"Constants.sol\";\n\nlibrary SafeInt256 {\n    int256 private constant _INT256_MIN = type(int256).min;\n\n    /// @dev Returns the multiplication of two signed integers, reverting on\n    /// overflow.\n\n    /// Counterpart to Solidity's `*` operator.\n\n    /// Requirements:\n\n    /// - Multiplication cannot overflow.\n\n    function mul(int256 a, int256 b) internal pure returns (int256 c) {\n        c = a * b;\n        if (a == -1) require (b == 0 || c / b == a);\n        else require (a == 0 || c / a == b);\n    }\n\n    /// @dev Returns the integer division of two signed integers. Reverts on\n    /// division by zero. The result is rounded towards zero.\n\n    /// Counterpart to Solidity's `/` operator. Note: this function uses a\n    /// `revert` opcode (which leaves remaining gas untouched) while Solidity\n    /// uses an invalid opcode to revert (consuming all remaining gas).\n\n    /// Requirements:\n\n    /// - The divisor cannot be zero.\n\n    function div(int256 a, int256 b) internal pure returns (int256 c) {\n        require(!(b == -1 && a == _INT256_MIN)); // dev: int256 div overflow\n        // NOTE: solidity will automatically revert on divide by zero\n        c = a / b;\n    }\n\n    function sub(int256 x, int256 y) internal pure returns (int256 z) {\n        //  taken from uniswap v3\n        require((z = x - y) <= x == (y >= 0));\n    }\n\n    function add(int256 x, int256 y) internal pure returns (int256 z) {\n        require((z = x + y) >= x == (y >= 0));\n    }\n\n    function neg(int256 x) internal pure returns (int256 y) {\n        return mul(-1, x);\n    }\n\n    function abs(int256 x) internal pure returns (int256) {\n        if (x < 0) return neg(x);\n        else return x;\n    }\n\n    function subNoNeg(int256 x, int256 y) internal pure returns (int256 z) {\n        z = sub(x, y);\n        require(z >= 0); // dev: int256 sub to negative\n\n        return z;\n    }\n\n    /// @dev Calculates x * RATE_PRECISION / y while checking overflows\n    function divInRatePrecision(int256 x, int256 y) internal pure returns (int256) {\n        return div(mul(x, Constants.RATE_PRECISION), y);\n    }\n\n    /// @dev Calculates x * y / RATE_PRECISION while checking overflows\n    function mulInRatePrecision(int256 x, int256 y) internal pure returns (int256) {\n        return div(mul(x, y), Constants.RATE_PRECISION);\n    }\n\n    function toUint(int256 x) internal pure returns (uint256) {\n        require(x >= 0);\n        return uint256(x);\n    }\n\n    function toInt(uint256 x) internal pure returns (int256) {\n        require (x <= uint256(type(int256).max)); // dev: toInt overflow\n        return int256(x);\n    }\n\n    function max(int256 x, int256 y) internal pure returns (int256) {\n        return x > y ? x : y;\n    }\n\n    function min(int256 x, int256 y) internal pure returns (int256) {\n        return x < y ? x : y;\n    }\n}\n"
    },
    "Constants.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.7.0;\n\n/// @title All shared constants for the Notional system should be declared here.\nlibrary Constants {\n    uint8 internal constant CETH_DECIMAL_PLACES = 8;\n\n    // Token precision used for all internal balances, TokenHandler library ensures that we\n    // limit the dust amount caused by precision mismatches\n    int256 internal constant INTERNAL_TOKEN_PRECISION = 1e8;\n    uint256 internal constant INCENTIVE_ACCUMULATION_PRECISION = 1e18;\n\n    // ETH will be initialized as the first currency\n    uint256 internal constant ETH_CURRENCY_ID = 1;\n    uint8 internal constant ETH_DECIMAL_PLACES = 18;\n    int256 internal constant ETH_DECIMALS = 1e18;\n    // Used to prevent overflow when converting decimal places to decimal precision values via\n    // 10**decimalPlaces. This is a safe value for int256 and uint256 variables. We apply this\n    // constraint when storing decimal places in governance.\n    uint256 internal constant MAX_DECIMAL_PLACES = 36;\n\n    // Address of the reserve account\n    address internal constant RESERVE = address(0);\n\n    // Most significant bit\n    bytes32 internal constant MSB =\n        0x8000000000000000000000000000000000000000000000000000000000000000;\n\n    // Each bit set in this mask marks where an active market should be in the bitmap\n    // if the first bit refers to the reference time. Used to detect idiosyncratic\n    // fcash in the nToken accounts\n    bytes32 internal constant ACTIVE_MARKETS_MASK = (\n        MSB >> ( 90 - 1) | // 3 month\n        MSB >> (105 - 1) | // 6 month\n        MSB >> (135 - 1) | // 1 year\n        MSB >> (147 - 1) | // 2 year\n        MSB >> (183 - 1) | // 5 year\n        MSB >> (211 - 1) | // 10 year\n        MSB >> (251 - 1)   // 20 year\n    );\n\n    // Basis for percentages\n    int256 internal constant PERCENTAGE_DECIMALS = 100;\n    // Max number of traded markets, also used as the maximum number of assets in a portfolio array\n    uint256 internal constant MAX_TRADED_MARKET_INDEX = 7;\n    // Max number of fCash assets in a bitmap, this is based on the gas costs of calculating free collateral\n    // for a bitmap portfolio\n    uint256 internal constant MAX_BITMAP_ASSETS = 20;\n    uint256 internal constant FIVE_MINUTES = 300;\n\n    // Internal date representations, note we use a 6/30/360 week/month/year convention here\n    uint256 internal constant DAY = 86400;\n    // We use six day weeks to ensure that all time references divide evenly\n    uint256 internal constant WEEK = DAY * 6;\n    uint256 internal constant MONTH = WEEK * 5;\n    uint256 internal constant QUARTER = MONTH * 3;\n    uint256 internal constant YEAR = QUARTER * 4;\n    \n    // These constants are used in DateTime.sol\n    uint256 internal constant DAYS_IN_WEEK = 6;\n    uint256 internal constant DAYS_IN_MONTH = 30;\n    uint256 internal constant DAYS_IN_QUARTER = 90;\n\n    // Offsets for each time chunk denominated in days\n    uint256 internal constant MAX_DAY_OFFSET = 90;\n    uint256 internal constant MAX_WEEK_OFFSET = 360;\n    uint256 internal constant MAX_MONTH_OFFSET = 2160;\n    uint256 internal constant MAX_QUARTER_OFFSET = 7650;\n\n    // Offsets for each time chunk denominated in bits\n    uint256 internal constant WEEK_BIT_OFFSET = 90;\n    uint256 internal constant MONTH_BIT_OFFSET = 135;\n    uint256 internal constant QUARTER_BIT_OFFSET = 195;\n\n    // This is a constant that represents the time period that all rates are normalized by, 360 days\n    uint256 internal constant IMPLIED_RATE_TIME = 360 * DAY;\n    // Number of decimal places that rates are stored in, equals 100%\n    int256 internal constant RATE_PRECISION = 1e9;\n    // One basis point in RATE_PRECISION terms\n    uint256 internal constant BASIS_POINT = uint256(RATE_PRECISION / 10000);\n    // Used to when calculating the amount to deleverage of a market when minting nTokens\n    uint256 internal constant DELEVERAGE_BUFFER = 300 * BASIS_POINT;\n    // Used for scaling cash group factors\n    uint256 internal constant FIVE_BASIS_POINTS = 5 * BASIS_POINT;\n    // Used for residual purchase incentive and cash withholding buffer\n    uint256 internal constant TEN_BASIS_POINTS = 10 * BASIS_POINT;\n\n    // This is the ABDK64x64 representation of RATE_PRECISION\n    // RATE_PRECISION_64x64 = ABDKMath64x64.fromUint(RATE_PRECISION)\n    int128 internal constant RATE_PRECISION_64x64 = 0x3b9aca000000000000000000;\n    int128 internal constant LOG_RATE_PRECISION_64x64 = 382276781265598821176;\n    // Limit the market proportion so that borrowing cannot hit extremely high interest rates\n    int256 internal constant MAX_MARKET_PROPORTION = RATE_PRECISION * 99 / 100;\n\n    uint8 internal constant FCASH_ASSET_TYPE = 1;\n    // Liquidity token asset types are 1 + marketIndex (where marketIndex is 1-indexed)\n    uint8 internal constant MIN_LIQUIDITY_TOKEN_INDEX = 2;\n    uint8 internal constant MAX_LIQUIDITY_TOKEN_INDEX = 8;\n\n    // Used for converting bool to bytes1, solidity does not have a native conversion\n    // method for this\n    bytes1 internal constant BOOL_FALSE = 0x00;\n    bytes1 internal constant BOOL_TRUE = 0x01;\n\n    // Account context flags\n    bytes1 internal constant HAS_ASSET_DEBT = 0x01;\n    bytes1 internal constant HAS_CASH_DEBT = 0x02;\n    bytes2 internal constant ACTIVE_IN_PORTFOLIO = 0x8000;\n    bytes2 internal constant ACTIVE_IN_BALANCES = 0x4000;\n    bytes2 internal constant UNMASK_FLAGS = 0x3FFF;\n    uint16 internal constant MAX_CURRENCIES = uint16(UNMASK_FLAGS);\n\n    // Equal to 100% of all deposit amounts for nToken liquidity across fCash markets.\n    int256 internal constant DEPOSIT_PERCENT_BASIS = 1e8;\n\n    // nToken Parameters: there are offsets in the nTokenParameters bytes6 variable returned\n    // in nTokenHandler. Each constant represents a position in the byte array.\n    uint8 internal constant LIQUIDATION_HAIRCUT_PERCENTAGE = 0;\n    uint8 internal constant CASH_WITHHOLDING_BUFFER = 1;\n    uint8 internal constant RESIDUAL_PURCHASE_TIME_BUFFER = 2;\n    uint8 internal constant PV_HAIRCUT_PERCENTAGE = 3;\n    uint8 internal constant RESIDUAL_PURCHASE_INCENTIVE = 4;\n\n    // Liquidation parameters\n    // Default percentage of collateral that a liquidator is allowed to liquidate, will be higher if the account\n    // requires more collateral to be liquidated\n    int256 internal constant DEFAULT_LIQUIDATION_PORTION = 40;\n    // Percentage of local liquidity token cash claim delivered to the liquidator for liquidating liquidity tokens\n    int256 internal constant TOKEN_REPO_INCENTIVE_PERCENT = 30;\n\n    // Pause Router liquidation enabled states\n    bytes1 internal constant LOCAL_CURRENCY_ENABLED = 0x01;\n    bytes1 internal constant COLLATERAL_CURRENCY_ENABLED = 0x02;\n    bytes1 internal constant LOCAL_FCASH_ENABLED = 0x04;\n    bytes1 internal constant CROSS_CURRENCY_FCASH_ENABLED = 0x08;\n}\n"
    },
    "ChainlinkAdapter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.7.0;\n\nimport \"SafeInt256.sol\";\nimport \"AggregatorV2V3Interface.sol\";\n\ncontract ChainlinkAdapter is AggregatorV2V3Interface {\n    using SafeInt256 for int256;\n    uint8 public override constant decimals = 18;\n    uint256 public override constant version = 1;\n    int256 public constant rateDecimals = 10**18;\n\n    string public override description;\n    AggregatorV2V3Interface public immutable baseToUSDOracle;\n    int256 public immutable baseToUSDDecimals;\n    AggregatorV2V3Interface public immutable quoteToUSDOracle;\n    int256 public immutable quoteToUSDDecimals;\n\n    constructor (\n        AggregatorV2V3Interface baseToUSDOracle_,\n        AggregatorV2V3Interface quoteToUSDOracle_,\n        string memory description_\n    ) {\n        description = description_;\n        baseToUSDOracle = baseToUSDOracle_;\n        quoteToUSDOracle = quoteToUSDOracle_;\n        baseToUSDDecimals = int256(10**baseToUSDOracle_.decimals());\n        quoteToUSDDecimals = int256(10**quoteToUSDOracle_.decimals());\n    }\n\n    /// @notice Allow derived classes to do additional math before returning the answer\n    function _convertAnswer(int256 answer) internal virtual view returns (int256) {\n        return answer;\n    }\n\n    function _calculateBaseToQuote() internal view returns (\n        uint80 roundId,\n        int256 answer,\n        uint256 startedAt,\n        uint256 updatedAt,\n        uint80 answeredInRound\n    ) {\n        int256 baseToUSD;\n        (\n            roundId,\n            baseToUSD,\n            startedAt,\n            updatedAt,\n            answeredInRound\n        ) = baseToUSDOracle.latestRoundData();\n        require(baseToUSD > 0, \"Chainlink Rate Error\");\n        (\n            /* roundId */,\n            int256 quoteToUSD,\n            /* uint256 startedAt */,\n            /* updatedAt */,\n            /* answeredInRound */\n        ) = quoteToUSDOracle.latestRoundData();\n        require(quoteToUSD > 0, \"Chainlink Rate Error\");\n\n        // To convert from USDC/USD (base) and ETH/USD (quote) to USDC/ETH we do:\n        // (USDC/USD * quoteDecimals * 1e18) / (ETH/USD * baseDecimals)\n        answer = _convertAnswer(\n            baseToUSD\n            .mul(quoteToUSDDecimals)\n            .mul(rateDecimals)\n            .div(quoteToUSD)\n            .div(baseToUSDDecimals)\n        );\n    }\n\n    function latestRoundData() external view override returns (\n        uint80 roundId,\n        int256 answer,\n        uint256 startedAt,\n        uint256 updatedAt,\n        uint80 answeredInRound\n    ) {\n        return _calculateBaseToQuote();\n    }\n\n    function latestAnswer() external view override returns (int256 answer) {\n        (/* */, answer, /* */, /* */, /* */) = _calculateBaseToQuote();\n    }\n\n    function latestTimestamp() external view override returns (uint256 updatedAt) {\n        (/* */, /* */, /* */, updatedAt, /* */) = _calculateBaseToQuote();\n    }\n\n    function latestRound() external view override returns (uint256 roundId) {\n        (roundId, /* */, /* */, /* */, /* */) = _calculateBaseToQuote();\n    }\n\n    function getRoundData(uint80 _roundId) external view override returns (\n        uint80 roundId,\n        int256 answer,\n        uint256 startedAt,\n        uint256 updatedAt,\n        uint80 answeredInRound\n    ) {\n        revert();\n    }\n\n    function getAnswer(uint256 roundId) external view override returns (int256) { revert(); }\n    function getTimestamp(uint256 roundId) external view override returns (uint256) { revert(); }\n}\n"
    },
    "AggregatorV2V3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0;\n\nimport \"AggregatorInterface.sol\";\nimport \"AggregatorV3Interface.sol\";\n\ninterface AggregatorV2V3Interface is AggregatorInterface, AggregatorV3Interface\n{\n}"
    },
    "AggregatorInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0;\n\ninterface AggregatorInterface {\n  function latestAnswer() external view returns (int256);\n  function latestTimestamp() external view returns (uint256);\n  function latestRound() external view returns (uint256);\n  function getAnswer(uint256 roundId) external view returns (int256);\n  function getTimestamp(uint256 roundId) external view returns (uint256);\n\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\n}"
    },
    "AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0;\n\ninterface AggregatorV3Interface {\n\n  function decimals() external view returns (uint8);\n  function description() external view returns (string memory);\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n}"
    },
    "IwstETH.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.7.0;\n\nimport \"IERC20.sol\";\n\ninterface IwstETH is IERC20 {\n    function stEthPerToken() external view returns (uint256);\n    function wrap(uint256 _stETHAmount) external returns (uint256);\n    function unwrap(uint256 _wstETHAmount) external returns (uint256);\n}\n"
    },
    "IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    }
  },
  "settings": {
    "evmVersion": "istanbul",
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "libraries": {
      "wstETHChainlinkAdapter.sol": {}
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  }
}}