{{
  "language": "Solidity",
  "settings": {
    "evmVersion": "london",
    "libraries": {},
    "metadata": {
      "bytecodeHash": "ipfs",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "contracts/UnifarmNFTDescriptorUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: GNU GPLv3\n\npragma solidity =0.8.9;\npragma abicoder v2;\n\nimport {IUnifarmNFTDescriptorUpgradeable} from './interfaces/IUnifarmNFTDescriptorUpgradeable.sol';\nimport {IUnifarmCohort} from './interfaces/IUnifarmCohort.sol';\nimport {NFTDescriptor} from './library/NFTDescriptor.sol';\nimport {IERC20TokenMetadata} from './interfaces/IERC20TokenMetadata.sol';\nimport {CheckPointReward} from './library/CheckPointReward.sol';\nimport {Initializable} from './proxy/Initializable.sol';\nimport {CohortHelper} from './library/CohortHelper.sol';\nimport {ConvertHexStrings} from './library/ConvertHexStrings.sol';\n\ncontract UnifarmNFTDescriptorUpgradeable is Initializable, IUnifarmNFTDescriptorUpgradeable {\n    /// @notice registry contract address\n    address public registry;\n\n    /**\n     * @notice construct a descriptor contract\n     * @param registry_ registry address\n     */\n\n    function __UnifarmNFTDescriptorUpgradeable_init(address registry_) external initializer {\n        __UnifarmNFTDescriptorUpgradeable_init_unchained(registry_);\n    }\n\n    /**\n     * @dev internal function to set descriptor storage\n     * @param registry_ registry address\n     */\n\n    function __UnifarmNFTDescriptorUpgradeable_init_unchained(address registry_) internal {\n        registry = registry_;\n    }\n\n    /**\n     * @dev get token ticker\n     * @param farmToken farm token address\n     * @return token ticker\n     */\n\n    function getTokenTicker(address farmToken) internal view returns (string memory) {\n        return IERC20TokenMetadata(farmToken).symbol();\n    }\n\n    /**\n     * @dev get Cohort details\n     * @param cohortId cohort address\n     * @param uStartBlock user start block\n     * @param uEndBlock user End Block\n     * @return cohortName cohort version\n     * @return confirmedEpochs confirmed epochs\n     */\n\n    function getCohortDetails(\n        address cohortId,\n        uint256 uStartBlock,\n        uint256 uEndBlock\n    ) internal view returns (string memory cohortName, uint256 confirmedEpochs) {\n        (string memory cohortVersion, , uint256 cEndBlock, uint256 epochBlocks, , , ) = CohortHelper.getCohort(registry, cohortId);\n        cohortName = cohortVersion;\n        confirmedEpochs = CheckPointReward.getCurrentCheckpoint(uStartBlock, (uEndBlock > 0 ? uEndBlock : cEndBlock), epochBlocks);\n    }\n\n    /**\n     * @inheritdoc IUnifarmNFTDescriptorUpgradeable\n     */\n\n    function generateTokenURI(address cohortId, uint256 tokenId) public view override returns (string memory) {\n        (uint32 fid, , uint256 stakedAmount, uint256 startBlock, uint256 sEndBlock, , , bool isBooster) = IUnifarmCohort(cohortId).viewStakingDetails(\n            tokenId\n        );\n\n        (string memory cohortVersion, uint256 confirmedEpochs) = getCohortDetails(cohortId, startBlock, sEndBlock);\n\n        (, address farmToken, , , , , ) = CohortHelper.getCohortToken(registry, cohortId, fid);\n\n        return\n            NFTDescriptor.createNftTokenURI(\n                NFTDescriptor.DescriptionParam({\n                    fid: fid,\n                    cohortName: cohortVersion,\n                    stakeTokenTicker: getTokenTicker(farmToken),\n                    cohortAddress: ConvertHexStrings.addressToString(cohortId),\n                    stakedBlock: startBlock,\n                    tokenId: tokenId,\n                    stakedAmount: stakedAmount,\n                    confirmedEpochs: confirmedEpochs,\n                    isBoosterAvailable: isBooster\n                })\n            );\n    }\n\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/abstract/CohortFactory.sol": {
      "content": "// SPDX-License-Identifier: GNU GPLv3\n\npragma solidity =0.8.9;\n\nabstract contract CohortFactory {\n    /**\n     * @notice factory owner\n     * @return owner\n     */\n    function owner() public view virtual returns (address);\n\n    /**\n     * @notice derive storage contracts\n     * @return registry contract address\n     * @return nftManager contract address\n     * @return rewardRegistry contract address\n     */\n\n    function getStorageContracts()\n        public\n        view\n        virtual\n        returns (\n            address registry,\n            address nftManager,\n            address rewardRegistry\n        );\n}\n"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: GNU GPLv3\n\n// OpenZeppelin Contracts v4.3.2 (token/ERC20/IERC20.sol)\n\npragma solidity =0.8.9;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\n\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/interfaces/IERC20TokenMetadata.sol": {
      "content": "// SPDX-License-Identifier: GNU GPLv3\npragma solidity =0.8.9;\n\ninterface IERC20TokenMetadata {\n    /**\n     * @dev returns name of the token\n     * @return name - token name\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev returns symbol of the token\n     * @return symbol - token symbol\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev returns decimals of the token\n     * @return decimals - token decimals\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/interfaces/IUnifarmCohort.sol": {
      "content": "// SPDX-License-Identifier: GNU GPLv3\n\npragma solidity =0.8.9;\n\n/// @title IUnifarmCohort Interface\n/// @author UNIFARM\n/// @notice unifarm cohort external functions\n/// @dev All function calls are currently implemented without any side effects\n\ninterface IUnifarmCohort {\n    /**\n    @notice stake handler\n    @dev function called by only nft manager\n    @param fid farm id where you want to stake\n    @param tokenId NFT token Id\n    @param account user wallet Address\n    @param referralAddress referral address for this stake\n   */\n\n    function stake(\n        uint32 fid,\n        uint256 tokenId,\n        address account,\n        address referralAddress\n    ) external;\n\n    /**\n     * @notice unStake handler\n     * @dev called by nft manager only\n     * @param user user wallet Address\n     * @param tokenId NFT Token Id\n     * @param flag 1, if owner is caller\n     */\n\n    function unStake(\n        address user,\n        uint256 tokenId,\n        uint256 flag\n    ) external;\n\n    /**\n     * @notice allow user to collect rewards before cohort end\n     * @dev called by NFT manager\n     * @param user user address\n     * @param tokenId NFT Token Id\n     */\n\n    function collectPrematureRewards(address user, uint256 tokenId) external;\n\n    /**\n     * @notice purchase a booster pack for particular token Id\n     * @dev called by NFT manager or owner\n     * @param user user wallet address who is willing to buy booster\n     * @param bpid booster pack id to purchase booster\n     * @param tokenId NFT token Id which booster to take\n     */\n\n    function buyBooster(\n        address user,\n        uint256 bpid,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @notice set portion amount for particular tokenId\n     * @dev called by only owner access\n     * @param tokenId NFT token Id\n     * @param stakedAmount new staked amount\n     */\n\n    function setPortionAmount(uint256 tokenId, uint256 stakedAmount) external;\n\n    /**\n     * @notice disable booster for particular tokenId\n     * @dev called by only owner access.\n     * @param tokenId NFT token Id\n     */\n\n    function disableBooster(uint256 tokenId) external;\n\n    /**\n     * @dev rescue Ethereum\n     * @param withdrawableAddress to address\n     * @param amount to withdraw\n     * @return Transaction status\n     */\n\n    function safeWithdrawEth(address withdrawableAddress, uint256 amount) external returns (bool);\n\n    /**\n     * @dev rescue all available tokens in a cohort\n     * @param tokens list of tokens\n     * @param amounts list of amounts to withdraw respectively\n     */\n\n    function safeWithdrawAll(\n        address withdrawableAddress,\n        address[] memory tokens,\n        uint256[] memory amounts\n    ) external;\n\n    /**\n     * @notice obtain staking details\n     * @param tokenId - NFT Token id\n     * @return fid the cohort farm id\n     * @return nftTokenId the NFT token id\n     * @return stakedAmount denotes staked amount\n     * @return startBlock start block of particular user stake\n     * @return endBlock end block of particular user stake\n     * @return originalOwner wallet address\n     * @return referralAddress the referral address of stake\n     * @return isBooster denotes booster availability\n     */\n\n    function viewStakingDetails(uint256 tokenId)\n        external\n        view\n        returns (\n            uint32 fid,\n            uint256 nftTokenId,\n            uint256 stakedAmount,\n            uint256 startBlock,\n            uint256 endBlock,\n            address originalOwner,\n            address referralAddress,\n            bool isBooster\n        );\n\n    /**\n     * @notice emit on each booster purchase\n     * @param nftTokenId NFT Token Id\n     * @param user user wallet address who bought the booster\n     * @param bpid booster pack id\n     */\n\n    event BoosterBuyHistory(uint256 indexed nftTokenId, address indexed user, uint256 bpid);\n\n    /**\n     * @notice emit on each claim\n     * @param fid farm id.\n     * @param tokenId NFT Token Id\n     * @param userAddress NFT owner wallet address\n     * @param referralAddress referral wallet address\n     * @param rValue Aggregated R Value\n     */\n\n    event Claim(uint32 fid, uint256 indexed tokenId, address indexed userAddress, address indexed referralAddress, uint256 rValue);\n\n    /**\n     * @notice emit on each stake\n     * @dev helps to derive referrals of unifarm cohort\n     * @param tokenId NFT Token Id\n     * @param referralAddress referral Wallet Address\n     * @param stakedAmount user staked amount\n     * @param fid farm id\n     */\n\n    event ReferedBy(uint256 indexed tokenId, address indexed referralAddress, uint256 stakedAmount, uint32 fid);\n}\n"
    },
    "contracts/interfaces/IUnifarmCohortRegistryUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: GNU GPLv3\n\npragma solidity =0.8.9;\npragma abicoder v2;\n\n/// @title IUnifarmCohortRegistryUpgradeable Interface\n/// @author UNIFARM\n/// @notice All External functions of Unifarm Cohort Registry.\n\ninterface IUnifarmCohortRegistryUpgradeable {\n    /**\n     * @notice set tokenMetaData for a particular cohort farm\n     * @dev only called by owner access or multicall\n     * @param cohortId cohort address\n     * @param fid_ farm id\n     * @param farmToken_ farm token address\n     * @param userMinStake_ user minimum stake\n     * @param userMaxStake_ user maximum stake\n     * @param totalStakeLimit_ total stake limit\n     * @param decimals_ token decimals\n     * @param skip_ it can be skip or not during unstake\n     */\n\n    function setTokenMetaData(\n        address cohortId,\n        uint32 fid_,\n        address farmToken_,\n        uint256 userMinStake_,\n        uint256 userMaxStake_,\n        uint256 totalStakeLimit_,\n        uint8 decimals_,\n        bool skip_\n    ) external;\n\n    /**\n     * @notice a function to set particular cohort details\n     * @dev only called by owner access or multicall\n     * @param cohortId cohort address\n     * @param cohortVersion_ cohort version\n     * @param startBlock_ start block of a cohort\n     * @param endBlock_ end block of a cohort\n     * @param epochBlocks_ epochBlocks of a cohort\n     * @param hasLiquidityMining_ true if lp tokens can be stake here\n     * @param hasContainsWrappedToken_ true if wTokens exist in rewards\n     * @param hasCohortLockinAvaliable_ cohort lockin flag\n     */\n\n    function setCohortDetails(\n        address cohortId,\n        string memory cohortVersion_,\n        uint256 startBlock_,\n        uint256 endBlock_,\n        uint256 epochBlocks_,\n        bool hasLiquidityMining_,\n        bool hasContainsWrappedToken_,\n        bool hasCohortLockinAvaliable_\n    ) external;\n\n    /**\n     * @notice to add a booster pack in a particular cohort\n     * @dev only called by owner access or multicall\n     * @param cohortId_ cohort address\n     * @param paymentToken_ payment token address\n     * @param boosterVault_ booster vault address\n     * @param bpid_ booster pack Id\n     * @param boosterPackAmount_ booster pack amount\n     */\n\n    function addBoosterPackage(\n        address cohortId_,\n        address paymentToken_,\n        address boosterVault_,\n        uint256 bpid_,\n        uint256 boosterPackAmount_\n    ) external;\n\n    /**\n     * @notice update multicall contract address\n     * @dev only called by owner access\n     * @param newMultiCallAddress new multicall address\n     */\n\n    function updateMulticall(address newMultiCallAddress) external;\n\n    /**\n     * @notice lock particular cohort contract\n     * @dev only called by owner access or multicall\n     * @param cohortId cohort contract address\n     * @param status true for lock vice-versa false for unlock\n     */\n\n    function setWholeCohortLock(address cohortId, bool status) external;\n\n    /**\n     * @notice lock particular cohort contract action. (`STAKE` | `UNSTAKE`)\n     * @dev only called by owner access or multicall\n     * @param cohortId cohort address\n     * @param actionToLock magic value STAKE/UNSTAKE\n     * @param status true for lock vice-versa false for unlock\n     */\n\n    function setCohortLockStatus(\n        address cohortId,\n        bytes4 actionToLock,\n        bool status\n    ) external;\n\n    /**\n     * @notice lock the particular farm action (`STAKE` | `UNSTAKE`) in a cohort\n     * @param cohortSalt mixture of cohortId and tokenId\n     * @param actionToLock magic value STAKE/UNSTAKE\n     * @param status true for lock vice-versa false for unlock\n     */\n\n    function setCohortTokenLockStatus(\n        bytes32 cohortSalt,\n        bytes4 actionToLock,\n        bool status\n    ) external;\n\n    /**\n     * @notice validate cohort stake locking status\n     * @param cohortId cohort address\n     * @param farmId farm Id\n     */\n\n    function validateStakeLock(address cohortId, uint32 farmId) external view;\n\n    /**\n     * @notice validate cohort unstake locking status\n     * @param cohortId cohort address\n     * @param farmId farm Id\n     */\n\n    function validateUnStakeLock(address cohortId, uint32 farmId) external view;\n\n    /**\n     * @notice get farm token details in a specific cohort\n     * @param cohortId particular cohort address\n     * @param farmId farmId of particular cohort\n     * @return fid farm Id\n     * @return farmToken farm Token Address\n     * @return userMinStake amount that user can minimum stake\n     * @return userMaxStake amount that user can maximum stake\n     * @return totalStakeLimit total stake limit for the specific farm\n     * @return decimals farm token decimals\n     * @return skip it can be skip or not during unstake\n     */\n\n    function getCohortToken(address cohortId, uint32 farmId)\n        external\n        view\n        returns (\n            uint32 fid,\n            address farmToken,\n            uint256 userMinStake,\n            uint256 userMaxStake,\n            uint256 totalStakeLimit,\n            uint8 decimals,\n            bool skip\n        );\n\n    /**\n     * @notice get specific cohort details\n     * @param cohortId cohort address\n     * @return cohortVersion specific cohort version\n     * @return startBlock start block of a unifarm cohort\n     * @return endBlock end block of a unifarm cohort\n     * @return epochBlocks epoch blocks in particular cohort\n     * @return hasLiquidityMining indicator for liquidity mining\n     * @return hasContainsWrappedToken true if contains wrapped token in cohort rewards\n     * @return hasCohortLockinAvaliable denotes cohort lockin\n     */\n\n    function getCohort(address cohortId)\n        external\n        view\n        returns (\n            string memory cohortVersion,\n            uint256 startBlock,\n            uint256 endBlock,\n            uint256 epochBlocks,\n            bool hasLiquidityMining,\n            bool hasContainsWrappedToken,\n            bool hasCohortLockinAvaliable\n        );\n\n    /**\n     * @notice get booster pack details for a specific cohort\n     * @param cohortId cohort address\n     * @param bpid booster pack Id\n     * @return cohortId_ cohort address\n     * @return paymentToken_ payment token address\n     * @return boosterVault booster vault address\n     * @return boosterPackAmount booster pack amount\n     */\n\n    function getBoosterPackDetails(address cohortId, uint256 bpid)\n        external\n        view\n        returns (\n            address cohortId_,\n            address paymentToken_,\n            address boosterVault,\n            uint256 boosterPackAmount\n        );\n\n    /**\n     * @notice emit on each farm token update\n     * @param cohortId cohort address\n     * @param farmToken farm token address\n     * @param fid farm Id\n     * @param userMinStake amount that user can minimum stake\n     * @param userMaxStake amount that user can maximum stake\n     * @param totalStakeLimit total stake limit for the specific farm\n     * @param decimals farm token decimals\n     * @param skip it can be skip or not during unstake\n     */\n\n    event TokenMetaDataDetails(\n        address indexed cohortId,\n        address indexed farmToken,\n        uint32 indexed fid,\n        uint256 userMinStake,\n        uint256 userMaxStake,\n        uint256 totalStakeLimit,\n        uint8 decimals,\n        bool skip\n    );\n\n    /**\n     * @notice emit on each update of cohort details\n     * @param cohortId cohort address\n     * @param cohortVersion specific cohort version\n     * @param startBlock start block of a unifarm cohort\n     * @param endBlock end block of a unifarm cohort\n     * @param epochBlocks epoch blocks in particular unifarm cohort\n     * @param hasLiquidityMining indicator for liquidity mining\n     * @param hasContainsWrappedToken true if contains wrapped token in cohort rewards\n     * @param hasCohortLockinAvaliable denotes cohort lockin\n     */\n\n    event AddedCohortDetails(\n        address indexed cohortId,\n        string indexed cohortVersion,\n        uint256 startBlock,\n        uint256 endBlock,\n        uint256 epochBlocks,\n        bool indexed hasLiquidityMining,\n        bool hasContainsWrappedToken,\n        bool hasCohortLockinAvaliable\n    );\n\n    /**\n     * @notice emit on update of each booster pacakge\n     * @param cohortId the cohort address\n     * @param bpid booster pack id\n     * @param paymentToken the payment token address\n     * @param boosterPackAmount the booster pack amount\n     */\n\n    event BoosterDetails(address indexed cohortId, uint256 indexed bpid, address paymentToken, uint256 boosterPackAmount);\n}\n"
    },
    "contracts/interfaces/IUnifarmNFTDescriptorUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: GNU GPLv3\n\npragma solidity =0.8.9;\npragma abicoder v2;\n\n/// @title IUnifarmNFTDescriptorUpgradeable Interface\n/// @author UNIFARM\n/// @notice All External functions of Unifarm NFT Manager Descriptor\n\ninterface IUnifarmNFTDescriptorUpgradeable {\n    /**\n     * @notice construct the Token Metadata\n     * @param cohortId cohort address\n     * @param tokenId NFT Token Id\n     * @return base64 encoded Token Metadata\n     */\n    function generateTokenURI(address cohortId, uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "contracts/interfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: GNU GPLv3\n\npragma solidity =0.8.9;\n\ninterface IWETH {\n    /**\n     * @dev deposit eth to the contract\n     */\n\n    function deposit() external payable;\n\n    /**\n     * @dev transfer allows to transfer to a wallet or contract address\n     * @param to recipient address\n     * @param value amount to be transfered\n     * @return Transfer status.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev allow to withdraw weth from contract\n     */\n\n    function withdraw(uint256) external;\n}\n"
    },
    "contracts/library/Base64.sol": {
      "content": "// SPDX-License-Identifier: GNU GPLv3\n\npragma solidity =0.8.9;\n\n/// @title Base64\n/// @author Brecht Devos - <brecht@loopring.org>\n/// @notice Provides functions for encoding/decoding base64\n// solhint-disable\nlibrary Base64 {\n    string internal constant TABLE_ENCODE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n    bytes internal constant TABLE_DECODE =\n        hex'0000000000000000000000000000000000000000000000000000000000000000'\n        hex'00000000000000000000003e0000003f3435363738393a3b3c3d000000000000'\n        hex'00000102030405060708090a0b0c0d0e0f101112131415161718190000000000'\n        hex'001a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132330000000000';\n\n    function encode(bytes memory data) internal pure returns (string memory) {\n        if (data.length == 0) return '';\n\n        // load the table into memory\n        string memory table = TABLE_ENCODE;\n\n        // multiply by 4/3 rounded up\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\n\n        // add some extra buffer at the end required for the writing\n        string memory result = new string(encodedLen + 32);\n\n        assembly {\n            // set the actual output length\n            mstore(result, encodedLen)\n\n            // prepare the lookup table\n            let tablePtr := add(table, 1)\n\n            // input ptr\n            let dataPtr := data\n            let endPtr := add(dataPtr, mload(data))\n\n            // result ptr, jump over length\n            let resultPtr := add(result, 32)\n\n            // run over the input, 3 bytes at a time\n            for {\n\n            } lt(dataPtr, endPtr) {\n\n            } {\n                // read 3 bytes\n                dataPtr := add(dataPtr, 3)\n                let input := mload(dataPtr)\n\n                // write 4 characters\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))\n                resultPtr := add(resultPtr, 1)\n            }\n\n            // padding with '='\n            switch mod(mload(data), 3)\n            case 1 {\n                mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\n            }\n            case 2 {\n                mstore(sub(resultPtr, 1), shl(248, 0x3d))\n            }\n        }\n\n        return result;\n    }\n\n    function decode(string memory _data) internal pure returns (bytes memory) {\n        bytes memory data = bytes(_data);\n\n        if (data.length == 0) return new bytes(0);\n        require(data.length % 4 == 0, 'IBDI');\n\n        // load the table into memory\n        bytes memory table = TABLE_DECODE;\n\n        // every 4 characters represent 3 bytes\n        uint256 decodedLen = (data.length / 4) * 3;\n\n        // add some extra buffer at the end required for the writing\n        bytes memory result = new bytes(decodedLen + 32);\n\n        assembly {\n            // padding with '='\n            let lastBytes := mload(add(data, mload(data)))\n            if eq(and(lastBytes, 0xFF), 0x3d) {\n                decodedLen := sub(decodedLen, 1)\n                if eq(and(lastBytes, 0xFFFF), 0x3d3d) {\n                    decodedLen := sub(decodedLen, 1)\n                }\n            }\n\n            // set the actual output length\n            mstore(result, decodedLen)\n\n            // prepare the lookup table\n            let tablePtr := add(table, 1)\n\n            // input ptr\n            let dataPtr := data\n            let endPtr := add(dataPtr, mload(data))\n\n            // result ptr, jump over length\n            let resultPtr := add(result, 32)\n\n            // run over the input, 4 characters at a time\n            for {\n\n            } lt(dataPtr, endPtr) {\n\n            } {\n                // read 4 characters\n                dataPtr := add(dataPtr, 4)\n                let input := mload(dataPtr)\n\n                // write 3 bytes\n                let output := add(\n                    add(\n                        shl(18, and(mload(add(tablePtr, and(shr(24, input), 0xFF))), 0xFF)),\n                        shl(12, and(mload(add(tablePtr, and(shr(16, input), 0xFF))), 0xFF))\n                    ),\n                    add(shl(6, and(mload(add(tablePtr, and(shr(8, input), 0xFF))), 0xFF)), and(mload(add(tablePtr, and(input, 0xFF))), 0xFF))\n                )\n                mstore(resultPtr, shl(232, output))\n                resultPtr := add(resultPtr, 3)\n            }\n        }\n\n        return result;\n    }\n}\n"
    },
    "contracts/library/CheckPointReward.sol": {
      "content": "// SPDX-License-Identifier: GNU GPLv3\n\npragma solidity =0.8.9;\n\n/// @title CheckPointReward library\n/// @author UNIFARM\n/// @notice help to do a calculation of various checkpoints.\n/// @dev all the functions are internally used in the protocol.\n\nlibrary CheckPointReward {\n    /**\n     * @dev help to find block difference\n     * @param from from the blockNumber\n     * @param to till the blockNumber\n     * @return the blockDifference\n     */\n\n    function getBlockDifference(uint256 from, uint256 to) internal pure returns (uint256) {\n        return to - from;\n    }\n\n    /**\n     * @dev calculate number of checkpoint\n     * @param from from blockNumber\n     * @param to till blockNumber\n     * @param epochBlocks epoch blocks length\n     * @return checkpoint number of checkpoint\n     */\n\n    function getCheckpoint(\n        uint256 from,\n        uint256 to,\n        uint256 epochBlocks\n    ) internal pure returns (uint256) {\n        uint256 blockDifference = getBlockDifference(from, to);\n        return uint256(blockDifference / epochBlocks);\n    }\n\n    /**\n     * @dev derive current check point in unifarm cohort\n     * @dev it will be maximum to unifarm cohort endBlock\n     * @param startBlock start block of a unifarm cohort\n     * @param endBlock end block of a unifarm cohort\n     * @param epochBlocks number of blocks in one epoch\n     * @return checkpoint the current checkpoint in unifarm cohort\n     */\n\n    function getCurrentCheckpoint(\n        uint256 startBlock,\n        uint256 endBlock,\n        uint256 epochBlocks\n    ) internal view returns (uint256 checkpoint) {\n        uint256 yfEndBlock = block.number;\n        if (yfEndBlock > endBlock) {\n            yfEndBlock = endBlock;\n        }\n        checkpoint = getCheckpoint(startBlock, yfEndBlock, epochBlocks);\n    }\n\n    /**\n     * @dev derive start check point of user staking\n     * @param startBlock start block\n     * @param userStakedBlock block on user staked\n     * @param epochBlocks number of block in epoch\n     * @return checkpoint the start checkpoint of a user\n     */\n\n    function getStartCheckpoint(\n        uint256 startBlock,\n        uint256 userStakedBlock,\n        uint256 epochBlocks\n    ) internal pure returns (uint256 checkpoint) {\n        checkpoint = getCheckpoint(startBlock, userStakedBlock, epochBlocks);\n    }\n}\n"
    },
    "contracts/library/CohortHelper.sol": {
      "content": "// SPDX-License-Identifier: GNU GPLv3\n\npragma solidity =0.8.9;\n\nimport {CohortFactory} from '../abstract/CohortFactory.sol';\nimport {IERC20} from '../interfaces/IERC20.sol';\nimport {IUnifarmCohortRegistryUpgradeable} from '../interfaces/IUnifarmCohortRegistryUpgradeable.sol';\nimport {IWETH} from '../interfaces/IWETH.sol';\n\n/// @title CohortHelper library\n/// @author UNIFARM\n/// @notice we have various util functions.which is used in protocol directly\n/// @dev all the functions are internally used in the protocol.\n\nlibrary CohortHelper {\n    /**\n     * @dev getBlockNumber obtain current block from the chain.\n     * @return current block number\n     */\n\n    function getBlockNumber() internal view returns (uint256) {\n        return block.number;\n    }\n\n    /**\n     * @dev get current owner of the factory contract.\n     * @param factory factory contract address.\n     * @return factory owner address\n     */\n\n    function owner(address factory) internal view returns (address) {\n        return CohortFactory(factory).owner();\n    }\n\n    /**\n     * @dev validating the sender\n     * @param factory factory contract address\n     * @return registry registry contract address\n     * @return nftManager nft Manager contract address\n     * @return rewardRegistry reward registry contract address\n     */\n\n    function verifyCaller(address factory)\n        internal\n        view\n        returns (\n            address registry,\n            address nftManager,\n            address rewardRegistry\n        )\n    {\n        (registry, nftManager, rewardRegistry) = getStorageContracts(factory);\n        require(msg.sender == nftManager, 'ONM');\n    }\n\n    /**\n     * @dev get cohort details\n     * @param registry registry contract address\n     * @param cohortId cohort contract address\n     * @return cohortVersion specfic cohort version.\n     * @return startBlock start block of a cohort.\n     * @return endBlock end block of a cohort.\n     * @return epochBlocks epoch blocks in particular cohort.\n     * @return hasLiquidityMining indicator for liquidity mining.\n     * @return hasContainsWrappedToken true if contains wrapped token in cohort rewards.\n     * @return hasCohortLockinAvaliable denotes cohort lockin.\n     */\n\n    function getCohort(address registry, address cohortId)\n        internal\n        view\n        returns (\n            string memory cohortVersion,\n            uint256 startBlock,\n            uint256 endBlock,\n            uint256 epochBlocks,\n            bool hasLiquidityMining,\n            bool hasContainsWrappedToken,\n            bool hasCohortLockinAvaliable\n        )\n    {\n        (\n            cohortVersion,\n            startBlock,\n            endBlock,\n            epochBlocks,\n            hasLiquidityMining,\n            hasContainsWrappedToken,\n            hasCohortLockinAvaliable\n        ) = IUnifarmCohortRegistryUpgradeable(registry).getCohort(cohortId);\n    }\n\n    /**\n     * @dev obtain particular cohort farm token details\n     * @param registry registry contract address\n     * @param cohortId cohort contract address\n     * @param farmId farm Id\n     * @return fid farm Id\n     * @return farmToken farm token Address\n     * @return userMinStake amount that user can minimum stake\n     * @return userMaxStake amount that user can maximum stake\n     * @return totalStakeLimit total stake limit for the specfic farm\n     * @return decimals farm token decimals\n     * @return skip it can be skip or not during unstake\n     */\n\n    function getCohortToken(\n        address registry,\n        address cohortId,\n        uint32 farmId\n    )\n        internal\n        view\n        returns (\n            uint32 fid,\n            address farmToken,\n            uint256 userMinStake,\n            uint256 userMaxStake,\n            uint256 totalStakeLimit,\n            uint8 decimals,\n            bool skip\n        )\n    {\n        (fid, farmToken, userMinStake, userMaxStake, totalStakeLimit, decimals, skip) = IUnifarmCohortRegistryUpgradeable(registry).getCohortToken(\n            cohortId,\n            farmId\n        );\n    }\n\n    /**\n     * @dev derive booster pack details available for a specfic cohort.\n     * @param registry registry contract address\n     * @param cohortId cohort contract Address\n     * @param bpid booster pack id.\n     * @return cohortId_ cohort address.\n     * @return paymentToken_ payment token address.\n     * @return boosterVault the booster vault address.\n     * @return boosterPackAmount the booster pack amount.\n     */\n\n    function getBoosterPackDetails(\n        address registry,\n        address cohortId,\n        uint256 bpid\n    )\n        internal\n        view\n        returns (\n            address cohortId_,\n            address paymentToken_,\n            address boosterVault,\n            uint256 boosterPackAmount\n        )\n    {\n        (cohortId_, paymentToken_, boosterVault, boosterPackAmount) = IUnifarmCohortRegistryUpgradeable(registry).getBoosterPackDetails(\n            cohortId,\n            bpid\n        );\n    }\n\n    /**\n     * @dev calculate exact balance of a particular cohort.\n     * @param token token address\n     * @param totalStaking total staking of a token\n     * @return cohortBalance current cohort balance\n     */\n\n    function getCohortBalance(address token, uint256 totalStaking) internal view returns (uint256 cohortBalance) {\n        uint256 contractBalance = IERC20(token).balanceOf(address(this));\n        cohortBalance = contractBalance - totalStaking;\n    }\n\n    /**\n     * @dev get all storage contracts from factory contract.\n     * @param factory factory contract address\n     * @return registry registry contract address\n     * @return nftManager nftManger contract address\n     * @return rewardRegistry reward registry address\n     */\n\n    function getStorageContracts(address factory)\n        internal\n        view\n        returns (\n            address registry,\n            address nftManager,\n            address rewardRegistry\n        )\n    {\n        (registry, nftManager, rewardRegistry) = CohortFactory(factory).getStorageContracts();\n    }\n\n    /**\n     * @dev handle deposit WETH\n     * @param weth WETH address\n     * @param amount deposit amount\n     */\n\n    function depositWETH(address weth, uint256 amount) internal {\n        IWETH(weth).deposit{value: amount}();\n    }\n\n    /**\n     * @dev validate stake lock status\n     * @param registry registry address\n     * @param cohortId cohort address\n     * @param farmId farm Id\n     */\n\n    function validateStakeLock(\n        address registry,\n        address cohortId,\n        uint32 farmId\n    ) internal view {\n        IUnifarmCohortRegistryUpgradeable(registry).validateStakeLock(cohortId, farmId);\n    }\n\n    /**\n     * @dev validate unstake lock status\n     * @param registry registry address\n     * @param cohortId cohort address\n     * @param farmId farm Id\n     */\n\n    function validateUnStakeLock(\n        address registry,\n        address cohortId,\n        uint32 farmId\n    ) internal view {\n        IUnifarmCohortRegistryUpgradeable(registry).validateUnStakeLock(cohortId, farmId);\n    }\n}\n"
    },
    "contracts/library/ConvertHexStrings.sol": {
      "content": "// SPDX-License-Identifier: GNU GPLv3\n\npragma solidity =0.8.9;\n\nlibrary ConvertHexStrings {\n    /**\n     * @dev Convert address to string\n     * @param account - account hex address\n     * @return string - hex string\n     */\n    function addressToString(address account) internal pure returns (string memory) {\n        return toString(abi.encodePacked(account));\n    }\n\n    /**\n     * @dev convert bytes data to string\n     * @param data - data is type of bytes\n     * @return string - string of alphabet\n     */\n\n    function toString(bytes memory data) internal pure returns (string memory) {\n        bytes memory alphabet = '0123456789abcdef';\n\n        bytes memory str = new bytes(2 + data.length * 2);\n        uint256 dataLength = data.length;\n        str[0] = '0';\n        str[1] = 'x';\n        for (uint256 i = 0; i < dataLength; i++) {\n            str[2 + i * 2] = alphabet[uint256(uint8(data[i] >> 4))];\n            str[3 + i * 2] = alphabet[uint256(uint8(data[i] & 0x0f))];\n        }\n        return string(str);\n    }\n}\n"
    },
    "contracts/library/NFTDescriptor.sol": {
      "content": "// SPDX-License-Identifier: GNU GPLv3\n\npragma solidity =0.8.9;\n\nimport {StringsUpgradeable} from '@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol';\nimport {Base64} from './Base64.sol';\n\n/// @title NFTDescriptor library\n/// @author UNIFARM\n/// @notice create token metadata & onchain SVG\n\nlibrary NFTDescriptor {\n    /// @notice for converting uint256 to string\n    using StringsUpgradeable for uint256;\n\n    /// @notice NFT Description Parameters\n    struct DescriptionParam {\n        // farm id\n        uint32 fid;\n        // cohort version\n        string cohortName;\n        // stake token ticker\n        string stakeTokenTicker;\n        // cohort address\n        string cohortAddress;\n        // owner staked  block\n        uint256 stakedBlock;\n        // nft token id\n        uint256 tokenId;\n        // owner stakedAmount\n        uint256 stakedAmount;\n        // owner confirmed epochs\n        uint256 confirmedEpochs;\n        // denotes booster availablity\n        bool isBoosterAvailable;\n    }\n\n    /**\n     * @dev construct the NFT name\n     * @param cohortName cohort name\n     * @param farmTicker farm token ticker\n     * @return NFT name\n     */\n\n    function generateName(string memory cohortName, string memory farmTicker) internal pure returns (string memory) {\n        return string(abi.encodePacked(farmTicker, ' ', '(', cohortName, ')'));\n    }\n\n    /**\n     * @dev construct the first segment of description\n     * @param tokenId farm token address\n     * @param cohortName cohort name\n     * @param stakeTokenTicker farm token ticker\n     * @param cohortId cohort contract address\n     * @return long description\n     */\n\n    function generateDescriptionSegment1(\n        uint256 tokenId,\n        string memory cohortName,\n        string memory stakeTokenTicker,\n        string memory cohortId\n    ) internal pure returns (string memory) {\n        return (\n            string(\n                abi.encodePacked(\n                    'This NFT denotes your staking on Unifarm. Owner of this nft can Burn or sell on any NFT marketplace. please check staking details below. \\\\n',\n                    'Token Id :',\n                    tokenId.toString(),\n                    '\\\\n',\n                    'Cohort Name :',\n                    cohortName,\n                    '\\\\n',\n                    'Cohort Address :',\n                    cohortId,\n                    '\\\\n',\n                    'Staked Token Ticker :',\n                    stakeTokenTicker,\n                    '\\\\n'\n                )\n            )\n        );\n    }\n\n    /**\n     * @dev construct second part of description\n     * @param stakedAmount user staked amount\n     * @param confirmedEpochs number of confirmed epochs\n     * @param stakedBlock block on which user staked\n     * @param isBoosterAvailable true, if user bought booster pack\n     * @return long description\n     */\n\n    function generateDescriptionSegment2(\n        uint256 stakedAmount,\n        uint256 confirmedEpochs,\n        uint256 stakedBlock,\n        bool isBoosterAvailable\n    ) internal pure returns (string memory) {\n        return (\n            string(\n                abi.encodePacked(\n                    'Staked Amount :',\n                    stakedAmount.toString(),\n                    '\\\\n',\n                    'Confirmed Epochs :',\n                    confirmedEpochs.toString(),\n                    '\\\\n',\n                    'Staked Block :',\n                    stakedBlock.toString(),\n                    '\\\\n',\n                    'Booster: ',\n                    isBoosterAvailable ? 'Yes' : 'No'\n                )\n            )\n        );\n    }\n\n    /**\n     * @dev construct SVG with available information\n     * @param svgParams it includes all the information of user staking\n     * @return svg\n     */\n\n    function generateSVG(DescriptionParam memory svgParams) internal pure returns (string memory) {\n        return\n            string(\n                abi.encodePacked(\n                    '<svg width=\"350\" height=\"350\" viewBox=\"0 0 350 350\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">',\n                    generateBoosterIndicator(svgParams.isBoosterAvailable),\n                    generateRectanglesSVG(),\n                    generateSVGTypography(svgParams),\n                    generateSVGTypographyForRectangles(svgParams.tokenId, svgParams.stakedBlock, svgParams.confirmedEpochs),\n                    '<text x=\"45\" y=\"313\" fill=\"#FFF\" font-size=\".75em\" font-family=\"Arial, Helvetica, sans-serif\">',\n                    svgParams.stakedAmount.toString(),\n                    '</text>',\n                    generateSVGDefs()\n                )\n            );\n    }\n\n    /**\n     * @dev generate svg rectangles\n     * @return svg rectangles\n     */\n\n    function generateRectanglesSVG() internal pure returns (string memory) {\n        return\n            string(\n                abi.encodePacked(\n                    '<path d=\"M38 162a5 5 0 0 1 5-5h78a5 5 0 0 1 5 5v22a5 5 0 0 1-5 5H43a5 5 0 0 1-5-5v-22Zm0 38a5 5 0 0 1 5-5h147a5 5 0 0 1 5 5v22a5 5 0 0 1-5 5H43a5 5 0 0 1-5-5v-22Zm0 38a5 5 0 0 1 5-5h180a5 5 0 0 1 5 5v22a5 5 0 0 1-5 5H43a5 5 0 0 1-5-5v-22Zm0 42.969c0-4.401 2.239-7.969 5-7.969h210c2.761 0 5 3.568 5 7.969v35.062c0 4.401-2.239 7.969-5 7.969H43c-2.761 0-5-3.568-5-7.969v-35.062Z\" fill=\"#293922\" fill-opacity=\".51\"/>'\n                )\n            );\n    }\n\n    /**\n     * @dev generate booster indicator\n     * @param isBoosted true, if user bought the booster pack\n     * @return booster indicator\n     */\n\n    function generateBoosterIndicator(bool isBoosted) internal pure returns (string memory) {\n        return\n            string(\n                abi.encodePacked(\n                    '<g clip-path=\"url(#a)\">',\n                    '<rect width=\"350\" height=\"350\" rx=\"37\" fill=\"url(#b)\"/>',\n                    '<rect x=\"15.35\" y=\"14.35\" width=\"315.3\" height=\"318.3\" rx=\"29.65\" stroke=\"#D6D6D6\" stroke-opacity=\".74\" stroke-width=\".7\"/>',\n                    generateRocketIcon(isBoosted),\n                    '</g>'\n                )\n            );\n    }\n\n    /**\n     * @dev generate rocket icon\n     * @param isBoosted true, if user bought the booster pack\n     * @return rocket icon\n     */\n    function generateRocketIcon(bool isBoosted) internal pure returns (string memory) {\n        return\n            isBoosted\n                ? string(\n                    abi.encodePacked(\n                        '<path d=\"M49 75h62a5 5 0 0 1 5 5v12a5 5 0 0 1-5 5H49V75Z\" fill=\"#C4C4C4\"/>',\n                        '<circle cx=\"49\" cy=\"86\" r=\"10.5\" fill=\"#C4C4C4\" stroke=\"#fff\"/>',\n                        '<path d=\"m43.832 90.407 4.284-4.284.758.757-4.285 4.284-.757-.757Z\" fill=\"#fff\"/>',\n                        '<path d=\"M49.036 94a.536.536 0 0 1-.53-.46l-.536-3.75 1.072-.15.401 2.823 1.736-1.399v-4.028a.534.534 0 0 1 .155-.38l2.18-2.181a4.788 4.788 0 0 0 1.415-3.407v-.996h-.997a4.788 4.788 0 0 0-3.407 1.414l-2.18 2.18a.536.536 0 0 1-.38.156h-4.029l-1.398 1.746 2.823.402-.15 1.071-3.75-.536a.537.537 0 0 1-.342-.867l2.142-2.679a.536.536 0 0 1 .418-.209h4.066l2.02-2.025A5.85 5.85 0 0 1 53.932 79h.997A1.071 1.071 0 0 1 56 80.072v.996a5.853 5.853 0 0 1-1.725 4.168l-2.025 2.02v4.065a.537.537 0 0 1-.203.418l-2.679 2.143a.535.535 0 0 1-.332.118Z\" fill=\"#fff\"/>'\n                    )\n                )\n                : '';\n    }\n\n    /**\n     * @dev generate typography for NFTSVG with rectangle fields\n     * @param tokenId NFT tokenId\n     * @param stakedBlock user staked block\n     * @param confirmedEpochs staking confirmed epochs\n     * @return typography for NFTSVG\n     */\n\n    function generateSVGTypographyForRectangles(\n        uint256 tokenId,\n        uint256 stakedBlock,\n        uint256 confirmedEpochs\n    ) internal pure returns (string memory) {\n        return\n            string(\n                abi.encodePacked(\n                    '<text x=\"45\" y=\"177\" fill=\"#FFF\" font-size=\".75em\" font-family=\"Arial, Helvetica, sans-serif\">'\n                    'ID: ',\n                    tokenId.toString(),\n                    '</text>',\n                    '<text x=\"45\" y=\"216\" fill=\"#FFF\" font-size=\".75em\" font-family=\"Arial, Helvetica, sans-serif\">',\n                    'Staked block: ',\n                    stakedBlock.toString(),\n                    '</text>',\n                    '<text x=\"45\" y=\"254\" fill=\"#FFF\" font-size=\".75em\" font-family=\"Arial, Helvetica, sans-serif\">',\n                    'Confirmed epochs: ',\n                    confirmedEpochs.toString(),\n                    '</text>'\n                    '<text x=\"45\" y=\"292\" fill=\"#FFF\" font-size=\".75em\" font-family=\"Arial, Helvetica, sans-serif\">',\n                    'Staked Amount: ',\n                    '</text>'\n                )\n            );\n    }\n\n    /**\n     * @dev create typography for SVG header\n     * @param params it includes all the information of user staking\n     * @return typography for SVG header\n     */\n\n    function generateSVGTypography(DescriptionParam memory params) internal pure returns (string memory) {\n        DescriptionParam memory svgParam = params;\n        return\n            string(\n                abi.encodePacked(\n                    '<text x=\"36\" y=\"65\" fill=\"#fff\" font-size=\"1em\" font-family=\"Arial, Helvetica, sans-serif\">',\n                    generateName(svgParam.cohortName, svgParam.stakeTokenTicker),\n                    '</text>',\n                    generateBoostedLabelText(svgParam.isBoosterAvailable),\n                    '<text x=\"40\" y=\"127\" fill=\"#FFF\" font-size=\".75em\" font-family=\"Arial, Helvetica, sans-serif\">',\n                    '<tspan x=\"40\" dy=\"0\">Cohort Address:</tspan>',\n                    '<tspan x=\"40\" dy=\"1.2em\">',\n                    svgParam.cohortAddress,\n                    '</tspan>',\n                    '</text>'\n                )\n            );\n    }\n\n    /**\n     * @dev create boosted label text for NFT SVG\n     * @param isBoosted true, if user bought the booster pack\n     * @return boosted label text\n     */\n\n    function generateBoostedLabelText(bool isBoosted) internal pure returns (string memory) {\n        return\n            isBoosted\n                ? string(\n                    abi.encodePacked(\n                        '<text x=\"64\" y=\"90\" fill=\"#fff\" font-size=\".75em\" font-family=\"Arial, Helvetica, sans-serif\">',\n                        'Boosted',\n                        '</text>'\n                    )\n                )\n                : '';\n    }\n\n    /**\n     * @dev create defs for NFT SVG\n     * @return defs\n     */\n    function generateSVGDefs() internal pure returns (string memory) {\n        return\n            string(\n                abi.encodePacked(\n                    '<defs>',\n                    '<linearGradient id=\"b\" x1=\"44.977\" y1=\"326.188\" x2=\"113.79\" y2=\"-21.919\" gradientUnits=\"userSpaceOnUse\">',\n                    '<stop stop-color=\"#730AAC\"/>',\n                    '<stop offset=\".739\" stop-color=\"#A2164A\"/>',\n                    '</linearGradient>',\n                    '<clipPath id=\"a\">',\n                    '<rect width=\"350\" height=\"350\" rx=\"37\" fill=\"#fff\"/>',\n                    '</clipPath>',\n                    '</defs>',\n                    '</svg>'\n                )\n            );\n    }\n\n    /**\n     * @dev create NFT Token URI\n     * @param descriptionParam it includes all the information of user staking\n     * @return NFT Token URI\n     */\n\n    function createNftTokenURI(DescriptionParam memory descriptionParam) internal pure returns (string memory) {\n        string memory name = generateName(descriptionParam.cohortName, descriptionParam.stakeTokenTicker);\n        string memory description = string(\n            abi.encodePacked(\n                generateDescriptionSegment1(\n                    descriptionParam.tokenId,\n                    descriptionParam.cohortName,\n                    descriptionParam.stakeTokenTicker,\n                    descriptionParam.cohortAddress\n                ),\n                generateDescriptionSegment2(\n                    descriptionParam.stakedAmount,\n                    descriptionParam.confirmedEpochs,\n                    descriptionParam.stakedBlock,\n                    descriptionParam.isBoosterAvailable\n                )\n            )\n        );\n        string memory svg = Base64.encode(bytes(generateSVG(descriptionParam)));\n        return\n            string(\n                abi.encodePacked(\n                    'data:application/json;base64,',\n                    string(\n                        Base64.encode(\n                            bytes(\n                                abi.encodePacked(\n                                    '{',\n                                    '\"name\":',\n                                    '\"',\n                                    name,\n                                    '\"',\n                                    ',',\n                                    '\"description\":',\n                                    '\"',\n                                    description,\n                                    '\"',\n                                    ',',\n                                    '\"image\":',\n                                    '\"data:image/svg+xml;base64,',\n                                    svg,\n                                    '\"',\n                                    '}'\n                                )\n                            )\n                        )\n                    )\n                )\n            );\n    }\n}\n"
    },
    "contracts/proxy/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/utils/Initializable.sol)\n\npragma solidity =0.8.9;\n\nimport '../utils/AddressUpgradeable.sol';\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() initializer {}\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice\n     */\n    modifier initializer() {\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\n        // contract may have been reentered\n        require(_initializing ? _isConstructor() : !_initialized, 'CIAI');\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} modifier, directly or indirectly\n     */\n    modifier onlyInitializing() {\n        require(_initializing, 'CINI');\n        _;\n    }\n\n    function _isConstructor() private view returns (bool) {\n        return !AddressUpgradeable.isContract(address(this));\n    }\n}\n"
    },
    "contracts/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity =0.8.9;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, 'Address: insufficient balance');\n\n        (bool success, ) = recipient.call{value: amount}('');\n        require(success, 'Address: unable to send value, recipient may have reverted');\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, 'Address: low-level call failed');\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, 'Address: low-level call with value failed');\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, 'Address: insufficient balance for call');\n        require(isContract(target), 'Address: call to non-contract');\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, 'Address: low-level static call failed');\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), 'Address: static call to non-contract');\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    }
  }
}}