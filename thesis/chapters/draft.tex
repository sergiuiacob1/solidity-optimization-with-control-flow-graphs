\chapter*{Draft} 
\addcontentsline{toc}{chapter}{Draft}

\section{Local optimizations}
Optimizing for loops.

\begin{lstlisting}[language=solidity]
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;

contract VariableInsideLoop {
    function declareVariableInsideLoop() public pure {
        for (uint i = 1; i <= 1000; i++) {
            uint x = i * i;
        }
    }

    function declareVariableOutsideLoop() public pure {
        uint x;
        for (uint i = 1; i <= 1000; i++) {
            x = i * i;
        }
    }
}
\end{lstlisting}

\^ Compiled with solidity 0.8.7, no optimizations enabled.
inside loop gas cost: 420223 gas
outside loop gas cost: 415250 gas

with 200 optimization runs:
inside loop gas cost: 237215 gas
outside loop gas cost: 232242 gas

Still lower!

\begin{lstlisting}[language=bash]
sergiuiacob@Sergius-MacBook-Pro dataset % solhint variable_declaration_loops.sol

\end{lstlisting}

solhint outputs nothing – it sees no issues

nor does solium (eth lint)


\begin{lstlisting}[language=bash]
sergiuiacob@Sergius-MacBook-Pro dataset % solium -f variable_declaration_loops.sol

No issues found.

sergiuiacob@Sergius-MacBook-Pro dataset % solium -f variable_declaration_if.sol

No issues found.

\end{lstlisting}


variable declaration inside if: 21217 gas
variable declaration outside if: 21274 gas
in this case, outside consumes more gas

200 optimization runs did not change anything

> DISPATCH GAS!!!







TODOs
* test cu persistent var
* TODO ce se intampla daca am acelasi assignment si in outer scope, si in block scope?
* acelasi gen aceeasi_var = aceeasi_val
* pe termination3.sol
  * exemplu ce se intampla cand rulez doar 'Dru'
  * exemplu cum se simplifica si mai mult (datorita static analysis) cand rulez toata suita de optimizatori




Important
* In YUL IR, pot fi instructiuni dupa o instructiune de leave!!!
  * Rezolvat de DeadCodeEliminator
* NU SCOATE assign-ment-urile pentru state variables!!!


Resurse utile
* tips n tricks cu YULs, poate e ceva de folos: https://hackmd.io/@gn56kcRBQc6mOi7LCgbv1g/rJez8O8st
* https://homepages.dcc.ufmg.br/~fernando/classes/dcc888/ementa/
* https://etherscan.io/contractsVerified
  * statistici cu cat \% din contracte folosesc solc 0.8
* tool vizualizare relatii functii din contracte https://piet.blockchains.com/?container=examples%2Fexport1562664060589.piet.json 


De adaugat in teza
* What is Data Flow Analysis?
* function dispatch table <- gas dispatch issue I've had

  * The DataFlowAnalyzer currently does not deal with the ``leave`` statement. This is because
  * it only matters at the end of a function body, which is a point in the code a derived class
  * can not easily deal with.
  ^ Asta scrie in DataFlowAnalyzer.h
* am folosit truffle framework pentru a calcula gas usage-ul in experimentele mele (care ele este doar 1)
* toate variantele pe care le poate lua un assignment


De adaugat in prezentare
* Solidity Summit 2022 – merge la bibliografie I guess.
* https://meet.ethereum.org/solidity – asking questions here. How to make a difference?
* Scheme
  * optimization pipeline (cod solidity -> YUL IR -> YUL optimizer -> EVM Bytecode -> EVM Optimizer (LLVM???) -> bytecode)
* Ce este un dialect. Despre EVM Dialect (folosit de Yul IR)
* cum functioneaza UAE: in documentatie scrie https://docs.soliditylang.org/en/v0.8.14/internals/optimizer.html#redundantassigneliminator
* Despre ce e un AST. Solidity foloseste ANTLR – https://medium.com/@obernardovieira/why-is-ast-so-important-b1e7d6c29260
Proces dezvoltare dizertatie
* Problema: se lucra deja la multe dintre contributiile pe care le consideram sa le fac in solidity de persoane random. trebuia sa gasesc un "free slot" la lucrat la ceva
* Cat de mult ajuta UAE? Experiment cu deployment pt un contract, o functie simpla. Cu si fara optimizarea UAE. DOAR CU ACEEEA!!! Cat gaz se salveaza?
* Am vrut sa imbunatatesc UAE pe AST-ul de pe Solidity – dar dupa o discutie cu echipa Solidity, mi-au clarificat ca optimizarile ar trebui facute pe YUL IR – care are si el un AST, doar ca nu e outputted, e in code base ---> mai dificil
* https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.453.4245&rep=rep1&type=pdf 
* Fuzzing tests – trying to break the compiler with Etherscan
* default optimization suite de fapt nu e aia prezentata in documentatie – e outdated
  * 'dhfoDgvulfnTUtnIf[xa[r]EscLMcCTUtTOntnfDIulLculVcul [j]Tpeulxa[rul]xa[r]cLgvifCTUca[r]LSsTFOtfDnca[r]Iulc]jmul[jul] VcTOcul jmul'
  * asta pare sa fie... printre altele

Random stuff
  * https://hrkrshnn.com/ prezentari
  * despre patterns care sunt costly dpdv al gazului https://computerscience.unicam.it/marcantoni/tesi/Ethereum%20Smart%20Contracts%20Optimization.pdf
  * despre completeness / corectness CFG https://eprints.ucm.es/id/eprint/61812/1/HERNANDEZ_CEREZO_Tecnicas_de_analisis_para_contratos_inteligentes_generacion_de_grafos_de_control_de_flujo_completos_4398577_720285146.pdf
  * SIF: https://arxiv.org/pdf/1905.01659.pdf
  * basic blocks, etc https://homepages.dcc.ufmg.br/~fernando/classes/dcc888/ementa/slides/ControlFlowGraphs.pdf
  * dispatch gas difference (ce m-a indus pe mine in eroare) slide 11 din https://hrkrshnn.com/t/devconnect.pdf
    * tot intr-una din prezentarile de aici zice ca "opcode optimization should be kept as simple as possible – engineering decision)
  * detaliu: Ethereum blockchain only stores EVM bytecode, so the high level code needs to be optimized before turned into EVM, of course
  * https://eprints.ucm.es/id/eprint/61812/1/HERNANDEZ_CEREZO_Tecnicas_de_analisis_para_contratos_inteligentes_generacion_de_grafos_de_control_de_flujo_completos_4398577_720285146.pdf     <------------- tool care imbunatateste Oyente / EthIR si gaseste security flaws. poate fi aplicat pe codul pe care il generez eu
  * optimizer passes (etape): pot fi platform independent / dependent
  * optimizari facute pe baza YUL, example: function inlining https://www.youtube.com/watch?v=VH4MgZDyZJU&ab_channel=EthereumFoundation
  * despre cum CFG-urile sunt folosite: "Gastap is one of the few tools based on static analysis that manages to infer gas upper
  bounds for transactions. Gastap is one of the most accurate tools in the field, having a
  great success rate. It generates a Control-Flow-Graph (CFG) as an intermediate representation of the analysis. However, the current algorithm used by Gastap is not precise.
  Therefore, a considerable number of smart contracts cannot be analyzed." din https://eprints.ucm.es/id/eprint/61812/1/HERNANDEZ_CEREZO_Tecnicas_de_analisis_para_contratos_inteligentes_generacion_de_grafos_de_control_de_flujo_completos_4398577_720285146.pdf
  * alte moduri in care lumea interpreteaza cod solidity, ex asta cu XML-uri ca sa foloseasca query-uri XPath apoi https://orbilu.uni.lu/bitstream/10993/35862/3/smartcheck-paper.pdf



Misc stuff
* adaugat screenshot cu llvm-opt --help (optimizarile pe care le poate face)
* de vorbit despre ce e "--optimize-runs" (scrie in doc oficial). trade off intre code size / code efficiency
* Simple Inlining a fost adaugat in solidity 0.8.2!!! super recent
* YUL optimizer: "The optimizer currently follows a purely greedy strategy and does not do any backtracking."
* Issues gasite in timp ce lucram la dizertatie
  * cand se construieste AST (--ast-compact-json), la pgrama valoarea pentru "src" nu e corecta, gen de unde pana unde tine codul pt pragma directive
* de folosit un tool online si de aratat cum functioneaza UAE (solc --optimize --ir-optimized --via-ir --yul-optimizations 'r'  termination.sol | pbcopy), o data cu '' si o data cu 'r'    –   https://text-compare.com/

Proprietati noduri CFG
* The	flow	of	control	can	only	
enter	the	basic	block	through	
the	first	instruction	in	the	
block.

Proprietati pentru solidity optimizer (on YUL)
* Disambiguatorul seteaza unique names pt fiecare functie / variabila
* loop related optimizations
  * stop condition is moved into the loop body
  * loop initialization body is moved before the loop
  * majoritatea optimizarilor listate in documentatia oficiala (0.8.14) graviteaza in jurul precalcularii constantelor si propagarii acestora

----din https://homepages.dcc.ufmg.br/~fernando/classes/dcc888/ementa/slides/ControlFlowGraphs.pdf

* first instruction of a block == leader (multiple moduri de a identifica leaders)
* basic blocks pot fi construite in functie de leader-ii identificati
  * un basic block incepe la primul leader si se termina la urmatorul leader

Idei cu ce pot face
* CFG intre contracte?
* diferite rezolutii CFG
* vizualizare CFG (graphviz?)
* dead code elimination (https://homepages.dcc.ufmg.br/~fernando/classes/dcc888/ementa/slides/ControlFlowGraphs.pdf)
  * ca pas intr-un CI
* izolarea codului – cred ca daca iau toate variabilele si le izolez (gen ce e folosit intr-un if sa fie definit acolo) etc. atunci o sa consume mai putin gas
* pentru a-mi testa softul: idei in capitolul 8.1 din https://eprints.ucm.es/id/eprint/61812/1/HERNANDEZ_CEREZO_Tecnicas_de_analisis_para_contratos_inteligentes_generacion_de_grafos_de_control_de_flujo_completos_4398577_720285146.pdf
* ma pot intepa in StructuralSimplifier + Dataflow Analyzer deja existente in solc

Optimizari deja facute de solc
* LoopInvariantCodeMotion – ce vreau eu sa fac de fapt https://docs.soliditylang.org/en/v0.8.14/internals/optimizer.html#loopinvariantcodemotion
  * "variable declarations inside conditional branches will not be moved out of the loop" <- posibilitate de improvement
* Local common subexpression eliminator
* citat din doc oficial: "specializes or inlines functions" (probabil on in loc de or)
  * todo aici, de aratat un exemplu pe YUL direct, inlined vs uninlined (--optimize --ir-optimized versus --ir)


Tipuri de optimizari
* local optimizations – in interiorul unui basic block

Pentru prezentare, Proof of Concept:
* programul meu intr-un CI care propune optimizari la PR-uri pentru cod ;)


How does LLVM work? Let's take that for example
* Virtual Register Allocation (ca exemplu)
https://homepages.dcc.ufmg.br/~fernando/classes/dcc888/ementa/slides/ControlFlowGraphs.pdf