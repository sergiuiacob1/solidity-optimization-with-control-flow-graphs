\chapter{Validation and benchmarking}
\paragraph*{}
In the optimization world, corectness comes before performance. Ensuring correctness of compiler enhancements is mandatory before even discussing about gas usage improvements. In order to ensure that the modifications done to the compiler do not alter the semantics of a smart contract, validation was done using unit testing, contract fuzzing and tests against the Etherscan dataset.

\paragraph*{}
The advantage of forking the Solidity eco-system and integrating the enhancements directly in the official codebase is that a first validation pass can be done by simply running the existing unit tests, and then extending those. All of the unit tests have passed. An additional validation was done by fuzzing, which in software development acts as a tool that generates random data for automated testing purposes. In the case of Solidity, fuzzing is used to construct valid, random smart contracts and make sure that they still compile. This also helps with regression testing, as fuzzing may ocassionally construct valid smart contracts that cannot be compiled anymore.

\paragraph*{}
A testing experiment was done using the online Etherscan dataset, which contains a series of verified smart contracts. The experiment meant acquiring all of the addresses for the 5000 \footnote{5000 is the imposed limit by the Etherscan API} available verified constracts from the Etherscan dataset, then downloading the source code for all of the contracts. Then, all of the smart contracts using lower versions of the Solidity compiler were discarded, i.e. files that did not match the pragma of \lstinline[columns=fixed]{pragma solidity ^0.8.14} in our case. As a validation step, all of the contracts that were compilable with the official 0.8.14 compiler release also needed to be compilable with the enhanced 0.8.14 compiler, step which passed.

\paragraph*{}
While validation was successful, contracts from the Etherscan network (at the time of writing this thesis) showed no benefits in the gas estimates of the contract construction. This might also be because most of the contracts returned ``infinite'' as a gas estimate, which is due to instructions such as loops in the code or recursive function calls. This is to be expected, since the edge cases described in this thesis are most likely the result of code mistakes on the developers' side, mistakes which often get caught during steps of code review. However, it is not excluded that future changes to the optimizer codebase will take advantage of the enhancements described in the previous chapter.
